---
title: 性能测试（三）性能测试的执行与分析
date: 2017-05-15 17:23:32
tags: 性能
copyright: true
password:
toc: true
---

本文章介绍性能测试的执行与分析。

<!--more-->
## Quick Guide

### 性能测试执行

* 人工边执行边分析
* 无人值守执行性能测试：利用业务或者系统空闲时间测试
  
#### 注意事项

* 如果在线上或者uat，要考虑对业务的影响，跟开发及时沟通测试场景，尽量业务或者系统空闲时间测试
* 记录性能指标(数值和图片)：图片还是必须的记录，测试周期长可能存在记录错误或者争论
* 监控请求是否正常,分析失败原因
* 测试总体曲线是否呈现波峰或者随着请求量增大趋于水平

### 结果分析与调优

#### 结果分析

1. 测试结果是否满足性能指标
2. 满足，开始写性能报告；不满足，是否受到哪方面限制或者其他因素，跟需求方确实是否需要调优，调优进行下一节初步分析，然后跟架构师和开发确定方案。

##### 注意事项

* 1.测试曲线远离预想
  * 可能是被测系统接受的tps不同于实际执行机发出，在被测机器增加日志打印之类方式去统计接受到的需求
  * 触发特殊的系统机制
* 2.请求出现较高的错误率
   * 查看返回的错误信息
   * 检查网络是否稳定
   * 检查中间组件异常
   * 检查数据库是否重启
   * 集群检查每个节点是否正常
* 3.集群测试平均性能小于单机
   * 负债均衡组件分发速度是否受到限制，处理太慢
   * 分发规则是否对每一台单机发送的请求量大体一致 

#### 系统瓶颈分析

整体思路：从前到后，从表象到内部:

* 1.首先排除压力机自身的问题，如CPU、内存，网络，脚本编写等
* 2.监控中间件的访问日志，观察响应时间，大体确定耗时处于哪一段
* 3.排查网络问题，监控压力机到后端服务器的网络，以及各服务器间的网络，是否达到网络上限
* 4.监控服务端所有机器的操作系统负载，如CPU、内存、磁盘、网络是否达到瓶颈
* 5.监控应用服务器的日志，查看是否存在ERROR日志，比如TimeOut或其他类型报错
* 6.监控各中间件的连接数，如nginx、tomcat、mysql等，是否达到上限
* 7.监控应用程序线程状态，使用jstack或jvisualvm查看是否有死锁、阻塞等情况
* 8.监控应用程序的jvm，使用jstat或者jmap查看GC情况，是否内存泄漏等
* 9.使用jprofiler监控应用程序，可以查看耗时比较长的代码方法
* 10.监控数据库，是否存在慢查询，一般数据库CPU高都是因为SQL语句效率低造成的
  * 在sql语句前加上explain，可以分析这条sql语句的执行情况 explain select * from t_order_loop_refund  where name = '小明'；
    * Type列可能的值
              Const：表中只有一个匹配行，用到primary key或unique key
              Eq_ref：唯一性索引扫描，key的所有部分被连接联接查询使用，且key是unique或primary key
              ref：非唯一性索引扫描，或只使用了联合索引的最左前缀
              Range：索引范围扫描，在索引列上进行给定范围内的检索，如between，in（1,100）
              Index：遍历索引...
              All：全表扫描
              Prossible key：使用哪个索引能找到行
              Keys：sql语句使用的索引
              rows：mysql 根据索引选择情况，估算查找数据所需读取的行数

    ![](/image/性能测试03_001.png)

    * 联合索引
    * 连接数
    * 数据库架构优化
      * 读写分离，主从配置
      * 硬件调优 
* 11.检查数据库执行计划，是否有全表扫描，以及索引不生效的情况
* 12.检查系统外部依赖情况，如果外部依赖系统性能差，也会造成本系统性能低
* 13.对于不好定位的问题，可以考虑采用模块隔离法来确定问题 

#### 优化方案

* sql
    1. 在 where 及 order by 涉及的列上建立索引，避免全表扫描，索引不要太多，一个表一般不要
    超过4个索引
    2. 避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描
    3. 查询语句中不要使用 *，减少内存使用
    4. 尽量减少子查询，使用关联查询（left join,right join,inner join）替代
    5. 减少使用IN或者NOT IN ,使用exists，not exists或者关联查询语句替代
    6. or 的查询尽量用 union或者union all 代替(在确认没有重复数据或者不用剔除重复数据时，
    union all会更好)
    7. 合理的增加冗余的字段（减少表的联接查询）
    8. 建表的时候能使用数字类型的字段就使用数字类型（type,status...），数字类型的字段作为条件查询比字符串的快
* 代码
    1. 使用对象池减少对重复对象的创建；
    2. 调整对后端的连接
    3. 增加本地缓存
    4. 如果不涉及事务的情况下，考虑使用Nosql进行存储
    5. 一次请求合并多次操作
    6. 由串行修改为并行操作
    7. 同步修改为异步

### 测试报告与总结

* 测试计划
* 业务流程
* 测试环境
* 测试场景：把测试场景罗列，并放上对于性能结果和资源占用率的图片
* 结果与分析：把测试性能指标与实际结果罗列对比，说明存在哪些问题
* 结论：问题和是否满足标准
* 风险点：存在哪些风险需要考虑，怎么去规避