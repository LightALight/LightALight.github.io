<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Keep It Simple Do It Well</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lightalight.github.io/"/>
  <updated>2022-07-12T14:39:50.711Z</updated>
  <id>https://lightalight.github.io/</id>
  
  <author>
    <name>Light A Light</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>安全性测试（一）安全性测试的基本概念</title>
    <link href="https://lightalight.github.io/2021/10/15/%E5%AE%89%E5%85%A8%E6%80%A7%E6%B5%8B%E8%AF%9501/"/>
    <id>https://lightalight.github.io/2021/10/15/安全性测试01/</id>
    <published>2021-10-15T11:23:32.000Z</published>
    <updated>2022-07-12T14:39:50.711Z</updated>
    
    <content type="html"><![CDATA[<p>软件因为漏洞，导致产品的数据泄露、功能受到影响和系统被入侵等危害。安全测试就是为了发现这些问题，并给予一定的安全评估。<br>本文章主要介绍如何进行软件的安全性测试。</p><a id="more"></a><h2 id="Quick-Guide"><a href="#Quick-Guide" class="headerlink" title="Quick Guide"></a>Quick Guide</h2><h3 id="安全方面"><a href="#安全方面" class="headerlink" title="安全方面"></a>安全方面</h3><ul><li>应用程序层的安全<ul><li>应用程序本身的安全性</li><li>应用程序的数据安全</li></ul></li><li>操作系统的安全</li><li>网络的安全</li></ul><h3 id="安全测试的要求"><a href="#安全测试的要求" class="headerlink" title="安全测试的要求"></a>安全测试的要求</h3><ol><li>熟悉常见漏洞、逻辑漏洞的原理和检测方式</li><li>较强编程能力，能使用脚本或者安全工具检测漏洞</li><li>做好安全评估</li></ol><h4 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h4><h5 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h5><h6 id="外部"><a href="#外部" class="headerlink" title="外部"></a>外部</h6><table><thead><tr><th style="text-align:center">种类</th><th style="text-align:center">类型</th><th>简单描述</th></tr></thead><tbody><tr><td style="text-align:center">通用漏洞</td><td style="text-align:center">暴力破解</td><td>利用密码字典循环去破解密码</td></tr><tr><td style="text-align:center">通用漏洞</td><td style="text-align:center">SQL注入</td><td>注入攻击漏洞,这些攻击发生在当不可信的SQL语句作为命令或者查询语句的一部分,被发送给解释器的时候。攻击者发送的恶意数据可以欺骗解释器,以执行计划外的命令或者在未被恰当授权时访问数据。</td></tr><tr><td style="text-align:center">通用漏洞</td><td style="text-align:center">XPath注入</td><td>XPath注入攻击是指利用XPath 解析器的松散输入和容错特性，能够在URL、表单或其它信息上附带恶意的XPath 查询代码，以获得权限信息的访问权并更改这些信息。XPath注入攻击是针对Web服务应用新的攻击方法，它允许攻击者在事先不知道XPath查询相关知识的情况下，通过XPath查询得到一个XML文档的完整内容。</td></tr><tr><td style="text-align:center">通用漏洞</td><td style="text-align:center">不安全的加密存储</td><td>未对需要保护的数据进行加密或者加密算法太弱都是不安全的加密存储</td></tr><tr><td style="text-align:center">通用漏洞</td><td style="text-align:center">敏感信息泄露</td><td>许多Web应用程序没有正确保护敏感数据,如信用卡、税务ID和身份验证凭据。攻击者可能会窃取或篡改这些弱保护的数据以进行信用卡诈骗、身份窃取或其他犯罪。敏感数据值需额外的保护,比如在存放或在传输过程中的加密,以及在与浏览器交换时进行特殊的预防措施。</td></tr><tr><td style="text-align:center">通用漏洞</td><td style="text-align:center">XSS跨站脚本攻击</td><td>恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意用户的特殊目的。</td></tr><tr><td style="text-align:center">通用漏洞</td><td style="text-align:center">CSRF跨站请求伪造</td><td>攻击者通过调用第三方网站的恶意脚本来伪造请求，在用户不知情的情况下，攻击者强行递交构造的具有“操作行为”的数据包。（测试对象：网页中可进行输入的表单）</td></tr><tr><td style="text-align:center">逻辑漏洞</td><td style="text-align:center">篡改输入</td><td>利用一些命令或者工具等篡改一些字段的值，从而达到恶意的效果。例如，篡改商品的单价和数量等。</td></tr><tr><td style="text-align:center">逻辑漏洞</td><td style="text-align:center">不安全的直接对象引用</td><td>在具有导出/下载功能的页面参数中修改内容，WEB服务器便会导出/下载程序源代码或者指定文件（测试对象：URL中有用户参数的地址，可以进行下载操作的地址）或者当开发人员暴露一个对内部实现对象的引用时,例如,一个文件、目录或者数据库密匙, 就会产生一个不安全的直接对象引用。在没有访问控制检测或其他保护时,攻击者会操控这些引用去访问未授权数据</td></tr><tr><td style="text-align:center">逻辑漏洞</td><td style="text-align:center">功能级访问控制缺失</td><td>大多数Web应用程序的功能在UI页面显示之前,会验证功能级别的访问权限。但是,应用程序需要在每个功能被访问时在服务器端执行相同的访问控制检查。如果请求没有被验证,攻击者能够伪造请求从而在未经适当授权时访问功能。</td></tr><tr><td style="text-align:center">逻辑漏洞</td><td style="text-align:center">缓冲区溢出</td><td>当计算机向缓冲区内填充数据位数时超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上。</td></tr><tr><td style="text-align:center">逻辑漏洞</td><td style="text-align:center">失效的身份验证机制</td><td>只对首次传递的Cookie加以验证，程序没有持续对Cookie中内含信息验证比对，攻击者可以修改Cookie中的重要信息以提升权限进行网站数据存取或是冒用他人账号取得个人私密资料（测试对象：可以进行传参的URL，提交请求页面，登录后的Cookie）</td></tr><tr><td style="text-align:center">逻辑漏洞</td><td style="text-align:center">会话管理劫持</td><td>检测Web应用程序会话机制是否存在安全隐患，能否被非法利用（会话劫持，伪装成合法用户）而影响Web应用程序的安全。</td></tr><tr><td style="text-align:center">逻辑漏洞</td><td style="text-align:center">没有限制URL访问</td><td>系统已经对URL的访问做了限制，但这种限制却实际并没有生效。攻击者能够很容易的就伪造请求直接访问未被授权的页面（测试对象：需要身份验证的页面）</td></tr><tr><td style="text-align:center">逻辑漏洞</td><td style="text-align:center">传输层保护不足</td><td>在身份验证过程中没有使用SSL/TLS，因此暴露传输数据和会话ID，被攻击者截听。它们有时还会使用过期或者配置不正确的证书。（测试对象：登录模块）</td></tr><tr><td style="text-align:center">逻辑漏洞</td><td style="text-align:center">未验证的重定向（redirectUrl）和转发</td><td>攻击者可以引导用户访问他们所要用户访问的站点。而最终造成的后果，重定向会使得用户访问钓鱼网站或是恶意网站。</td></tr><tr><td style="text-align:center">配置漏洞</td><td style="text-align:center">安全配置错误</td><td>Config中的链接字符串以及用户信息，邮件，数据存储信息等都需要加以保护，如果没有进行保护，那么就是安全配置出现了问题。</td></tr><tr><td style="text-align:center">APP漏洞</td><td style="text-align:center">逆向反编译</td><td>通过提供的安装包或者客户端，反编译出原代码获取信息</td></tr><tr><td style="text-align:center">系统漏洞</td><td style="text-align:center">LDAP注入</td><td>利用LDAP注入技术的关键在于控制用于目录搜索服务的过滤器。使用这些技术，攻击者可能直接访问LDAP目录树下的数据库，及重要的公司信息。情况还可能比这更严重，因为许多应用的安全性依赖于基于LDAP目录的单点登录环境。</td></tr><tr><td style="text-align:center">系统漏洞</td><td style="text-align:center">使用含有已知漏洞的组件</td><td>组件,比如:库文件、框架和其他软件模块,几乎总是以全部的权限运行。如果使用含有已知漏洞的组件,这种攻击可以造成更为严重的数据丢失或服务器接管。应用程序使用带有已知漏洞的组件会破坏应用程序防御系统,并使一系列可能的攻击和影响成为可能。危害比较严重</td></tr><tr><td style="text-align:center">系统漏洞</td><td style="text-align:center">操作系统漏洞</td><td>利用操作系统的漏洞，引发系统故障或者窃取信息</td></tr><tr><td style="text-align:center">网络</td><td style="text-align:center">DDoS</td><td>流量攻击，一种针对网络带宽的攻击，即大量攻击包导致网络带宽被阻塞，合法网络包被虚假的攻击包淹没而无法到达主机；一种是为资源耗尽攻击，主要是针对服务器主机的攻击，即通过大量攻击包导致主机的内存被耗尽或CPU被内核及应用程序占完而造成无法提供网络服务</td></tr></tbody></table><h6 id="内部"><a href="#内部" class="headerlink" title="内部"></a>内部</h6><p>社会工程学：通过对人的习惯、心里和数据分析，伪装或者欺骗内部人员获取信息。</p><h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h4><p>使用专业的具有特定功能的安全扫描软件来寻找潜在的漏洞，将已经发生的缺陷纳入缺陷库，然后通过自动化测试方法来使用自动化缺陷库进行轰炸测试。</p><h5 id="安全测试工具"><a href="#安全测试工具" class="headerlink" title="安全测试工具"></a>安全测试工具</h5><ul><li><p><a href="https://www.kali.org/" target="_blank" rel="noopener">Kali Linux</a>：基于Debian的Linux发行版， 设计用于数字取证操作系统。Kali Linux预装了许多渗透测试软件，包括nmap 、Wireshark 、msfvenom、John the Ripper，以及Aircrack-ng，超过300个渗透测试工具，永久免费，开源.</p></li><li><p><a href="https://nmap.org/" target="_blank" rel="noopener">Nmap</a>:一个网络连接端扫描软件，用来扫描网上电脑开放的网络连接端。确定哪些服务运行在哪些连接端，并且推断计算机运行哪个操作系统（这是亦称 fingerprinting）。</p><ul><li><a href="https://blog.csdn.net/m0_37268841/article/details/80404613" target="_blank" rel="noopener">参考</a></li></ul></li><li><p><a href="http://www.openvas.org/" target="_blank" rel="noopener">msfvenom</a>:msfpayload,msfencode的结合体，可利用msfvenom生成木马程序,并在目标机上执行,在本地监听上线。</p><ul><li><a href="https://www.offensive-security.com/metasploit-unleashed/msfvenom/" target="_blank" rel="noopener">参考</a></li></ul></li><li><p><a href="https://www.ibm.com/supply-chain/hcl-divestiture" target="_blank" rel="noopener">AppScan</a>:一款安全漏洞扫描工具，支持Web和移动，现在安全测试做漏洞扫描非常适用，它相当于是”探索”和”测试”的过程，最终生成很直观的测试报告，有助于研发人员分析和修复通常安全测试工具用这个，扫描一些安全漏洞，用起来比较方便，网上资料比较多，适合很多测试同学用，资料广阔，大家可以尝试下。</p><ul><li><a href="https://www.cnblogs.com/benpao1314/p/8065720.html" target="_blank" rel="noopener">参考</a></li></ul></li><li><p><a href="https://portswigger.net/burp/" target="_blank" rel="noopener">Burp Suite</a>:一款信息安全从业人员必备的集 成型的渗透测试工具，它采用自动测试和半自动测试的方式，包含了 Proxy,Spider,Scanner,Intruder,Repeater,Sequencer,Decoder,Comparer等工具模块；Proxy功能可以拦截HTTP/S的代理服务器（手机和web）；Spide功能-智能感应的网络爬虫；Intruder功能可以对web应用程序进行自动化攻击等，非常适合做安全测试。通 过拦截HTTP/HTTPS的web数据包，充当浏览器和相关应用程序的中间人，进行拦截、修改、重放数据包进行测试，是web安全人员的一把必备的瑞士军刀。</p><ul><li><a href="https://www.cnblogs.com/nieliangcai/p/6692296.html" target="_blank" rel="noopener">参考</a></li></ul></li><li><p><a href="https://www.acunetix.com/" target="_blank" rel="noopener">Acunetix</a>:一款网络漏洞扫描软件，它可以检测网络的安全漏洞。</p></li><li><p><a href="http://sqlmap.org/" target="_blank" rel="noopener">sqlmap</a>:一个开源的渗透测试工具，可以用来进行自动化检测，利用SQL注入漏洞，获取数据库服务器的权限。它具有功能强大的检测引擎,针对各种不同类型数据库的渗透测试的功能选项，包括获取数据库中存储的数据，访问操作系统文件甚至可以通过外带数据连接的方式执行操作系统命令。</p><ul><li><a href="https://github.com/sqlmapproject/sqlmap/zipball/master" target="_blank" rel="noopener">下载地址</a></li><li><a href="https://asciinema.org/a/46601" target="_blank" rel="noopener">演示视频</a></li><li><a href="http://www.youtube.com/user/inquisb/videos" target="_blank" rel="noopener">教程</a></li><li><a href="https://www.freebuf.com/sectool/164608.html" target="_blank" rel="noopener">参考</a></li></ul></li><li><p><a href="http://www.openvas.org/" target="_blank" rel="noopener">OpenVAS</a>:一个开放式漏洞评估系统，也可以说它是一个包含着相关工具的网络扫描器。其核心部件是一个服务器，包括一套网络漏洞测试程序，可以检测远程系统和应用程序中的安全问题。OpenVas服务端只允许安装在Linux系统上，接下来我们来介绍一下使用二进制搭建OpenVas的方法以及基础的使用。</p><ul><li><a href="https://www.freebuf.com/column/158357.html" target="_blank" rel="noopener">参考</a></li></ul></li><li><p><a href="http://www.fortify.net/README.html" target="_blank" rel="noopener">fortify</a>:静态代码检查工具</p><ul><li><a href="https://www.freebuf.com/sectool/95683.html" target="_blank" rel="noopener">参考</a></li></ul></li><li><p><a href="https://www.tenable.com/downloads/nessus" target="_blank" rel="noopener">nessus</a>:一款号称是世界上最流行的漏洞扫描程序，全世界有超过75000个组织在使用它。该工具提供完整的电脑漏洞扫描服务，并随时更新其漏洞数据库。Nessus不同于传统的漏洞扫描软件，Nessus可同时在本机或远端上遥控，进行系统的漏洞分析扫描。</p><ul><li><a href="https://www.cnblogs.com/cheyunhua/p/8084459.html" target="_blank" rel="noopener">参考</a></li></ul></li><li><p><a href="https://www.fujieace.com/kali-linux/owasp-zed-zap.html" target="_blank" rel="noopener">zap</a>:OWASP Zed攻击代理（ZAP）是世界上最受欢迎的免费安全审计工具之一，由数百名国际志愿者*积极维护。它可以帮助您在开发和测试应用程序时自动查找Web应用程序中的安全漏洞。</p></li><li><p><a href="https://www.acunetix.com/vulnerability-scanner/" target="_blank" rel="noopener">Acunetix Web Vulnerability Scanner（简称AWVS）</a>:是一款知名的网络漏洞扫描工具，它通过网络爬虫测试你的网站安全，检测流行安全漏洞</p></li></ul><h5 id="测试场景设计"><a href="#测试场景设计" class="headerlink" title="测试场景设计"></a>测试场景设计</h5><ul><li><a href="正向安全测试">正向安全测试</a></li><li><a href="反向安全测试">反向安全测试</a></li></ul><p>正向测试过程是以测试空间为依据寻找缺陷和漏洞，反向测试过程则是以已知的缺陷空间为依据去寻找软件中是否会发生同样的缺陷和漏洞，两者各有其优缺点。反向测试过程主要的一个优点是成本较低，只要验证已知的可能发生的缺陷即可，但缺点是测试不完善，无法将测试空间覆盖完整，无法发现未知的攻击手段。正向测试过程的优点是测试比较充分，但工作量相对来说较大。因此，对安全性要求较低的软件，一般按反向测试过程来测试即可，对于安全性要求较高的软件，应以正向测试过程为主，反向测试过程为辅。</p><h6 id="正向安全测试"><a href="#正向安全测试" class="headerlink" title="正向安全测试"></a>正向安全测试</h6><p>为了规避反向设计原则所带来的测试不完备性，需要一种正向的测试方法来对软件进行比较完备的测试，使测试过的软件能够预防未知的攻击手段和方法。</p><ol><li>先标识测试空间。对测试空间的所有的可变数据进行标识，由于进行安全性测试的代价高昂，其中要重点对外部输入层进行标识。例如，需求分析、概要设计、详细设计、编码这几个阶段都要对测试空间进行标识，并建立测试空间跟踪矩阵。</li><li>精确定义设计空间。重点审查需求中对设计空间是否有明确定义，和需求牵涉到的数据是否都标识出了它的合法取值范围。在这个步骤中，最需要注意的是精确二字，要严格按照安全性原则来对设计空间做精确的定义。</li><li>标识安全隐患。根据找出的测试空间和设计空间以及它们之间的转换规则，标识出哪些测试空间和哪些转换规则可能存在安全隐患。例如,测试空间愈复杂，即测试空间划分越复杂或可变数据组合关系越多也越不安全。还有转换规则愈复杂，则出问题的可能性也愈大，这些都属于安全隐患。</li><li>建立和验证入侵矩阵。安全隐患标识完成后，就可以根据标识出来的安全隐患建立入侵矩阵。列出潜在安全隐患，标识出存在潜在安全隐患的可变数据，和标识出安全隐患的等级。其中对于那些安全隐患等级高的可变数据，必须进行详尽的测试用例设计。</li></ol><h6 id="反向安全测试"><a href="#反向安全测试" class="headerlink" title="反向安全测试"></a>反向安全测试</h6><p>大部分软件的安全测试都是依据缺陷空间反向设计原则来进行的，即事先检查哪些地方可能存在安全隐患，然后针对这些可能的隐患进行测试。因此，反向测试过程是从缺陷空间出发，建立缺陷威胁模型，通过威胁模型来寻找入侵点，对入侵点进行已知漏洞的扫描测试。好处是可以对已知的缺陷进行分析，避免软件里存在已知类型的缺陷，但是对未知的攻击手段和方法通常会无能为力。</p><ol><li>建立缺陷威胁模型。建立缺陷威胁模型主要是从已知的安全漏洞入手，检查软件中是否存在已知的漏洞。建立威胁模型时，需要先确定软件牵涉到哪些专业领域，再根据各个专业领域所遇到的攻击手段来进行建模。</li><li>寻找和扫描入侵点。检查威胁模型里的哪些缺陷可能在本软件中发生，再将可能发生的威胁纳入入侵点矩阵进行管理。如果有成熟的漏洞扫描工具，那么直接使用漏洞扫描工具进行扫描，然后将发现的可疑问题纳入入侵点矩阵进行管理。</li><li>入侵矩阵的验证测试。创建好入侵矩阵后，就可以针对入侵矩阵的具体条目设计对应的测试用例，然后进行测试验证。</li></ol><h5 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h5><ol><li>静态的代码安全测试：主要通过对源代码进行安全扫描，根据程序中数据流、控制流、语义等信息与其特有软件安全规则库进行匹对，从中找出代码中潜在的安全漏洞。静态的源代码安全测试是非常有用的方法，它可以在编码阶段找出所有可能存在安全风险的代码，这样开发人员可以在早期解决潜在的安全问题。而正因为如此，静态代码测试比较适用于早期的代码开发阶段，而不是测试阶段。</li><li>动态的渗透测试：渗透测试也是常用的安全测试方法。是使用自动化工具或者人工的方法模拟黑客的输入，对应用系统进行攻击性测试，从中找出运行时刻所存在的安全漏洞。这种测试的特点就是真实有效，一般找出来的问题都是正确的，也是较为严重的。但渗透测试一个致命的缺点是模拟的测试数据只能到达有限的测试点，覆盖率很低。</li><li>程序数据扫描。一个有高安全性需求的软件，在运行过程中数据是不能遭到破坏的，否则就会导致缓冲区溢出类型的攻击。数据扫描的手段通常是进行内存测试，内存测试可以发现许多诸如缓冲区溢出之类的漏洞，而这类漏洞使用除此之外的测试手段都难以发现。例如，对软件运行时的内存信息进行扫描，看是否存在一些导致隐患的信息，当然这需要专门的工具来进行验证，手工做是比较困难的。</li></ol><h5 id="如何练习"><a href="#如何练习" class="headerlink" title="如何练习"></a>如何练习</h5><ol><li>[搭建一个靶机])(<a href="https://www.freebuf.com/sectool/102661.html" target="_blank" rel="noopener">https://www.freebuf.com/sectool/102661.html</a>)</li><li><a href="https://www.freebuf.com/articles/web/123779.html" target="_blank" rel="noopener">进行攻击练习</a></li><li>修复漏洞，再次测试攻击，查看结果是否有效</li></ol><h4 id="安全性评估"><a href="#安全性评估" class="headerlink" title="安全性评估"></a>安全性评估</h4><p>当做完安全性测试后，软件是否能够达到预期的安全程度呢?这是安全性测试人员最关心的问题，因此需要建立对测试后的安全性评估机制。一般从以下两个方面进行评估。</p><ol><li>安全性缺陷数据评估。如果发现软件的安全性缺陷和漏洞越多，可能遗留的缺陷也越多。进行这类评估时，必须建立基线数据作为参照，否则评估起来没有依据就无法得到正确的结论。</li><li>采用漏洞植入法来进行评估。漏洞植入法和可靠性测试里的故障插入测试是同一道理，只不过这里是在软件里插入一些有安全隐患的问题。采用漏洞植入法时，先让不参加安全测试的特定人员在软件中预先植入一定数量的漏洞，最后测试完后看有多少植入的漏洞被发现，以此来评估软件的安全性测试做得是否充分。</li></ol><h3 id="安全建议"><a href="#安全建议" class="headerlink" title="安全建议"></a>安全建议</h3><h4 id="层面"><a href="#层面" class="headerlink" title="层面"></a>层面</h4><ul><li>管理层<ul><li>技术：建立高效统一的安全管理和权限划分，如集中授权、认证、用户和日志管理等</li><li>非技术：流程化、制度化去加强安全意识和规范</li></ul></li><li>应用层<ul><li>业务安全：防止恶意攻击</li><li>应用设计安全：认证、口令策略、访问控制和授权、加密、会话管理、日志、数据包含和运行安全等</li><li>应用编码安全：输入校验、输出编码、文件上传下载、异常处理、安全API等</li></ul></li><li>系统层：操作系统、数据库系统、中间间系统等<ul><li>安全加固：最小化安装、最小化服务、最强口令策略、内核参数优化等</li><li>恶意软件防护：防病毒、主机防火墙等</li></ul></li><li>网络层：网络设备保护、网络拓朴安全设计、网络边界保护（如防火墙）、网络数据加密（如VPN）、网络安全检测（如IDS\IPS）等</li></ul><h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><ol><li>最小授权：只授予每个用户/程序在执行操作时所必须的最小特权。这样可以限制事故、错误、攻击带来的危害，减小特权程序之间潜在的相互影响。</li><li>发生故障优先保证安全：当系统发生故障时，对任何请求默认应加以拒绝。</li><li>深入防御原则：采用多层安全机制，这个概念范围比较大。比如在表单中的字段校验不光要在页面校验，还要在后台有相应的校验机制；比如在信任区、飞信任区之间二次部署防火墙。</li><li>权限分离：比如禁止root用户远程登录、多重身份校验登陆等；</li><li>系统架构设计和代码尽可能简洁，越复杂的系统，bug越多</li><li>共享事务的数量和使用尽可能少，毕竟单独控制一个操作比并行控制两个过程更容易一些；</li><li>安全保护机制不能依赖于攻击者对系统实现过程的无知、而只依赖于像口令/密钥这样较容易改变的东西。</li><li>不信任原则：要严格限制用户、外部部件的信任度，要假设他们都是不安全的。</li><li>对受保护的对象的每一个访问都要经过检查。</li><li>心理接受程度：不能通过限制、甚至组织用户访问系统资源来阻止攻击，但可以考虑引入少量可接受的使用障碍。</li><li>不要等开发人员编码完成才开始进行安全测试，可以负责任的将，65%以上的安全漏洞都是发生在架构设计阶段，因此要积极参与到架构设计评审活动中，将一些低中级别的隐患扼杀在摇篮中。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;软件因为漏洞，导致产品的数据泄露、功能受到影响和系统被入侵等危害。安全测试就是为了发现这些问题，并给予一定的安全评估。&lt;br&gt;本文章主要介绍如何进行软件的安全性测试。&lt;/p&gt;
    
    </summary>
    
    
      <category term="安全" scheme="https://lightalight.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>App测试(四) Android Studio 连接手机进行调试</title>
    <link href="https://lightalight.github.io/2021/09/15/App%E6%B5%8B%E8%AF%9504/"/>
    <id>https://lightalight.github.io/2021/09/15/App测试04/</id>
    <published>2021-09-15T11:23:32.000Z</published>
    <updated>2022-07-19T16:58:20.206Z</updated>
    
    <content type="html"><![CDATA[<p>Android Studio 是谷歌推出的一个Android集成开发工具，基于IntelliJ IDEA. 类似 Eclipse ADT，Android Studio 提供了集成的 Android 开发工具用于开发和调试。<br>文章介绍Android Studio的基本使用。<br><a id="more"></a></p><h2 id="Quick-Guide"><a href="#Quick-Guide" class="headerlink" title="Quick Guide"></a>Quick Guide</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="创建第一个项目"><a href="#创建第一个项目" class="headerlink" title="创建第一个项目"></a>创建第一个项目</h4><ul><li>进入AndroidStudio官网</li><li>点击Download进行下载</li></ul><p><img src="/image/App测试04/App测试04_001.png" alt=""></p><ul><li>创建第一个项目<br>如果用kotlin 开发就选择【Empty Compose Activity】</li></ul><p><img src="/image/App测试04/App测试04_002.png" alt=""></p><p><img src="/image/App测试04/App测试04_003.png" alt=""></p><ul><li>【tools】-&gt;【SDK Manager】-&gt;【SDK Tools】 下载Android Emulator 和Android SDK Platform-Tools</li></ul><p><img src="/image/App测试04/App测试04_004.png" alt=""></p><ul><li>可以先试试AS自带的模拟器</li></ul><p><img src="/image/App测试04/App测试04_005.png" alt=""></p><ul><li>点击create device</li></ul><p><img src="/image/App测试04/App测试04_006.png" alt=""></p><ul><li>选择一种型号的设备下载</li></ul><p><img src="/image/App测试04/App测试04_007.png" alt=""></p><ul><li>然后运行项目就可以看到效果啦</li></ul><p><img src="/image/App测试04/App测试04_008.png" alt=""></p><h4 id="连接手机进行调试"><a href="#连接手机进行调试" class="headerlink" title="连接手机进行调试"></a>连接手机进行调试</h4><h5 id="ADB环境配置"><a href="#ADB环境配置" class="headerlink" title="ADB环境配置"></a>ADB环境配置</h5><ul><li>查看自己Android Studio配置的sdk路径【tools】-&gt;【SDK Manager】比如我的路径是C:\Users\Admin\AppData\Local\Android\Sdk</li></ul><p><img src="/image/App测试04/App测试04_009.png" alt=""></p><ul><li>配置环境变量：右键【我的电脑】-&gt;【高级系统设置】-&gt;【环境变量】，新建变量【Android_Home】</li></ul><p><img src="/image/App测试04/App测试04_010.png" alt=""></p><ul><li>然后在Path变量中，新增加一项%Android_Home%(即为相对路径)：</li></ul><p><img src="/image/App测试04/App测试04_011.png" alt=""></p><ul><li>打开cmd窗口，输入adb, 出现如下图就说明安装好啦</li></ul><p><img src="/image/App测试04/App测试04_012.png" alt=""></p><h5 id="配置USB-Driver"><a href="#配置USB-Driver" class="headerlink" title="配置USB Driver"></a>配置USB Driver</h5><ul><li>下载Google USB Driver【tools】-&gt;【SDK Manager】-&gt;【SDK Tools】</li></ul><p><img src="/image/App测试04/App测试04_013.png" alt=""></p><ul><li>将手机用USB线连接到电脑，打开设备管理器，找到你的手机</li></ul><p><img src="/image/App测试04/App测试04_014.png" alt=""></p><ul><li>右键点击你的手机名称，选择【更新驱动设备】</li></ul><p><img src="/image/App测试04/App测试04_015.png" alt=""></p><ul><li>然后再选择【浏览我的电脑以查找驱动程序】</li></ul><p><img src="/image/App测试04/App测试04_016.png" alt=""></p><ul><li>找到usb_driver的安装路径(默认情况在SDK文件路径下的extras\google\usb_driver),最后点击下一页完成更新就好啦</li></ul><p><img src="/image/App测试04/App测试04_017.png" alt=""></p><ul><li><p>打开手机的开发者模式（不同手机不一样，自行百度，这里附上华为nova系列）</p><ul><li>安卓系统的参考这篇文章：<a href="https://www.iefans.net/info/v944581.html" target="_blank" rel="noopener">https://www.iefans.net/info/v944581.html</a></li><li>鸿蒙系统:【设置】-&gt; 【系统和更新】-&gt;【开发人员选项】-&gt;【USB调试】,选择允许USB调试</li></ul><p><img src="/image/App测试04/App测试04_018.png" alt=""></p></li></ul><ul><li>连接手机调试（USB线）,显示手机设备</li></ul><p><img src="/image/App测试04/App测试04_019.png" alt=""></p><ul><li>然后选择手机，点击运行，就可以在手机上调试</li></ul><p><img src="/image/App测试04/App测试04_020.png" alt=""></p><p><img src="/image/App测试04/App测试04_021.png" alt=""></p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><h4 id="查看性能"><a href="#查看性能" class="headerlink" title="查看性能"></a>查看性能</h4><p>需要app开启debug模式</p><ul><li>根据以下操作步骤选择对应链接的手机，并且手机上启动APP</li></ul><p><img src="/image/App测试04/App测试04_022.png" alt=""></p><ul><li>此时进行app操作即可查看以下信息</li></ul><p><img src="/image/App测试04/App测试04_023.png" alt=""></p><ul><li>在页面内点击任意一个位置 进入到具体信息页面</li></ul><p><img src="/image/App测试04/App测试04_024.png" alt=""></p><h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><p>需要app开启debug模式</p><p><img src="/image/App测试04/App测试04_025.png" alt=""></p><p><img src="/image/App测试04/App测试04_026.png" alt=""></p><h4 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h4><p><img src="/image/App测试04/App测试04_027.png" alt=""></p><h4 id="设置无线连接"><a href="#设置无线连接" class="headerlink" title="设置无线连接"></a>设置无线连接</h4><ol><li>手机和电脑连入同一个无线网络</li><li>手机连接电脑，在命令行输入adb tcpip 5555</li><li>断开连接线，命令行输入adb connect 10.3.6.59(手机的IP地址)</li><li>提示连接成功后，可以进行无线调试了</li></ol><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="Failed-to-find-Build-Tools-revision-30-0-3"><a href="#Failed-to-find-Build-Tools-revision-30-0-3" class="headerlink" title="Failed to find Build Tools revision 30.0.3"></a>Failed to find Build Tools revision 30.0.3</h4><p>取消然后再选中Show package detail，然后下载30.0.3<br><img src="/image/App测试04/App测试04_028.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android Studio 是谷歌推出的一个Android集成开发工具，基于IntelliJ IDEA. 类似 Eclipse ADT，Android Studio 提供了集成的 Android 开发工具用于开发和调试。&lt;br&gt;文章介绍Android Studio的基本使用。&lt;br&gt;
    
    </summary>
    
    
      <category term="app" scheme="https://lightalight.github.io/tags/app/"/>
    
      <category term="AndroidStudio" scheme="https://lightalight.github.io/tags/AndroidStudio/"/>
    
  </entry>
  
  <entry>
    <title>App测试(三) Monkey的基本使用</title>
    <link href="https://lightalight.github.io/2021/08/15/App%E6%B5%8B%E8%AF%9503/"/>
    <id>https://lightalight.github.io/2021/08/15/App测试03/</id>
    <published>2021-08-15T11:23:32.000Z</published>
    <updated>2022-07-19T17:04:13.054Z</updated>
    
    <content type="html"><![CDATA[<p>Monkey 测试是通过向系统发送伪随机的用户事件流（如按键输入、触摸屏输入、手势输入等），实现对应用程序客户端的稳定性测试；<br>通俗来说，Monkey 测试即“猴子测试”，是指像猴子一样，不知道程序的任何用户交互方面的知识，就对界面进行无目的、乱点乱按的操作；<br>Monkey 测试是一种为了测试软件的稳定性、健壮性的快速有效的方法；<br>Monkey 程序是 Android 系统自带的，由 Java 语言写成，在 Android 文件系统中的存放路径是： /system/framework/monkey.jar；<br>Monkey 程序需要通过 adb 来运行。<br>文章介绍Monkey的基本使用。<br><a id="more"></a></p><h2 id="Quick-Guide"><a href="#Quick-Guide" class="headerlink" title="Quick Guide"></a>Quick Guide</h2><h3 id="一、monkey启动步骤"><a href="#一、monkey启动步骤" class="headerlink" title="一、monkey启动步骤"></a>一、monkey启动步骤</h3><ol><li>连接设备</li><li>adb shell</li><li>cd /system/bin</li><li>输入monkey</li></ol><h3 id="二、关闭monkey"><a href="#二、关闭monkey" class="headerlink" title="二、关闭monkey"></a>二、关闭monkey</h3><ol><li>adb shell ps 查看进程</li><li>查出 com.android.commands.monkey 进程ID</li><li>adb shell kill pid 杀死monkey进程</li></ol><h3 id="三、monkey-命令"><a href="#三、monkey-命令" class="headerlink" title="三、monkey 命令"></a>三、monkey 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey [options]  &lt;event-count&gt;</span><br></pre></td></tr></table></figure><ul><li>-options 指monkey传入的参数，不指定则为无反馈启动，把事件任意发送到目标环境的全部包中</li><li>-\<event-count> 指随机发送时间数。如输入100就执行100个随机事件。</event-count></li></ul><h3 id="四、操作事件"><a href="#四、操作事件" class="headerlink" title="四、操作事件"></a>四、操作事件</h3><h4 id="1-触摸事件"><a href="#1-触摸事件" class="headerlink" title="1.触摸事件"></a>1.触摸事件</h4><p>按下抬起的操作，可通过–pct–touch 配置事件百分比（是由一组ACTION_DOWN和ACTION_UP）组成</p><h4 id="2-手势事件"><a href="#2-手势事件" class="headerlink" title="2.手势事件"></a>2.手势事件</h4><p>指按下、移动、抬起、直线滑动的操作。通过–pct–motion配置百分比（由ACTION_DOWN和ACTION_MOVE和ACTION_UP组成）</p><h4 id="3-二指缩放事件"><a href="#3-二指缩放事件" class="headerlink" title="3.二指缩放事件"></a>3.二指缩放事件</h4><p>通过–pct–pinchzoom配置，</p><h4 id="4-轨迹事件"><a href="#4-轨迹事件" class="headerlink" title="4.轨迹事件"></a>4.轨迹事件</h4><p>由一个或多个随机移动组成，通过–pct-tracball</p><h4 id="5-旋转屏幕"><a href="#5-旋转屏幕" class="headerlink" title="5.旋转屏幕"></a>5.旋转屏幕</h4><p>通过–pct-rotation配置百分比</p><h4 id="6-基本导航事件"><a href="#6-基本导航事件" class="headerlink" title="6.基本导航事件"></a>6.基本导航事件</h4><p>现在基本没有</p><h4 id="7-主要导航事件"><a href="#7-主要导航事件" class="headerlink" title="7.主要导航事件"></a>7.主要导航事件</h4><p>主要是中间键、back、菜单按键。通过–pct-majornav配置</p><h4 id="8-系统按键事件"><a href="#8-系统按键事件" class="headerlink" title="8.系统按键事件"></a>8.系统按键事件</h4><p>如home、back、音量调节等，通过–pct-syskeys配置</p><h4 id="9-启动activity事件"><a href="#9-启动activity事件" class="headerlink" title="9.启动activity事件"></a>9.启动activity事件</h4><p>手机开启一个activity。随机执行一个startactivity（）方法</p><h4 id="10-键盘事件"><a href="#10-键盘事件" class="headerlink" title="10.键盘事件"></a>10.键盘事件</h4><p>通过–pct-flip配置</p><h3 id="五、monkey-参数"><a href="#五、monkey-参数" class="headerlink" title="五、monkey 参数"></a>五、monkey 参数</h3><h4 id="1-常规参数"><a href="#1-常规参数" class="headerlink" title="1.常规参数"></a>1.常规参数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 帮助类参数</span></span><br><span class="line">monkey -h </span><br><span class="line">adb shell monkey -v &lt;event-count&gt;</span><br></pre></td></tr></table></figure><p>-v打印出日志。每个-v增加反馈信息级别，-v越多越详细，最多三个</p><h4 id="2-事件类参数"><a href="#2-事件类参数" class="headerlink" title="2.事件类参数"></a>2.事件类参数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey -f /mnt/sdcard/test1  执行脚本文件</span><br><span class="line"></span><br><span class="line">adb shell monkey -s 666 100  ;   -s可以重复执行之前的随机操作。每次随机事件默认生成一个seed</span><br><span class="line"></span><br><span class="line">adb shell monkey --throttle 3000 5;   --throttle 每个指令之间增加间隔时间</span><br><span class="line"></span><br><span class="line">adb shell monkey -v -v --pct-touch 100 200;   调整触摸事件百分比等</span><br></pre></td></tr></table></figure><h3 id="六、约束类参数"><a href="#六、约束类参数" class="headerlink" title="六、约束类参数"></a>六、约束类参数</h3><h4 id="1-包约束-只访问包里的activity"><a href="#1-包约束-只访问包里的activity" class="headerlink" title="1.包约束 (只访问包里的activity)"></a>1.包约束 (只访问包里的activity)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey -p com.tal.kaoyan 500</span><br></pre></td></tr></table></figure><h4 id="2-activity约束"><a href="#2-activity约束" class="headerlink" title="2.activity约束"></a>2.activity约束</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey -c Intent.CATEGORY_LAUNCHER 1000</span><br></pre></td></tr></table></figure><h3 id="七、调试类参数"><a href="#七、调试类参数" class="headerlink" title="七、调试类参数"></a>七、调试类参数</h3><h4 id="1-程序崩溃侯继续发送事件"><a href="#1-程序崩溃侯继续发送事件" class="headerlink" title="1.程序崩溃侯继续发送事件"></a>1.程序崩溃侯继续发送事件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey --ignore-crashes &lt;event-count&gt;</span><br></pre></td></tr></table></figure><h4 id="2-超时错误继续发送事件"><a href="#2-超时错误继续发送事件" class="headerlink" title="2.超时错误继续发送事件"></a>2.超时错误继续发送事件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey --ignore-timeouts</span><br></pre></td></tr></table></figure><h4 id="3-应用程序权限错误发生后继续发送事件"><a href="#3-应用程序权限错误发生后继续发送事件" class="headerlink" title="3.应用程序权限错误发生后继续发送事件"></a>3.应用程序权限错误发生后继续发送事件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey --ignore-security-exceptions</span><br></pre></td></tr></table></figure><h3 id="八、案例"><a href="#八、案例" class="headerlink" title="八、案例"></a>八、案例</h3><ol><li>测试是指定应用，因此需要使用-p指定被测app包名：com.tal.kaoyan</li><li>这个测试的目的是希望模拟用户操作，因此需要让Monkey执行的事件尽可能地接近用户的常规操作，这样才可以最大限度地发现用户使用过程中可能出现的问题。因此需要对Monkey执行的事件百分比做一些调整:</li><li>触摸事件和手势事件是用户最常见的操作，所以通过–pct-touch和–pct-motion将这两个事件的占比调整到40%与25%；目标应用包含了多个Activity，为了能覆盖大部分的Activity，所以通过–pct-appswitch将Activity切换的事件占比调整到10%；被测应用在测试中出现过不少横竖屏之间切换的问题，这个场景也必须关注，因此通过–pct-rotation把横竖屏切换事件调整到10%。</li><li>使用-s参数来指定命令执行的seed值 Monkey会根据seed值来生成对应事件流，同一个seed生成的事件流是完全相同的。这里指定了seed值，是为了测试发现问题时，便于进行问题复现。</li><li>使用–throttle参数来控制Monkey每个操作之间的时间间隔 指定操作之间的时间间隔，一方面是希望能更接近用户的操作场景，正常用户操作都会有一定的时间间隔；另一方面也是不希望因为过于频繁的操作而导致系统崩溃，尤其是在比较低端的手机上执行测试时。因此通过–throttle设置Monkey每个操作固定延迟0.4秒。</li><li>使用–ignore-crashs和–ignore-timeouts参数使Monkey遇到意外时能继续执行 在执行Monkey测试时，会因为应用的崩溃或没有响应而意外终止，所以需要在命令中增加限制参数–ignore-crash和–ignore-timeouts，让Monkey在遇到崩溃或没有响应的时候，能在日志中记录相关信息，并继续执行后续的测试。</li><li>使用-v指定log的详细级别 Monkey的日志输出有3个级别：日志的级别越高，其详细程度也越高。为了方便问题的定位，这里将日志设为 -v -v.</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey -p com.tal.kaoyan</span><br></pre></td></tr></table></figure><ul><li>–pct-touch 40 –pct-motion 25</li><li>–pct-appswitch 10</li><li>–pct-rotation 5</li><li>-s 1666 –throttle 400</li><li>–ignore-crashes</li><li>–ignore-timeouts</li><li>-v -v  200</li></ul><h3 id="九、monkey脚本稳定性测试"><a href="#九、monkey脚本稳定性测试" class="headerlink" title="九、monkey脚本稳定性测试"></a>九、monkey脚本稳定性测试</h3><p>按照规范写好脚本，放在手机里，通过monkey -f调用脚本</p><h4 id="1-脚本api"><a href="#1-脚本api" class="headerlink" title="1.脚本api"></a>1.脚本api</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">LaunchActivity(pkg_name, cl_name)：启动应用的Activity。参数：包名和启动的Activity。</span><br><span class="line">Tap(x, y, tapDuration)： 模拟一次手指单击事件。参数：x,y为控件坐标，tapDuration为点击的持续时间，此参数可省略。</span><br><span class="line">UserWait(sleepTime)： 休眠一段时间</span><br><span class="line">DispatchPress(keyName)： 按键。参数： keycode。 RotateScreen(rotationDegree, persist)： 旋转屏幕。 参数：rotationDegree为旋转角度， e.g. 1代表90度；persist表示旋转之后是否固定，0表示旋转后恢复，非0则表示固定不变。</span><br><span class="line">DispatchString(input)： 输入字符串。</span><br><span class="line">DispatchFlip(true/false)： 打开或者关闭软键盘。</span><br><span class="line">PressAndHold(x, y, pressDuration)： 模拟长按事件。</span><br><span class="line">Drag(xStart, yStart, xEnd, yEnd, stepCount)： 用于模拟一个拖拽操作。</span><br><span class="line">PinchZoom(x1Start, y1Start, x1End, y1End, x2Start, y2Start, x2End, y2End, stepCount)： 模拟缩放手势。</span><br><span class="line">LongPress()： 长按2秒。</span><br><span class="line">DeviceWakeUp()： 唤醒屏幕。</span><br><span class="line">PowerLog(power_log_type, test_case_status)： 模拟电池电量信息。</span><br><span class="line">WriteLog()： 将电池信息写入sd卡。</span><br><span class="line">RunCmd(cmd)： 运行shell命令。</span><br><span class="line">DispatchPointer(downtime,eventTime,action,x,yxpressure,size,metastate,xPrecision,yPrecision,device,edgeFlags)： 向指定位置，发送单个手势。</span><br><span class="line">DispatchPointer(downtime,eventTime,action,x,yxpressure,size,metastate,xPrecision,yPrecision,device,edgeFilags)： 发送按键消息。</span><br><span class="line">LaunchInstrumentation(test_name,runner_name)： 运行一个instrumentation测试用例。</span><br><span class="line">DispatchTrackball： 模拟发送轨迹球事件。</span><br><span class="line">ProfileWait： 等待5秒。</span><br><span class="line">StartCaptureFramerate()： 获取帧率。</span><br><span class="line">EndCaptureFramerate(input)： 结束获取帧率。</span><br></pre></td></tr></table></figure><h4 id="2-脚本格式"><a href="#2-脚本格式" class="headerlink" title="2.脚本格式"></a>2.脚本格式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Monkey脚本主要包含两部分，一部分是头文件信息，一部分是具体的monkey命令。</span></span><br><span class="line"><span class="built_in">type</span> = raw events</span><br><span class="line">count = 1</span><br><span class="line">speed = 1.0</span><br><span class="line"><span class="comment"># 下面为monkey命令</span></span><br><span class="line">start data &gt;&gt;</span><br><span class="line"><span class="comment"># 具体的monkey脚本内容</span></span><br></pre></td></tr></table></figure><h4 id="3-编写脚本"><a href="#3-编写脚本" class="headerlink" title="3.编写脚本"></a>3.编写脚本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#头文件信息</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> = raw events</span><br><span class="line"></span><br><span class="line">count = 1</span><br><span class="line"></span><br><span class="line">speed = 1.0</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动测试</span></span><br><span class="line">start data &gt;&gt;</span><br><span class="line"></span><br><span class="line">LaunchActivity(com.tal.kaoyan,com.tal.kaoyan.ui.activity.SplashActivity)</span><br><span class="line">UserWait(2000)</span><br><span class="line"></span><br><span class="line">Tap(624,900,1000) <span class="comment">#点击取消升级</span></span><br><span class="line">UserWait(2000)</span><br><span class="line"></span><br><span class="line">Tap(806,64,1000) <span class="comment">#点击跳过</span></span><br><span class="line">UserWait(2000)</span><br><span class="line"></span><br><span class="line">Tap(217,378,1000) <span class="comment">#点击用户名输入框</span></span><br><span class="line">DispatchString(zxw1234)</span><br><span class="line">UserWait(2000)</span><br><span class="line"></span><br><span class="line">Tap(197,461,1000) <span class="comment">#点击密码输入框</span></span><br><span class="line">DispatchString(zxw123456)</span><br><span class="line">UserWait(2000)</span><br><span class="line"></span><br><span class="line">Tap(343,637,1000) <span class="comment">#点击登录按钮</span></span><br></pre></td></tr></table></figure><h4 id="4-执行脚本"><a href="#4-执行脚本" class="headerlink" title="4.执行脚本"></a>4.执行脚本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb push C:\Users\Shuqing\Desktop\kyb1.txt /sdcard</span><br><span class="line"></span><br><span class="line">adb shell monkey -f /sdcard/kyb1.txt -v 1</span><br></pre></td></tr></table></figure><h4 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5.注意事项"></a>5.注意事项</h4><p>头文件代码书写注意“=”两边预留空格，否则会出现如下报错。</p><h3 id="十、日志管理"><a href="#十、日志管理" class="headerlink" title="十、日志管理"></a>十、日志管理</h3><h4 id="1-日志保存方式"><a href="#1-日志保存方式" class="headerlink" title="1.日志保存方式"></a>1.日志保存方式</h4><ul><li>保存pc中</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey -v -v 100 &gt;d:\monkeylog.txt</span><br></pre></td></tr></table></figure><ul><li>保存在手机上</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">monkey -v 100 &gt;/sdcard/monkeylog.log</span><br></pre></td></tr></table></figure><ul><li>正常日志和error日志分开保存</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey -v 100 1&gt;d:\monkey.log  2&gt;d:\error.log</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Monkey 测试是通过向系统发送伪随机的用户事件流（如按键输入、触摸屏输入、手势输入等），实现对应用程序客户端的稳定性测试；&lt;br&gt;通俗来说，Monkey 测试即“猴子测试”，是指像猴子一样，不知道程序的任何用户交互方面的知识，就对界面进行无目的、乱点乱按的操作；&lt;br&gt;Monkey 测试是一种为了测试软件的稳定性、健壮性的快速有效的方法；&lt;br&gt;Monkey 程序是 Android 系统自带的，由 Java 语言写成，在 Android 文件系统中的存放路径是： /system/framework/monkey.jar；&lt;br&gt;Monkey 程序需要通过 adb 来运行。&lt;br&gt;文章介绍Monkey的基本使用。&lt;br&gt;
    
    </summary>
    
    
      <category term="app" scheme="https://lightalight.github.io/tags/app/"/>
    
      <category term="monkey" scheme="https://lightalight.github.io/tags/monkey/"/>
    
  </entry>
  
  <entry>
    <title>App测试(二) adb工具的基本使用</title>
    <link href="https://lightalight.github.io/2021/07/15/App%E6%B5%8B%E8%AF%9502/"/>
    <id>https://lightalight.github.io/2021/07/15/App测试02/</id>
    <published>2021-07-15T11:23:32.000Z</published>
    <updated>2022-07-19T17:06:46.922Z</updated>
    
    <content type="html"><![CDATA[<p>adb全称Android Debug Bridge，是Android SDK中的一个工具, 使用adb可以直接操作管理Android模拟器或者真实的Andriod设备，就是起到调试桥的作用。文章介绍adb的基本使用。<br><a id="more"></a></p><h2 id="Quick-Guide"><a href="#Quick-Guide" class="headerlink" title="Quick Guide"></a>Quick Guide</h2><h3 id="adb的安装"><a href="#adb的安装" class="headerlink" title="adb的安装"></a>adb的安装</h3><p>adb工具包一般只是一个压缩文件，不需要安装，只需要解压即可。解压后有三个必须文件，adb.exe动态链接库文件、adbWinApi.dll和adbWinUsbApi.dll，解压后即可直接使用。<br>如图：</p><p><img src="/image/App测试02/App测试02_001.png" alt=""></p><h3 id="adb的基本使用"><a href="#adb的基本使用" class="headerlink" title="adb的基本使用"></a>adb的基本使用</h3><p>进入到adb目录，cmd打开命令窗口</p><ul><li>连接上设备</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb connect ip</span><br></pre></td></tr></table></figure><p>注意：第一次链接失败，再连一次就成功了！</p><ul><li>查看当前连接的所有设备</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure><ul><li>推送文件到设备</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push 电脑文件的路径 /sdcard</span><br></pre></td></tr></table></figure><ul><li>在设备上的文件管理器找到相关.apk文件</li><li>断开连接</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb disconnect</span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li>获取设备列表和设备状态</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure><ul><li>安装/卸载app</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">adb install 包信息</span><br><span class="line"></span><br><span class="line">adb install -r 包信息    //覆盖安装</span><br><span class="line"></span><br><span class="line">adb install -d 包信息    //安装的版本比手机上的版本低</span><br><span class="line"></span><br><span class="line">adb uninstall pkname    //卸载</span><br></pre></td></tr></table></figure><ul><li>将PC机上的文件push到手机上</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push 文件 /sdcard/</span><br></pre></td></tr></table></figure><ul><li>将手机上的文件pull到PC机上</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull /sdcard/50.zip（文件） D:\back（路径）</span><br></pre></td></tr></table></figure><ul><li>查看adb后台进程</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell ps | findstr adbd</span><br></pre></td></tr></table></figure><ul><li>获取当前界面的包名信息</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys window | findstr mCurrentFocus</span><br></pre></td></tr></table></figure><ul><li>app禁用命令、启用命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm <span class="built_in">disable</span>-user 包名    <span class="comment"># 禁用命令</span></span><br><span class="line"></span><br><span class="line">adb shell pm <span class="built_in">enable</span> 包名    <span class="comment"># 启用命令</span></span><br></pre></td></tr></table></figure><ul><li>内存快速填充命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 快速填充1G内存</span></span><br><span class="line">adb shell dd <span class="keyword">if</span>=/dev/zero of=/sdcard/file bs=1024000 count=1024</span><br></pre></td></tr></table></figure><ul><li>获取手机品牌</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell getprop ro.product.brand</span><br></pre></td></tr></table></figure><ul><li>截屏</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell screencap -p /sdcard/screenshot.png</span><br></pre></td></tr></table></figure><ul><li>重启手机</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb reboot</span><br></pre></td></tr></table></figure><ul><li>一般问题log的抓抓取adb LOG</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># //一般问题log的抓取</span></span><br><span class="line">adb shell -v time &gt; D:\log.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示问题log的抓取</span></span><br><span class="line">adb shell dumpsys SurfaceFlinger &gt; D:\SF.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># adb 查看所有进程信息</span></span><br><span class="line">adb shell ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># adb 查看指定关键字的进程信息 *** 为关键字 可以为包名</span></span><br><span class="line">adb shell “ps | grep ***”</span><br><span class="line"></span><br><span class="line"><span class="comment"># adb 查看所有进程的 log信息</span></span><br><span class="line">adb logcat -v process</span><br><span class="line"></span><br><span class="line"><span class="comment"># adb 查看指定PID的log信息</span></span><br><span class="line">adb logcat -v process | grep ****</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有的log日志</span></span><br><span class="line">adb logcat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 过滤查看指定关键字的log ***为关键字</span></span><br><span class="line">adb logcat | grep ***</span><br></pre></td></tr></table></figure><h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><h4 id="安装正常"><a href="#安装正常" class="headerlink" title="安装正常"></a>安装正常</h4><ol><li>安装chrome 插件 Android Debug Bridge</li><li>手机开启调试模式，且手机的包需要时 开发包（dev），然后usb连接手机</li><li>浏览器输入 chrome://inspect ，手机进入对应h5页面，然后在浏览器就可以看到并inspect</li></ol><p><img src="/image/App测试02/App测试02_002.png" alt=""></p><h4 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h4><ul><li><a href="https://blog.csdn.net/weixin_40398599/article/details/102818136?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;dist_request_id=1328740.50354.16170887036072893&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control" target="_blank" rel="noopener">Chrome DevTools 调试技巧</a></li><li><a href="https://blog.csdn.net/weixin_33863087/article/details/89132834?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;dist_request_id=1328740.50354.16170887036072893&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control" target="_blank" rel="noopener">最新 Chrome DevTools(v57) 使用详解</a></li></ul><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li>1.不能访问404<ul><li>网络问题：看能不能访问 <a href="https://chrome-devtools-frontend.appspot.com/" target="_blank" rel="noopener">https://chrome-devtools-frontend.appspot.com/</a></li><li>浏览器版本：被调试端版本过低（调试端 的浏览器版本 是否低于 被调试）；</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;adb全称Android Debug Bridge，是Android SDK中的一个工具, 使用adb可以直接操作管理Android模拟器或者真实的Andriod设备，就是起到调试桥的作用。文章介绍adb的基本使用。&lt;br&gt;
    
    </summary>
    
    
      <category term="app" scheme="https://lightalight.github.io/tags/app/"/>
    
      <category term="adb" scheme="https://lightalight.github.io/tags/adb/"/>
    
  </entry>
  
  <entry>
    <title>App测试(一) App测试的基本概念</title>
    <link href="https://lightalight.github.io/2021/06/15/App%E6%B5%8B%E8%AF%9501/"/>
    <id>https://lightalight.github.io/2021/06/15/App测试01/</id>
    <published>2021-06-15T11:23:32.000Z</published>
    <updated>2022-07-19T16:58:22.805Z</updated>
    
    <content type="html"><![CDATA[<p>文章介绍App测试的基本概念。<br><a id="more"></a></p><h2 id="Quick-Guide"><a href="#Quick-Guide" class="headerlink" title="Quick Guide"></a>Quick Guide</h2><h3 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h3><ul><li>功能测试<ul><li>冒烟测试（不符合打回）</li><li>特性测试<ul><li>ui</li><li>功能</li></ul></li><li>兼容性测试</li></ul></li><li>合版测试<ul><li>特性功能</li><li>全量功能</li></ul></li><li>渠道包测试</li><li>上线测试</li><li>版本问题跟踪</li></ul><h3 id="测试周期"><a href="#测试周期" class="headerlink" title="测试周期"></a>测试周期</h3><p>测试周期可按项目的开发周期来确定测试时间，一般测试时间为1~2周（即15个工作日），根据项目情况以及版本质量可适当缩短或延长测试时间。</p><h3 id="测试资源"><a href="#测试资源" class="headerlink" title="测试资源"></a>测试资源</h3><p>测试任务开始前，检查各项测试资源。</p><ul><li>产品功能需求文档；</li><li>产品原型图；</li><li>产品效果图；</li><li>行为统计分析定义文档；</li><li>测试设备（ios3.1.3-ios5.0.1；Android1.6-Android4.0；Winphone7.1及以上；Symbian v3/v5/Nokia Belle等）；</li><li>其他</li></ul><h3 id="日报及产品上线报告"><a href="#日报及产品上线报告" class="headerlink" title="日报及产品上线报告"></a>日报及产品上线报告</h3><ul><li>测试人员每天需对所测项目发送测试日报。</li><li>测试日报所包含的内容为：<ul><li>对当前测试版本质量进行分级；</li><li>对较严重的问题进行例举，提示开发人员优先修改；</li><li>对版本的整体情况进行评估。</li></ul></li><li>产品上线前，测试人员发送产品上线报告。</li><li>上线报告所包含的内容为：<ul><li>对当前版本质量进行分级和历史问题记录对比；</li><li>附上测试报告（功能测试报告、兼容性测试报告、性能测试报告以及app可用性能标准结果）；</li><li>总结上线版本的基本情况。若有遗留问题必须列出并记录解决方案。</li></ul></li></ul><h3 id="版本反馈收集"><a href="#版本反馈收集" class="headerlink" title="版本反馈收集"></a>版本反馈收集</h3><ul><li>应用市场</li><li>App内反馈系统</li><li>埋点技术</li></ul><h3 id="测试点"><a href="#测试点" class="headerlink" title="测试点"></a>测试点</h3><h4 id="非功能测试"><a href="#非功能测试" class="headerlink" title="非功能测试"></a>非功能测试</h4><p>针对 APP 应用的非功能性需求, 在 APP 应用开发初期, 可能需要对 APP 应用内容本身, 在线下展开针对性的实用性调研测试或者参考友商, </p><h4 id="特性测试"><a href="#特性测试" class="headerlink" title="特性测试"></a>特性测试</h4><h5 id="UI测试"><a href="#UI测试" class="headerlink" title="UI测试"></a>UI测试</h5><ul><li>确保原型图和效果图为当前最新版本，符合产品经理及用户需求；测试过程中一切以效果图为准，若有用户体验方面的建议，可以先与产品经理确认，确认通过后，可以正式向开发提出用户体验方面的问题。</li><li>在不同环境或者版本下测试出的数据差异需保留</li></ul><h5 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h5><ul><li>按照用户的需求(需求说明书、原型等]去检验开发的代码实现是否满足用户的功能性需求。</li><li>测试对象: 功能点(单独模块) —-》流程测试（多模块）</li><li>测试方法: 等价类与边界值组合</li></ul><h5 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h5><p>验证完特性后，把所有特性功能合成一个版本，对App的所有基本功能（核心功能）进行全面回归</p><h4 id="专项测试"><a href="#专项测试" class="headerlink" title="专项测试"></a>专项测试</h4><p><img src="/image/App测试01/App测试01_001.png" alt=""></p><h5 id="兼容性测试"><a href="#兼容性测试" class="headerlink" title="兼容性测试"></a>兼容性测试</h5><ul><li>硬件<ul><li>设备型号</li><li>屏幕尺寸</li><li>屏幕分辨率</li><li>网络类型</li></ul></li><li>软件<ul><li>系统版本</li><li>App版本</li><li>不同系统</li><li>与主流App是否兼容</li></ul></li></ul><h5 id="安装-卸载-升级测试"><a href="#安装-卸载-升级测试" class="headerlink" title="安装/卸载/升级测试*"></a>安装/卸载/升级测试*</h5><ul><li>安装类型<ul><li>Andriod ：.apk</li><li>ios：.lpa</li></ul></li><li>不同的安装渠道<ul><li>Andriod<ul><li>手机的应用商店</li><li>第三方软件：豌豆荚</li><li>-官网</li></ul></li><li>iOS:<ul><li>官网</li><li>APP Store</li></ul></li></ul></li><li>不同的系统版本</li><li>各种的安装方式<ul><li>正常情况<ul><li>正常安装测试,检查是否安装成功</li><li>APP版本覆盖测试</li><li>回退版本测试</li><li>在不同型号、系统、屏幕大小、分辨率上的手机进行安装·</li><li>安装完成后:能否正常启动应用程序</li><li>安装完成后,重启于机能否正常启动应用程序</li></ul></li><li>异常情况<ul><li>安装时内存不足</li><li>安装过程中的意外情况（强行断电、断网、来电话了、查看信息)等等</li><li>能否取消安装</li></ul></li></ul></li><li>各种卸载方式<ul><li>正常情况<ul><li>直接删除安装文件夹卸载是否有提示信息。</li><li>用自己的卸载程序进行卸载,检查是否卸载干净</li><li>用第三方工具,检查是否卸载干净</li><li>不同系统、硬件环境、网络环境下进行卸载</li><li>卸载后再次安装，是否正常使用</li></ul></li><li>异常情况<ul><li>卸载中出现异常情况能否恢复(比如手机关机，内存、没电等)，程序是否还能运行</li><li>卸载后是否有残留，是否能够再次进行安装</li><li>是否可以取消卸载软件恢复使用</li></ul></li></ul></li><li>各种升级方式<ul><li>更新版本需要提示用户</li><li>考虑是否进行强制升级<ul><li>否：可取消升级，但是有提示</li><li>是<ul><li>软件存在严重缺陷</li><li>软件不能够向前兼容</li></ul></li></ul></li><li>是否能够跨版本升级</li><li>断点续传</li></ul></li></ul><h5 id="交叉事件测试"><a href="#交叉事件测试" class="headerlink" title="交叉事件测试"></a>交叉事件测试</h5><p>APP 应用的交叉事件测试又称: 冲突测试或干扰测试。 一般多用于考察应用在运行过程中, 对于外界干扰的处理能力。</p><p>测试点:</p><ul><li>运行时接收来电/短信/消息推送/收取邮件</li><li>运行时出现系统弹窗, 运行时切换外部设备等。</li><li>插拔耳机</li><li>网络切换</li><li>系流自带应用(摄像头、计算器）</li><li>多个App同时运行是否影响正常功能</li><li>App运行时前/后台切换是否影响正常功能</li><li>App运行时切换网络（2G、3G、wifi）/浏览网络/使用蓝牙传送/接收数据</li></ul><h5 id="推送消息测试"><a href="#推送消息测试" class="headerlink" title="推送消息测试"></a>推送消息测试</h5><p>消息推送测试主要目的就是为了唤醒或提醒用户</p><ul><li>对象<ul><li>全部推送</li><li>部分推送</li><li>精确推送</li></ul></li><li>消息形式<ul><li>弹窗</li><li>消息通知栏</li><li>短信</li><li>邮件</li></ul></li><li>测试关注点<ul><li>push消息应该按设定规则发送特定用户</li><li>APP在后台运行时，应能正常收到push消息</li><li>设备在锁屏状态下，应能正常收到APP的Push消息</li><li>设备网络断开重连后，应能收到push消息</li><li>系统设置不接受APP通知消息时，用户应该不在收到push消息</li><li>在非免打扰时间段，用户能正常收到push。</li></ul></li></ul><h5 id="用户体验度测试"><a href="#用户体验度测试" class="headerlink" title="用户体验度测试"></a>用户体验度测试</h5><p>APP 应用用户体验度测试主要是从用户使用角度出发, 主观的感知产品或服务的可用, 易用及友好程度的测试形式. </p><p>测试点:</p><ul><li>界面设计：美观性</li><li>功能易用性：保持登录(APP) 页面层级关系在4层左右</li><li>横竖屏切换,</li><li>系统功能响应等.</li><li>是否有空数据界面设计，引导用户去执行操作。</li><li>是否滥用用户引导。</li><li>是否有不可点击的效果，如：你的按钮此时处于不可用状态，那么一定要灰掉，或者拿掉按钮，否则会给用户误导</li><li>菜单层次是否太深</li><li>交互流程分支是否太多</li><li>相关的选项是否离得很远</li><li>一次是否载入太多的数据</li><li>界面中按钮可点击范围是否适中</li><li>标签页是否跟内容没有从属关系，当切换标签的时候，内容跟着切换</li><li>操作应该有主次从属关系</li><li>是否定义Back的逻辑。涉及软硬件交互时，Back键应具体定义</li><li>是否有横屏模式的设计，应用一般需要支持横屏模式，即自适应设计</li></ul><h5 id="稳定性测试"><a href="#稳定性测试" class="headerlink" title="稳定性测试"></a>稳定性测试</h5><p>APP 应用稳定测试测试一般是通过测试工具实现在一定时间范围内的无序操作, 来检测应用的稳定运行能力,</p><p>测试点：</p><ul><li>闪退</li><li>系统崩溃</li><li>没响应</li></ul><p>常见的测试工具如下:</p><ul><li>Monkey</li><li>UICrawler</li><li>Maxim</li></ul><h5 id="客户端性能测试"><a href="#客户端性能测试" class="headerlink" title="客户端性能测试"></a>客户端性能测试</h5><p>一款 APP 应用是否优秀不仅仅体现在功能可用性上, 同时也需要关注 APP 应用在不同类型设备上的性能表现, 如果性能表现不够稳定, 则会在一定程度上影响某一部分用户的使用体验. </p><ul><li>极限测试：在各种边界压力情况下，如电池、存储、网速等，验证App是否能正确响应。<ul><li>内存满时安装App</li><li>运行App时手机断电</li><li>运行App时断掉网络</li><li>内存不足</li><li>电量不足</li></ul></li><li>响应能力测试：测试App中的各类操作是否满足用户响应时间要求 。（安装包放到云测上可以测试）<ul><li>App安装、卸载的响应时间</li><li>App各类功能性操作的影响时间</li></ul></li><li>压力测试：反复/长期操作下、系统资源是否占用异常。（itestin）<ul><li>App反复进行安装卸载，查看系统资源是否正常</li><li>其他功能反复进行操作，查看系统资源是否正常</li></ul></li><li>性能评估：评估典型用户应用场景下，系统资源的使用情况。（Jmeter）<ul><li>APP的启动时间是否过长;</li><li>AFP使用时对CPU、内存的占用情况;</li><li>APP使用时，电量流星的消耗情况;</li><li>反复长期的操作情况下,系统资源的使用情况。</li></ul></li><li><p>性能测试指标</p><ul><li>内存</li><li>CPU</li><li>流量</li><li>电量</li><li>启动速度</li><li>界面切换速度</li></ul></li><li><p>内存溢出和<em>内存泄漏</em></p><ul><li>内存溢出oul of mermory，是指程序在申清内存时，没有足够的内存空问供其使用，出现out of memory;</li><li><em>内存泄漏</em> memory leak，是指程序在申请内存后，无法释放已申请的内存空问，一次内存泄露危害可以忽略,但内存泄露堆积后果很严重,无论多少内存,迟早会被占光;memory leak会最终会导致out of memory</li></ul></li><li>冷启动与热启动<ul><li>app被后台杀死后，在这个状态打开app，这种启动方式叫做冷启动;</li><li>热启动;指app没有被后台杀死，仍然左后台运行，通常我们再次去打T开这个app，这种启动方式叫热启动。</li></ul></li></ul><h5 id="服务端性能测试"><a href="#服务端性能测试" class="headerlink" title="服务端性能测试"></a>服务端性能测试</h5><p>测试点:</p><ul><li>单机容量测试:可以检测到单机服务器在90%的响应时间和成功率都达标的前提下，能够承载多少用户量。</li><li>24小时稳定性测试:使用特定游戏模型压测24小时，服务无重启，内存无泄漏，并且各事务成功率达标。</li></ul><p>指标</p><ul><li>响应时间</li><li>吞吐量</li><li>并发数</li><li>事物通过率等</li></ul><p>测试工具: </p><ul><li>LoadRunner</li><li>JMeter</li></ul><h5 id="安全测试"><a href="#安全测试" class="headerlink" title="安全测试"></a>安全测试</h5><p>测试点: </p><ul><li>反编译性</li><li>数据安全</li><li>键盘安全</li><li>通信保密性及安全策略等方面的验证.</li></ul><h4 id="其他测试"><a href="#其他测试" class="headerlink" title="其他测试"></a>其他测试</h4><h5 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h5><ul><li>同表单编辑页面</li><li>用户名密码长度</li><li>注册后的提示页面</li><li>前台注册页面和后台的管理页面数据是否一致</li><li>注册后，在后台管理中页面提示</li></ul><h5 id="注销"><a href="#注销" class="headerlink" title="注销"></a>注销</h5><ul><li>注销原模块，新的模块系统能否正确处理。</li><li>终止注销能否返回原模块，原用户。</li><li>注销原用户，新用户系统能否正确处理。</li><li>使用错误的账号、口令、无权限的被禁用的账号进行注销</li></ul><h5 id="登录测试"><a href="#登录测试" class="headerlink" title="登录测试"></a>登录测试</h5><ul><li>登录<ul><li>登录方式</li><li>快速登录</li><li>免登录<ul><li>密码修改</li></ul></li><li>多端登录是否限制</li><li>密码修改</li></ul></li><li>离线（游客模式）<ul><li>页面权限控制</li><li>跳转登录</li></ul></li></ul><h5 id="导航测试"><a href="#导航测试" class="headerlink" title="导航测试"></a>导航测试</h5><ul><li>按钮、对话框、列表和窗口等；或在不同的连接页面之间需要导航</li><li>是否易于导航，导航是否直观</li><li>是否需要搜索引擎</li><li>导航帮助是否准确直观</li><li>导航与页面结构、菜单、连接页面的风格是否一致</li></ul><h5 id="图形测试"><a href="#图形测试" class="headerlink" title="图形测试"></a>图形测试</h5><ul><li>横向比较。各控件操作方式统一</li><li>自适应界面设计，内容根据窗口大小自适应</li><li>页面标签风格是否统一</li><li>页面是否美观</li><li>页面的图片应有其实际意义而要求整体有序美观</li><li>图片质量要高且图片尺寸在设计符合要求的情况下应尽量小</li><li>界面整体使用的颜色不宜过多</li></ul><h5 id="内容测试"><a href="#内容测试" class="headerlink" title="内容测试"></a>内容测试</h5><ul><li>输入框说明文字的内容与系统功能是否一致</li><li>文字长度是否加以限制</li><li>文字内容是否表意不明</li><li>是否有错别字</li><li>信息是否为中文显示</li><li>是否有敏感性词汇、关键词</li><li>是否有敏感性图片，如：涉及版权、专利、隐私等图片</li></ul><h5 id="弱网测试"><a href="#弱网测试" class="headerlink" title="弱网测试"></a>弱网测试</h5><ul><li>各个功能正常<ul><li>可以浏览本地数据</li><li>退出app再开启app时能正常浏览</li><li>切换到后台再切回前台可以正常浏览</li><li>锁屏后再解屏回到应用前台可以正常浏览</li><li>在对服务端的数据有更新时会给予离线的相应提示</li></ul></li><li>丢包会重试</li><li>最小原则：不能闪退</li></ul><h5 id="协议测试"><a href="#协议测试" class="headerlink" title="协议测试"></a>协议测试</h5><p>直接协议访问，服务端要做校验</p><h5 id="定位、照相机服务"><a href="#定位、照相机服务" class="headerlink" title="定位、照相机服务"></a>定位、照相机服务</h5><ul><li>App有用到相机，定位服务时，需要注意系统版本差异</li><li>有用到定位服务、照相机服务的地方，需要进行前后台的切换测试，检查应用是否正常。</li><li>当定位服务没有开启时，使用定位服务，会友好性弹出是否允许设置定位提示。当确定允许开启定位时，能自动跳转到定位设置中开启定位服务。</li><li>测试定位、照相机服务时，需要采用真机进行测试。</li></ul><h5 id="时间测试"><a href="#时间测试" class="headerlink" title="时间测试"></a>时间测试</h5><ul><li>客户端可以自行设置手机的时区、时间，因此需要校验该设置对app的影响。</li><li>中国为东8区，所以当手机设置的时间非东8区时，查看需要显示时间的地方，时间是否展示正确，应用功能是否正常。时间一般需要根据服务器时间再转换成客户端对应的时区来展示，这样的用户体验比较好。比如发表一篇微博在服务端记录的是10：00，此时，华盛顿时间为22：00，客户端去浏览时，如果设置的是华盛顿时间,则显示的发表时间即为22:00,当时间设回东8区时间时，再查看则显示为10：00。</li></ul><h3 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h3><h4 id="自动化工具"><a href="#自动化工具" class="headerlink" title="自动化工具"></a>自动化工具</h4><ul><li>Appium</li><li>Airtest</li><li>uiautomator2</li></ul><h4 id="稳定性测试工具"><a href="#稳定性测试工具" class="headerlink" title="稳定性测试工具"></a>稳定性测试工具</h4><ul><li>Monkey</li><li>MonkeyRunner</li><li>Maxim</li><li>UICrawler</li></ul><h4 id="性能测试工具"><a href="#性能测试工具" class="headerlink" title="性能测试工具"></a>性能测试工具</h4><ul><li>GT</li><li>Perfdog</li><li>SoloPi</li></ul><h4 id="弱网测试-amp-抓包工具"><a href="#弱网测试-amp-抓包工具" class="headerlink" title="弱网测试&amp;抓包工具"></a>弱网测试&amp;抓包工具</h4><ul><li>QNET</li><li>Fiddler</li><li>Charles</li><li>Whistle</li></ul><h4 id="兼容性测试工具"><a href="#兼容性测试工具" class="headerlink" title="兼容性测试工具"></a>兼容性测试工具</h4><ul><li>TestIn</li><li>腾讯优测</li><li>百度MTC</li><li>阿里MQC</li></ul><h4 id="安全测试工具"><a href="#安全测试工具" class="headerlink" title="安全测试工具"></a>安全测试工具</h4><ul><li>OWASP ZAP</li><li>Drozer</li><li>MobSF</li><li>QARK</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章介绍App测试的基本概念。&lt;br&gt;
    
    </summary>
    
    
      <category term="app" scheme="https://lightalight.github.io/tags/app/"/>
    
  </entry>
  
  <entry>
    <title>Golang（四）Golang的包管理</title>
    <link href="https://lightalight.github.io/2021/05/15/Golang04/"/>
    <id>https://lightalight.github.io/2021/05/15/Golang04/</id>
    <published>2021-05-15T14:23:32.000Z</published>
    <updated>2022-07-03T03:18:39.247Z</updated>
    
    <content type="html"><![CDATA[<p>　　包是管理整个工程的工具。把同类型的文件放在一个目录，称之为 “包”，多个包构成 一个工程。<br>　　本文章主要介绍 Golang 的包管理。</p><a id="more"></a><h2 id="Quick-Guide"><a href="#Quick-Guide" class="headerlink" title="Quick Guide"></a>Quick Guide</h2><h3 id="一、包的规则"><a href="#一、包的规则" class="headerlink" title="一、包的规则"></a>一、包的规则</h3><ul><li>包名一般是小写的，使用一个简短且有意义的名称。</li><li>包名一般要和所在的目录同名，也可以不同，包名中不能包含<code></code>等特殊符号。</li><li>包一般使用域名作为目录名称，这样能保证包名的唯一性，比如 GitHub 项目的包一般会放到<code>GOPATH/src/github.com/userName/projectName</code>目录下。</li><li>包名为 main 的包为应用程序的入口包，编译不包含 main 包的源码文件时不会得到可执行文件。</li><li>一个文件夹下的所有源码文件只能属于同一个包。</li></ul><h3 id="二、自定义包"><a href="#二、自定义包" class="headerlink" title="二、自定义包"></a>二、自定义包</h3><ul><li>1.在 GOPATH 的 src 目录下创建一个文件（后缀必须是 .go）</li><li>2.文件开头都声明”package &lt;包名,一般是目录名&gt;“</li><li>3,定义包里面的函数,就完成了一个简单的包</li></ul><p><img src="/image/Golang04/Golang04_001.png" alt=""></p><h3 id="三、包的导入"><a href="#三、包的导入" class="headerlink" title="三、包的导入"></a>三、包的导入</h3><p>要在代码中引用其他包的内容，需要使用 import 关键字导入使用的包。具体语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"包的路径"</span></span><br></pre></td></tr></table></figure><ul><li>import 导入语句通常放在源码文件开头包声明语句的下面；</li><li>导入的包名需要使用双引号包裹起来；</li><li>包名是从<code>GOPATH/src/</code> 后开始计算的，使用<code>/</code> 进行路径分隔。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当行导入</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"包 1 的路径"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"包 2 的路径"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多行导入</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"包 1 的路径"</span></span><br><span class="line">    <span class="string">"包 2 的路径"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绝对路径导入:以GOROOT/src/或GOPATH/src/的路径为起始点,计算被引用包的路径</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"database/sql"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相对路径导入:以引用的文件为起始点,计算被引用包的路径</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"../sql"</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main    <span class="comment">// 声明 main 包</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span>       <span class="comment">// 导入 fmt 包，打印字符串是需要用到</span></span><br><span class="line">    myfmt <span class="string">"mylib/fmt"</span>  <span class="comment">// 命名为 myfmt</span></span><br><span class="line">)</span><br><span class="line">func main() &#123;   <span class="comment">// 声明 main 主函数</span></span><br><span class="line">    fmt.Println(<span class="string">"Hello World!"</span>) <span class="comment">// 打印 Hello World!</span></span><br><span class="line">    myfmt.Println(<span class="string">"Hello World again!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、包的引用格式"><a href="#四、包的引用格式" class="headerlink" title="四、包的引用格式"></a>四、包的引用格式</h3><p>包的引用有四种格式，下面以 fmt 包为例来分别演示一下这四种格式。</p><ul><li>标准引用格式</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"标准引用"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自定义别名引用格式</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> F <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    F.Println(<span class="string">"自定义别名引用"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>省略引用格式</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> . <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//不需要加前缀 fmt.</span></span><br><span class="line">    Println(<span class="string">"省略引用"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>匿名引用格式：只执行包初始化的 init 函数，而不使用包内部的数据</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    _ <span class="string">"database/sql"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"匿名引用"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、包的加载"><a href="#五、包的加载" class="headerlink" title="五、包的加载"></a>五、包的加载</h3><p>当使用main启动这个程序的时候，包就会加载起来，过程如下图：</p><p><img src="/image/Golang04/Golang04_002.png" alt=""></p><h3 id="六、常用的包"><a href="#六、常用的包" class="headerlink" title="六、常用的包"></a>六、常用的包</h3><p>接下来给大家列一下常用的内置包，可以方便大家使用，省的还需要自己去定义。</p><ul><li>1.fmt：格式化的标准输入输出<ul><li>Printf() ：输出后换行</li><li>Println() ：格式化输出</li></ul></li><li>2.io：提供了原始的 I/O 操作界面</li><li>3.bufio：各个组件内部都维护了一个缓冲区，数据读写操作都直接通过缓存区进行 bufio 包通过对 io 包的封装，提供了数据缓冲功能，能够一定程度减少大块数据读写带来的开销。</li><li>4.sort：提供了用于对切片和用户定义的集合进行排序的功能。</li><li>5.strconv：提供了将字符串转换成基本数据类型，或者从基本数据类型转换为字符串的功能。</li><li>6.os：提供了不依赖平台的操作系统函数接口<ul><li>Hostname():返回内核提供的主机名</li><li>Environ():返回所有的环境变量，返回值格式为“key=value”的字符串的切片拷贝。</li><li>Getenv():会检索并返回名为 key 的环境变量的值。如果不存在该环境变量则会返回空字符串。</li><li>Setenv():设置名为 key 的环境变量，如果出错会返回该错误。</li><li>Exit():当前程序以给出的状态码 code 退出。</li><li>Getwd():回一个对应当前工作目录的根路径。</li><li>Mkdir():可以使用指定的权限和名称创建一个目录。</li><li>MkdirAll():可以使用指定的权限和名称创建一个目录，包括任何必要的上级目录，并返回 nil，否则返回错误。</li><li>Remove():会删除 name 指定的文件或目录。</li><li>RemoveAll ():会递归的删除所有子目录和文件。</li></ul></li><li>7.os/exec：提供了执行自定义 linux 命令的相关实现。</li><li>8.sync：多线程中锁机制以及其他同步互斥机制<ul><li>Mutex:互斥锁</li><li>RWMutex：读写锁</li></ul></li><li>9.flag：提供命令行参数的规则定义和传入参数解析的功能</li><li>10.encoding/json：JSON的序列号和反序列化</li><li>11.html/template：web 开发中生成 html 的 template 的一些函数</li><li>12.net/http：提供 HTTP 相关服务，主要包括 http 请求、响应和 URL 的解析，以及基本的 http 客户端和扩展的 http 服务。</li><li>13.reflect：提供运行时反射，允许程序通过抽象类型操作对象。</li><li>14.strings和bytes：提供处理字符串的一些函数集合，包括合并、查找、分割、比较、后缀检查、索引、大小写处理等等。</li><li>15.log：用于在程序中输出日志<ul><li>Print(): 普通输出；</li><li>Fatal(): 在执行完 Print 后，执行 os.Exit(1)；</li><li>Panic():在执行完 Print 后调用 panic() 方法。</li></ul></li><li>16.math/big：实现了大数字的多精度计算<ul><li>Int:有符号整数</li><li>Rat:有理数</li><li>Float:浮点数</li></ul></li><li>17.regexp:正则表达式</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"regexp"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">buf := <span class="string">"abc azc a7c aac 888 a9c  tac"</span></span><br><span class="line"><span class="comment">//解析正则表达式，如果成功返回解释器</span></span><br><span class="line">reg1 := regexp.MustCompile(<span class="string">`a.c`</span>)</span><br><span class="line"><span class="keyword">if</span> reg1 == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"regexp err"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据规则提取关键信息</span></span><br><span class="line">result1 := reg1.FindAllStringSubmatch(buf, <span class="number">-1</span>)</span><br><span class="line">fmt.Println(<span class="string">"result1 = "</span>, result1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>18.time：时间显示和测量等所用的函数<ul><li>Now()：当前时间</li><li>Add() :增加时间</li><li>Sub():时间相减</li><li>ParseInLocation():字符串转为本地时间</li><li>Pta</li></ul></li><li>19.flag：给命令行参数增加描述</li></ul><h3 id="七、第三方包的管理"><a href="#七、第三方包的管理" class="headerlink" title="七、第三方包的管理"></a>七、第三方包的管理</h3><p><strong>go module</strong> 是Go语言默认的依赖管理工具。除此之外,还有godep、glide和govendor，这边就不过多描述。</p><p>常用命令如下:</p><ul><li>1.准备工作，先设置代理</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Windows 下设置 GOPROXY 的命令为</span></span><br><span class="line"><span class="keyword">go</span> env -w GOPROXY=https:<span class="comment">//goproxy.cn,direct</span></span><br><span class="line"><span class="comment">// MacOS 或 Linux 下设置 GOPROXY 的命令为：</span></span><br><span class="line">export GOPROXY=https:<span class="comment">//goproxy.cn</span></span><br></pre></td></tr></table></figure><ul><li>2.在 GOPATH 目录之外新建一个工程目录，并使用go mod init初始化生成 go.mod 文件。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> mod init hello</span><br></pre></td></tr></table></figure><p>go.mod文件内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module go_mod</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.15</span></span><br></pre></td></tr></table></figure><ul><li>3.创建一个go文件，然后增加依赖引用，并运行它。它就会去自动下载需要的第三方包，放到 GOPATH目录下pkg/mod,并且会更新 go.mod文件。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/labstack/echo"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">e := echo.New()</span><br><span class="line">e.GET(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c echo.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.String(http.StatusOK, <span class="string">"Hello World!"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go.mod文件内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module go_mod</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.15</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">github.com/labstack/echo v3<span class="number">.3</span><span class="number">.10</span>+incompatible</span><br><span class="line">github.com/labstack/gommon v0<span class="number">.3</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">golang.org/x/crypto v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200820211705</span><span class="number">-5</span>c72a883971a <span class="comment">// indirect</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>go.mod 提供了 module、require、replace 和 exclude 四个命令：</p><ul><li>module 语句指定包的名字（路径）；</li><li>require 语句指定的依赖项模块；</li><li>replace 语句可以替换依赖项模块；</li><li>exclude 语句可以忽略依赖项模块。</li></ul><p>More info: <a href="http://c.biancheng.net/golang/" target="_blank" rel="noopener">Golang</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　包是管理整个工程的工具。把同类型的文件放在一个目录，称之为 “包”，多个包构成 一个工程。&lt;br&gt;　　本文章主要介绍 Golang 的包管理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://lightalight.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang（三）Go语言的基本语法(下)</title>
    <link href="https://lightalight.github.io/2021/04/15/Golang03/"/>
    <id>https://lightalight.github.io/2021/04/15/Golang03/</id>
    <published>2021-04-15T14:23:32.000Z</published>
    <updated>2022-07-03T03:18:39.270Z</updated>
    
    <content type="html"><![CDATA[<p>　　本文章主要介绍 Golang 的基本语法。</p><a id="more"></a><h2 id="Quick-Guide"><a href="#Quick-Guide" class="headerlink" title="Quick Guide"></a>Quick Guide</h2><h3 id="一、容器"><a href="#一、容器" class="headerlink" title="一、容器"></a>一、容器</h3><p>复杂类型的变量,具有各种形式的存储和处理数据的功能,主要用于编写复杂算法、结构和逻辑。</p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。</p><p>声明语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组变量名 [元素数量]Type</span><br></pre></td></tr></table></figure><ul><li>数组变量名：数组声明及使用时的变量名。</li><li>元素数量：数组的元素数量，可以是一个表达式，但最终通过编译期计算的结果必须是整型数值，元素数量不能含有到运行时才能确认大小的数值。</li><li>Type：可以是任意基本类型，包括数组本身，类型为数组本身时，可以实现多维数组。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> a [<span class="number">3</span>]<span class="keyword">int</span>             <span class="comment">// 定义三个整数的数组</span></span><br><span class="line">    <span class="comment">// 访问数组的每个元素可以通过索引下标，索引下标的范围是从 0 开始到数组长度减 1 的位置，内置函数 len() 可以返回数组中元素的个数。</span></span><br><span class="line">  fmt.Println(a[<span class="number">0</span>])        <span class="comment">// 打印第一个元素</span></span><br><span class="line">  fmt.Println(a[<span class="built_in">len</span>(a)<span class="number">-1</span>]) <span class="comment">// 打印最后一个元素</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历数组——访问每一个数组元素，打印索引和元素</span></span><br><span class="line">  <span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%d %d\n"</span>, i, v)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果在数组长度的位置出现“...”省略号，则表示数组的长度是根据初始化值的个数来计算</span></span><br><span class="line">    q := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, q) <span class="comment">// "[3]int"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>默认情况下，数组的每个元素都会被初始化为元素类型对应的零值。</strong></p><h5 id="数组之间的对比"><a href="#数组之间的对比" class="headerlink" title="数组之间的对比"></a>数组之间的对比</h5><p>可以直接通过较运算符 ==和!=</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    b := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    c := [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>&#125;</span><br><span class="line">    fmt.Println(a == b, a == c, b == c) <span class="comment">// "true false false"</span></span><br><span class="line">    d := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    fmt.Println(a == d) <span class="comment">// 编译错误：无法比较 [2]int == [3]int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h5><p>声明语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array_name [size1][size2]...[sizen] array_type</span><br></pre></td></tr></table></figure><ul><li>array_name 为数组的名字</li><li>array_type 为数组的类型</li><li>size1、size2 等等为数组每一维度的长度。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 声明一个二维整型数组，两个维度的长度分别是 4 和 2</span></span><br><span class="line">    <span class="keyword">var</span> array [<span class="number">4</span>][<span class="number">2</span>]<span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 使用数组字面量来声明并初始化一个二维整型数组</span></span><br><span class="line">    array = [<span class="number">4</span>][<span class="number">2</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">10</span>, <span class="number">11</span>&#125;, &#123;<span class="number">20</span>, <span class="number">21</span>&#125;, &#123;<span class="number">30</span>, <span class="number">31</span>&#125;, &#123;<span class="number">40</span>, <span class="number">41</span>&#125;&#125;</span><br><span class="line">    <span class="comment">// 声明并初始化数组中索引为 1 和 3 的元素</span></span><br><span class="line">    array = [<span class="number">4</span>][<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>: &#123;<span class="number">20</span>, <span class="number">21</span>&#125;, <span class="number">3</span>: &#123;<span class="number">40</span>, <span class="number">41</span>&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>切片（slice）是对数组的一个连续片段的<strong>引用</strong>,就像切糕一样,把数组切出几块,取出其中一块.</p><p>语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice [开始位置 : 结束位置]</span><br></pre></td></tr></table></figure><ul><li>slice：表示目标切片对象；</li><li>开始位置：对应目标切片对象的索引；</li><li>结束位置：对应目标切片的结束索引。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a  = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    fmt.Println(a, a[<span class="number">1</span>:<span class="number">2</span>]) <span class="comment">// 结果:[1 2 3]  [2]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片规则</p><ul><li>取出的元素数量为：结束位置 - 开始位置；</li><li>取出元素不包含结束位置对应的索引，切片最后一个元素使用 slice[len(slice)] 获取；</li><li>当缺省开始位置时，表示从连续区域开头到结束位置；</li><li>当缺省结束位置时，表示从开始位置到整个连续区域末尾；</li><li>两者同时缺省时，与切片本身等效；</li><li>两者同时为 0 时，等效于空切片，一般用于切片复位。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> highRiseBuilding [<span class="number">30</span>]<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">30</span>; i++ &#123;</span><br><span class="line">            highRiseBuilding[i] = i + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间</span></span><br><span class="line">    fmt.Println(highRiseBuilding[<span class="number">10</span>:<span class="number">15</span>])</span><br><span class="line">    <span class="comment">// 中间到尾部的所有元素</span></span><br><span class="line">    fmt.Println(highRiseBuilding[<span class="number">20</span>:])</span><br><span class="line">    <span class="comment">// 开头到中间指定位置的所有元素</span></span><br><span class="line">    fmt.Println(highRiseBuilding[:<span class="number">2</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="声明切片"><a href="#声明切片" class="headerlink" title="声明切片"></a>声明切片</h5><p>声明语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name []Type</span><br><span class="line"><span class="built_in">make</span>( []Type, size, <span class="built_in">cap</span> )</span><br><span class="line"><span class="comment">// make函数用于初始化slice、chan和map</span></span><br><span class="line"><span class="comment">// 如果只用var声明，不用make初始化，变量对应的值为nil。</span></span><br><span class="line"><span class="comment">// size 元素的个数</span></span><br><span class="line"><span class="comment">// cap 从它的第一个元素开始数，到其底层数组元素末尾的个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 声明字符串切片</span></span><br><span class="line">    <span class="keyword">var</span> strList []<span class="keyword">string</span></span><br><span class="line">    <span class="comment">// 声明整型切片</span></span><br><span class="line">    <span class="keyword">var</span> numList []<span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 声明一个空切片</span></span><br><span class="line">    <span class="keyword">var</span> numListEmpty = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 输出3个切片</span></span><br><span class="line">    fmt.Println(strList, numList, numListEmpty)</span><br><span class="line"></span><br><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(a), <span class="built_in">len</span>(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="切片扩容"><a href="#切片扩容" class="headerlink" title="切片扩容"></a>切片扩容</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 扩展元素,cap不足,低于1000一下是翻倍扩展,大于等于1.25倍增加</span></span><br><span class="line">    <span class="keyword">var</span> a []<span class="keyword">int</span></span><br><span class="line">    a = <span class="built_in">append</span>(a, <span class="number">1</span>) <span class="comment">// 追加1个元素</span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    a = <span class="built_in">append</span>(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 追加多个元素, 手写解包方式</span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    a = <span class="built_in">append</span>(a, []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;...) <span class="comment">// 追加一个切片, 切片需要解包</span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="切片删除元素"><a href="#切片删除元素" class="headerlink" title="切片删除元素"></a>切片删除元素</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">a = a[<span class="number">1</span>:] <span class="comment">// 删除开头1个元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:<span class="number">2</span>], a[<span class="number">2</span>+<span class="number">1</span>:]...) <span class="comment">// 删除中间1个元素</span></span><br><span class="line">a = a[:<span class="number">3</span><span class="number">-1</span>] <span class="comment">// 删除尾部1个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="切片复制"><a href="#切片复制" class="headerlink" title="切片复制"></a>切片复制</h5><p>语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span>( destSlice, srcSlice []T) <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    slice2 := []<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="built_in">copy</span>(slice2, slice1) <span class="comment">// 只会复制slice1的前3个元素到slice2中</span></span><br><span class="line">    <span class="built_in">copy</span>(slice1, slice2) <span class="comment">// 只会复制slice2的3个元素到slice1的前3个位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="多维切片"><a href="#多维切片" class="headerlink" title="多维切片"></a>多维切片</h5><p>语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sliceName [][]...[]sliceType</span><br></pre></td></tr></table></figure><p><img src="/image/Golang03/Golang03_001.png" alt=""></p><h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><p>map是一种元素对（pair）的无序集合，pair 对应一个 key（索引）和一个 value（值），所以这个结构也称为关联数组或字典。</p><p>声明语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mapname <span class="keyword">map</span>[keytype]valuetype</span><br><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[keytype]valuetype, <span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure><ul><li>mapname 为 map 的变量名。</li><li>keytype 为键类型。</li><li>valuetype 是键对应的值类型。</li><li>cap 预设的容量。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mapLit := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"one"</span>: <span class="number">1</span>, <span class="string">"two"</span>: <span class="number">2</span>&#125;</span><br><span class="line">mapCreated := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">float32</span>)</span><br><span class="line">mapCreated[<span class="string">"key1"</span>] = <span class="number">4.5</span></span><br><span class="line">mapCreated[<span class="string">"key2"</span>] = <span class="number">3.14159</span></span><br><span class="line">mapLit[<span class="string">"two"</span>] = <span class="number">3</span></span><br><span class="line">fmt.Printf(<span class="string">"Map literal at \"one\" is: %d\n"</span>, mapLit[<span class="string">"one"</span>])</span><br><span class="line">fmt.Printf(<span class="string">"Map created at \"key2\" is: %f\n"</span>, mapCreated[<span class="string">"key2"</span>])</span><br><span class="line">fmt.Printf(<span class="string">"Map assigned at \"two\" is: %d\n"</span>, mapLit[<span class="string">"two"</span>])</span><br><span class="line">fmt.Printf(<span class="string">"Map literal at \"ten\" is: %d\n"</span>, mapLit[<span class="string">"ten"</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="map的高级用法"><a href="#map的高级用法" class="headerlink" title="map的高级用法"></a>map的高级用法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line">scene := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">  scene[<span class="string">"route"</span>] = <span class="number">66</span></span><br><span class="line">  scene[<span class="string">"brazil"</span>] = <span class="number">4</span></span><br><span class="line">scene[<span class="string">"china"</span>] = <span class="number">960</span></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line">  <span class="keyword">for</span> k, v := <span class="keyword">range</span> scene &#123;</span><br><span class="line">        fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定key</span></span><br><span class="line"><span class="built_in">delete</span>(scene, <span class="string">"brazil"</span>)</span><br><span class="line">fmt.Println(scene)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>list是一种非连续的存储容器，由多个节点组成，节点通过变量记录彼此之间的关系，列表有多种实现方法，如单链表、双链表等。</p><p>列表的原理可以这样理解：假设 A、B、C 三个人都有电话号码，如果 A 把号码告诉给 B，B 把号码告诉给 C，这个过程就建立了一个单链表结构，如下图所示。</p><p><img src="/image/Golang03/Golang03_002.png" alt=""></p><p>如果在这个基础上，再从 C 开始将自己的号码告诉给自己所知道号码的主人，这样就形成了双链表结构，如下图所示。</p><p><img src="/image/Golang03/Golang03_003.png" alt=""></p><p>那么如果需要获得所有人的号码，只需要从 A 或者 C 开始，要求他们将自己的号码发出来，然后再通知下一个人如此循环，这样就构成了一个列表遍历的过程。</p><p>如果 B 换号码了，他需要通知 A 和 C，将自己的号码移除，这个过程就是列表元素的删除操作，如下图所示。</p><p><img src="/image/Golang03/Golang03_004.png" alt=""></p><h5 id="列表的初始化"><a href="#列表的初始化" class="headerlink" title="列表的初始化"></a>列表的初始化</h5><ul><li>1.通过 container/list 包的 New() 函数初始化 list</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名 := list.New()</span><br></pre></td></tr></table></figure><ul><li>2.通过 var 关键字声明初始化 list</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 list.List</span><br></pre></td></tr></table></figure><h5 id="遍历列表"><a href="#遍历列表" class="headerlink" title="遍历列表"></a>遍历列表</h5><p>遍历双链表需要配合 Front() 函数获取头元素，遍历时只要元素不为空就可以继续进行，每一次遍历都会调用元素的 Next() 函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"container/list"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个 list</span></span><br><span class="line">l := list.New()</span><br><span class="line"><span class="comment">//把4元素放在最后</span></span><br><span class="line">e4 := l.PushBack(<span class="number">4</span>)</span><br><span class="line"><span class="comment">//把1元素放在最前</span></span><br><span class="line">e1 := l.PushFront(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 遍历所有元素并打印其内容</span></span><br><span class="line"><span class="keyword">for</span> e := l.Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">fmt.Println(e.Value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="在列表中插入元素"><a href="#在列表中插入元素" class="headerlink" title="在列表中插入元素"></a>在列表中插入元素</h5><table><thead><tr><th>方 法</th><th>功 能</th></tr></thead><tbody><tr><td>InsertAfter(v interface {}, mark <em> Element) </em> Element</td><td>在 mark 点之后插入元素，mark 点由其他插入函数提供</td></tr><tr><td>InsertBefore(v interface {}, mark <em> Element) </em>Element</td><td>在 mark 点之前插入元素，mark 点由其他插入函数提供</td></tr><tr><td>PushBackList(other *List)</td><td>添加 other 列表元素到尾部</td></tr><tr><td>PushFrontList(other *List)</td><td>添加 other 列表元素到头部</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"container/list"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个 list</span></span><br><span class="line">l := list.New()</span><br><span class="line"><span class="comment">//把4元素放在最后</span></span><br><span class="line">e4 := l.PushBack(<span class="number">4</span>)</span><br><span class="line"><span class="comment">//把1元素放在最前</span></span><br><span class="line">e1 := l.PushFront(<span class="number">1</span>)</span><br><span class="line"><span class="comment">//在e4元素前面插入3</span></span><br><span class="line">l.InsertBefore(<span class="number">3</span>, e4)</span><br><span class="line"><span class="comment">//在e1后面插入2</span></span><br><span class="line">l.InsertAfter(<span class="number">2</span>, e1)</span><br><span class="line"><span class="comment">// 遍历所有元素并打印其内容</span></span><br><span class="line"><span class="keyword">for</span> e := l.Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">fmt.Println(e.Value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="从列表中删除元素"><a href="#从列表中删除元素" class="headerlink" title="从列表中删除元素"></a>从列表中删除元素</h5><p>列表插入函数的返回值会提供一个 *list.Element 结构，这个结构记录着列表元素的值以及与其他节点之间的关系等信息，从列表中删除元素时，需要用到这个结构进行快速删除。</p><p>直接看例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"container/list"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">l := list.New()</span><br><span class="line"><span class="comment">// 尾部添加</span></span><br><span class="line">l.PushBack(<span class="string">"canon"</span>)</span><br><span class="line"><span class="comment">// 头部添加</span></span><br><span class="line">l.PushFront(<span class="number">67</span>)</span><br><span class="line"><span class="comment">// 尾部添加后保存元素句柄</span></span><br><span class="line">element := l.PushBack(<span class="string">"fist"</span>)</span><br><span class="line"><span class="comment">// 在fist之后添加high</span></span><br><span class="line">l.InsertAfter(<span class="string">"high"</span>, element)</span><br><span class="line"><span class="comment">// 在fist之前添加noon</span></span><br><span class="line">l.InsertBefore(<span class="string">"noon"</span>, element)</span><br><span class="line"><span class="comment">// 遍历所有元素并打印其内容</span></span><br><span class="line"><span class="keyword">for</span> e := l.Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">fmt.Println(e.Value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">l.Remove(element)</span><br><span class="line">fmt.Println(<span class="string">"删除后"</span>)</span><br><span class="line"><span class="comment">// 遍历所有元素并打印其内容</span></span><br><span class="line"><span class="keyword">for</span> e := l.Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">fmt.Println(e.Value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、结构体"><a href="#二、结构体" class="headerlink" title="二、结构体"></a>二、结构体</h3><p>结构体是一种复合类型，由零个或多个任意类型的值聚合成的实体，每个值都可以称为结构体的成员。</p><p>定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名 <span class="keyword">struct</span> &#123;</span><br><span class="line">    字段<span class="number">1</span> 字段<span class="number">1</span>类型</span><br><span class="line">    字段<span class="number">2</span> 字段<span class="number">2</span>类型</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类型名：标识自定义结构体的名称，在同一个包内不能重复。</li><li>struct{}：表示结构体类型</li><li>字段1、字段2……：表示结构体字段名，结构体中的字段名必须唯一。</li><li>字段1类型、字段2类型……：表示结构体各个字段的类型,可以是结构体。</li></ul><h4 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 定义只是一种内存布局的描述，只有当实例化时，才会真正地分配内存</span></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">X <span class="keyword">int</span></span><br><span class="line">Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 实例化</span></span><br><span class="line"><span class="keyword">var</span> p Point</span><br><span class="line"><span class="comment">// 用.访问</span></span><br><span class="line">p.X = <span class="number">10</span></span><br><span class="line">p.Y = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">fmt.Println(p.X)</span><br><span class="line">fmt.Println(p.Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以通过以下两种方式实例化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ins := <span class="built_in">new</span>(T)</span><br><span class="line">ins := &amp;T&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>T 表示结构体类型</li><li>ins：T 类型被实例化后保存到 ins 变量中，ins 的类型为 *T，属于指针。</li></ul><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ins := 结构体类型名&#123;</span><br><span class="line">    字段<span class="number">1</span>: 字段<span class="number">1</span>的值,</span><br><span class="line">    字段<span class="number">2</span>: 字段<span class="number">2</span>的值,</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ins := 结构体类型名&#123;</span><br><span class="line">    字段<span class="number">1</span>的值,</span><br><span class="line">    字段<span class="number">2</span>的值,</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">name  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">relation := &amp;People&#123;</span><br><span class="line">name: <span class="string">"爷爷"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">Province    <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">addr := Address&#123;</span><br><span class="line"><span class="string">"四川"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(relation.name)</span><br><span class="line">fmt.Println(addr.Province)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ins := <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 匿名结构体字段定义</span></span><br><span class="line">    字段<span class="number">1</span> 字段类型<span class="number">1</span></span><br><span class="line">    字段<span class="number">2</span> 字段类型<span class="number">2</span></span><br><span class="line">    …</span><br><span class="line">&#125;&#123;</span><br><span class="line">    <span class="comment">// 字段值初始化</span></span><br><span class="line">    初始化字段<span class="number">1</span>: 字段<span class="number">1</span>的值,</span><br><span class="line">    初始化字段<span class="number">2</span>: 字段<span class="number">2</span>的值,</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 实例化一个匿名结构体</span></span><br><span class="line">msg := &amp;<span class="keyword">struct</span> &#123;  <span class="comment">// 定义部分</span></span><br><span class="line">id   <span class="keyword">int</span></span><br><span class="line">data <span class="keyword">string</span></span><br><span class="line">&#125;&#123;  <span class="comment">// 值初始化部分</span></span><br><span class="line"><span class="number">1024</span>,</span><br><span class="line"><span class="string">"hello"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(msg.id)</span><br><span class="line">fmt.Println(msg.data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、接口"><a href="#三、接口" class="headerlink" title="三、接口"></a>三、接口</h3><p>接口是一组方法的集合，可以理解为抽象的类型。它提供了一种非侵入式的接口。任何类型只要实现了该接口中方法集，那么就属于这个类型。</p><p>接口声明的格式:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口类型名 <span class="keyword">interface</span>&#123;</span><br><span class="line">    方法名<span class="number">1</span>( 参数列表<span class="number">1</span> ) 返回值列表<span class="number">1</span></span><br><span class="line">    方法名<span class="number">2</span>( 参数列表<span class="number">2</span> ) 返回值列表<span class="number">2</span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接口类型名：使用 type 将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加 er，如有写操作的接口叫 Writer</li><li>方法名：当方法名首字母是大写时，且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。（小写屏蔽隐藏机制）</li><li>参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以被忽略</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个鸭子接口</span></span><br><span class="line"><span class="keyword">type</span> Duck <span class="keyword">interface</span> &#123;</span><br><span class="line">Quack()   <span class="comment">// 鸭子叫</span></span><br><span class="line">DuckGo()  <span class="comment">// 鸭子走</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在有只鸡类型</span></span><br><span class="line"><span class="keyword">type</span> Chicken <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Chicken)</span> <span class="title">IsChicken</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"我是小鸡"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这只鸡会鸭子叫和鸭子走</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Chicken)</span> <span class="title">Quack</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"嘎嘎"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Chicken)</span> <span class="title">DuckGo</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"大摇大摆的走"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数，负责执行鸭子能做的事情</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoDuck</span><span class="params">(d Duck)</span></span> &#123;</span><br><span class="line">d.Quack()</span><br><span class="line">d.DuckGo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := Chicken&#123;&#125;</span><br><span class="line">DoDuck(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接口的方法 与 实现接口的类型方法格式一致</li><li>接口中所有方法均被实现</li></ul><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>如果想判断 一个使用在接口值上的操作，用于检查接口类型变量所持有的值是否实现了期望的接口或者具体的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value, ok := x.(T)</span><br></pre></td></tr></table></figure><ul><li>x 表示一个接口的类型</li><li>T 表示一个具体的类型（也可为接口类型）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 可以接受任何类型的数据</span></span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">x = <span class="number">10</span></span><br><span class="line">value1, ok1 := x.(<span class="keyword">int</span>)</span><br><span class="line">fmt.Print(value1, <span class="string">","</span>, ok1, <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">x = <span class="literal">nil</span></span><br><span class="line">value2, ok2 := x.(<span class="keyword">int</span>)</span><br><span class="line">fmt.Print(value2, <span class="string">","</span>, ok2, <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getType</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> a.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">        fmt.Println(<span class="string">"the type of a is int"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">        fmt.Println(<span class="string">"the type of a is string"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">        fmt.Println(<span class="string">"the type of a is float"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">"unknown type"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    getType(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口排序"><a href="#接口排序" class="headerlink" title="接口排序"></a>接口排序</h4><p>其实可以用来排序。内置接口 sort.Interface,它需要知道三个东西：序列的长度，表示两个元素比较的结果，一种交换两个元素的方式,它就会给你排序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将[]string定义为MyStringList类型</span></span><br><span class="line"><span class="keyword">type</span> MyStringList []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现sort.Interface接口的获取元素数量方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyStringList)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现sort.Interface接口的比较元素方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyStringList)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> m[i] &lt; m[j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现sort.Interface接口的交换元素方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyStringList)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">m[i], m[j] = m[j], m[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 准备一个内容被打乱顺序的字符串切片</span></span><br><span class="line">names := MyStringList&#123;</span><br><span class="line"><span class="string">"3. Triple Kill"</span>,</span><br><span class="line"><span class="string">"5. Penta Kill"</span>,</span><br><span class="line"><span class="string">"2. Double Kill"</span>,</span><br><span class="line"><span class="string">"4. Quadra Kill"</span>,</span><br><span class="line"><span class="string">"1. First Blood"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用sort包进行排序</span></span><br><span class="line">sort.Sort(names)</span><br><span class="line"><span class="comment">// 遍历打印结果</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> names &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、进程"><a href="#四、进程" class="headerlink" title="四、进程"></a>四、进程</h3><p><strong>进程</strong>：是程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位。 </p><p><strong>线程</strong>：是进程的一个执行实体，是 CPU 调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。 一个进程可以创建和撤销多个线程，同一个进程中的多个线程之间可以并发执行。</p><p><img src="/image/Golang03/Golang03_005.png" alt=""></p><p><strong>协程</strong>：协程是一种用户态的轻量级线程，由用户控制协程的调度。线程进程都是同步机制，而协程则是异步，只不过协程能保留上一次调用时的状态，每次切换回来时，就相当于进入上一次调用的状态。</p><p><img src="/image/Golang03/Golang03_006.png" alt=""></p><p><strong>并发</strong>： 多线程程序在单核心的 cpu 上运行，取得多个任务，利用时序切换不同任务执行.请看下图：</p><p><img src="/image/Golang03/Golang03_007.png" alt=""></p><p><strong>并行</strong>： 多线程程序在多核心的 cpu 上运行.取得多个任务，并同时去执行所取得的这些任务。相当于将长长的一条队列，划分成了多条短队列，所以并行缩短了任务队列的长度。请看下图：</p><p><img src="/image/Golang03/Golang03_008.png" alt=""></p><h4 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h4><p>go 并发是 让某个函数独立运行的能力，这个核心就是goroutine。goroutine有点类似协程，一个goroutine就是一个独立的工作单元，运行时通过算法调度这些goroutine来运行，在单个进程里执行成千上万的并发任务。</p><p>语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> 函数名( 参数列表 )</span><br></pre></td></tr></table></figure><ul><li>函数名：要调用的函数名。</li><li>参数列表：调用函数需要传入的参数。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">running</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> times <span class="keyword">int</span></span><br><span class="line"><span class="comment">// 构建一个无限循环</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">times++</span><br><span class="line">fmt.Println(<span class="string">"tick"</span>, times)</span><br><span class="line"><span class="comment">// 延时1秒</span></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 并发执行程序</span></span><br><span class="line"><span class="keyword">go</span> running()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受命令行输入, 不做任何事情</span></span><br><span class="line">    <span class="keyword">var</span> input <span class="keyword">string</span></span><br><span class="line">    fmt.Scanln(&amp;input)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用匿名函数创建goroutine"><a href="#使用匿名函数创建goroutine" class="headerlink" title="使用匿名函数创建goroutine"></a>使用匿名函数创建goroutine</h4><p>语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">( 参数列表 )</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;( 调用参数列表 )</span><br></pre></td></tr></table></figure><ul><li>参数列表：函数体内的参数变量列表。</li><li>函数体：匿名函数的代码。</li><li>调用参数列表：启动 goroutine 时，需要向匿名函数传递的调用参数。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> times <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            times++</span><br><span class="line">            fmt.Println(<span class="string">"tick"</span>, times)</span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">var</span> input <span class="keyword">string</span></span><br><span class="line">    fmt.Scanln(&amp;input)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1.一个是主进程执行过快，导致其他协程没有执行；</li><li>2.多个协程之间用到相同的数据；</li></ul><h4 id="等待组"><a href="#等待组" class="headerlink" title="等待组"></a>等待组</h4><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>(wg * WaitGroup) Add(delta int)</td><td>等待组的计数器 +1</td></tr><tr><td>(wg * WaitGroup) Done()</td><td>等待组的计数器 -1</td></tr><tr><td>(wg * WaitGroup) Wait()</td><td>当等待组计数器不等于 0 时阻塞直到变 0。</td></tr></tbody></table><p>使用步骤：</p><ul><li>1.利用wg.Add(delta)先增加计数器的个数</li><li>2.再利用wg.Done()减少计数器的个数，最后让计数器等于0</li><li>3.当等待组计数器等于0，才会执行wg.Wait()后面的代码，不然就一直阻塞</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 声明一个等待组</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="comment">// 准备一系列的网站地址</span></span><br><span class="line"><span class="keyword">var</span> urls = []<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"https://www.baidu.com/"</span>,</span><br><span class="line"><span class="string">"https://www.sougou.com/"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历这些地址</span></span><br><span class="line"><span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line"><span class="comment">// 每一个任务开始时, 将等待组增加1</span></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 开启一个并发</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(url <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 使用defer, 表示函数完成时将等待组值减1</span></span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="comment">// 使用http访问提供的地址</span></span><br><span class="line">_, err := http.Get(url)</span><br><span class="line"><span class="comment">// 访问完成后, 打印地址和可能发生的错误</span></span><br><span class="line">fmt.Println(url, err)</span><br><span class="line"><span class="comment">// 通过参数传递url地址</span></span><br><span class="line">&#125;(url)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待所有的任务完成</span></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">"over"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="资源竞争"><a href="#资源竞争" class="headerlink" title="资源竞争"></a>资源竞争</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">count <span class="keyword">int32</span></span><br><span class="line">wg    sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> incCount()</span><br><span class="line"><span class="keyword">go</span> incCount()</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(count)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incCount</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">fmt.Println(<span class="string">"count:"</span>,count)</span><br><span class="line">value := count</span><br><span class="line"><span class="comment">// 是让当前 goroutine 暂停的意思，退回执行队列，让其他等待的 goroutine 运行，目的是为了使资源竞争的结果更明显。</span></span><br><span class="line">runtime.Gosched()</span><br><span class="line">value++</span><br><span class="line">count = value</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预期是4,实际结果 2/3/4之间随机出现. 因为 count 变量没有任何同步保护，所以两个 goroutine 都会对其进行读写，会导致对已经计算好的结果被覆盖，以至于产生错误结果。</p><h5 id="锁住共享资源"><a href="#锁住共享资源" class="headerlink" title="锁住共享资源"></a>锁住共享资源</h5><p>解决方案1:锁住共享资源</p><ul><li>原子函数: 以很底层的加锁机制来同步访问整型变量和指针<ul><li>atomic.AddInt64 : 安全地加一个整型值的方式</li><li>atomic.LoadInt64 : 安全地读一个整型值的方式</li><li>atomic.StoreInt64 : 安全地写一个整型值的方式</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"sync/atomic"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">counter <span class="keyword">int64</span></span><br><span class="line">wg      sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> incCounter(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> incCounter(<span class="number">2</span>)</span><br><span class="line">wg.Wait() <span class="comment">//等待goroutine结束</span></span><br><span class="line">fmt.Println(counter)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incCounter</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> count := <span class="number">0</span>; count &lt; <span class="number">2</span>; count++ &#123;</span><br><span class="line"><span class="comment">//安全的对counter加1</span></span><br><span class="line">atomic.AddInt64(&amp;counter, <span class="number">1</span>) </span><br><span class="line">fmt.Println(<span class="string">"counter:"</span>,counter)</span><br><span class="line">runtime.Gosched()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h5><p>方案2:使用互斥锁。</p><ul><li>互斥锁:在代码上创建一个临界区，保证同一时间只有一个 goroutine 可以执行这个临界代码。<ul><li>sync.Mutex：暴力锁， 当一个 goroutine 获得了 Mutex 后，其他 goroutine 就只能乖乖等到这个 goroutine 释放该 Mutex。<ul><li>Lock() 加锁</li><li>Unlock() 解锁</li></ul></li><li>sync.RWMutex： 基于sync.Mutex产生的单写多读模型，运行多个 goroutine 读，读的时候不允许写入，写的时候不允许读。<ul><li>Lock()和Unlock()用于申请和释放写锁</li><li>RLock()和RUnlock()用于申请和释放读锁</li></ul></li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">counter <span class="keyword">int64</span></span><br><span class="line">wg      sync.WaitGroup</span><br><span class="line">mutex   sync.Mutex</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> incCounter(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> incCounter(<span class="number">2</span>)</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(counter)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incCounter</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> count := <span class="number">0</span>; count &lt; <span class="number">2</span>; count++ &#123;</span><br><span class="line"><span class="comment">//同一时刻只允许一个goroutine进入这个临界区</span></span><br><span class="line">mutex.Lock()</span><br><span class="line">&#123;</span><br><span class="line">value := counter</span><br><span class="line">runtime.Gosched()</span><br><span class="line">value++</span><br><span class="line">counter = value</span><br><span class="line">&#125;</span><br><span class="line">mutex.Unlock() <span class="comment">//释放锁，允许其他正在等待的goroutine进入临界区</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h4><p><img src="/image/Golang03/Golang03_009.png" alt=""></p><p>通道（channel）是一种特殊的类型。在任何时候，同时只能有一个 goroutine 访问通道进行发送和获取数据。goroutine 间通过通道就可以通信。</p><p>通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。</p><p>声明语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 通道变量 <span class="keyword">chan</span> 通道类型</span><br></pre></td></tr></table></figure><ul><li>通道类型：通道内的数据类型。</li><li>通道变量：保存通道的变量。</li></ul><p>创建语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通道实例 := <span class="built_in">make</span>(<span class="keyword">chan</span>类型 通道类型, 缓冲大小)</span><br></pre></td></tr></table></figure><ul><li>chan类型：<ul><li>chan&lt;- 只能用来发送</li><li>&lt;-chan 只能用来接收</li><li>chan 用来发送和接收</li></ul></li><li>通道类型：和无缓冲通道用法一致，影响通道发送和接收的数据类型。</li><li>缓冲大小：决定通道最多可以保存的元素数量。<ul><li><strong>无缓冲通道</strong>：不设置。进行发送 goroutine 需要被接收后才可以继续发送。接收的goroutine 也同理。</li><li><strong>缓冲通道</strong>：设置大小，缓存大小为设置个数。进行发送goroutine 可以在发送元素达到缓存上限之前，继续发。接收的goroutine 需要通道元素不为零，就可以一直接收。</li></ul></li><li>通道实例：被创建出的通道实例。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">senderOnly := <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)   <span class="comment">// 只能用来发送（管道的入口，只进不出）</span></span><br><span class="line">receiverOnly := <span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 只能用来接收（管道的出口，只出不进）</span></span><br><span class="line">unbuffer := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)       <span class="comment">// 无缓冲可收发</span></span><br><span class="line">buffer := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)      <span class="comment">// 无缓冲可收发</span></span><br><span class="line">fmt.Println(senderOnly, receiverOnly, unbuffer, buffer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用通道收发数据:</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通道变量 &lt;- 值</span><br><span class="line">收到的值 := &lt;-通道变量</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"start main"</span>)</span><br><span class="line">    <span class="comment">// 创建通道</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"come into goroutine1"</span>)</span><br><span class="line"><span class="keyword">var</span> r <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">r += i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据到通道</span></span><br><span class="line">ch &lt;- r</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"come into goroutine2"</span>)</span><br><span class="line"><span class="keyword">var</span> r <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">r *= i</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 发送数据到通道</span></span><br><span class="line">ch &lt;- r</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"come into goroutine3"</span>)</span><br><span class="line">        <span class="comment">// 发送数据到通道</span></span><br><span class="line">ch &lt;- <span class="number">11</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="comment">// 接受数据并累加</span></span><br><span class="line">result += &lt;-ch</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">fmt.Println(<span class="string">"result is:"</span>, result)</span><br><span class="line">fmt.Println(<span class="string">"end main"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"start main"</span>)</span><br><span class="line"><span class="comment">// 创建一个3个元素缓冲大小的整型通道</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 查看当前通道的大小</span></span><br><span class="line">fmt.Println(<span class="string">"通道的大小:"</span>,<span class="built_in">len</span>(ch))</span><br><span class="line"><span class="comment">// 开启一个并发匿名函数</span></span><br><span class="line"><span class="comment">// 开启一个并发匿名函数</span></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line">ch &lt;- <span class="number">3</span></span><br><span class="line">fmt.Println(<span class="string">"通道的大小:"</span>,<span class="built_in">len</span>(ch))</span><br><span class="line"><span class="comment">// 遍历接收通道数据</span></span><br><span class="line"><span class="keyword">for</span> data := <span class="keyword">range</span> ch &#123;</span><br><span class="line"><span class="comment">// 打印通道数据</span></span><br><span class="line">fmt.Println(data)</span><br><span class="line"><span class="comment">// 当遇到数据0时, 退出接收循环</span></span><br><span class="line"><span class="keyword">if</span> data == <span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"end main"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="超时通道"><a href="#超时通道" class="headerlink" title="超时通道"></a>超时通道</h5><p>因为发送元素到通道,如果没有及时被接收,就会造成阻塞.所以我们可以结合select进行超时判断:</p><p>语法结构如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-chan1:</span><br><span class="line">    <span class="comment">// 如果chan1成功读到数据，则进行该case处理语句</span></span><br><span class="line">    <span class="keyword">case</span> chan2 &lt;- <span class="number">1</span>:</span><br><span class="line">    <span class="comment">// 如果成功向chan2写入数据，则进行该case处理语句</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 如果上面都没有成功，则进入default处理流程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建普通通道</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 创建超时通道</span></span><br><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"><span class="comment">//新开一个协程</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> num := &lt;-ch:</span><br><span class="line">fmt.Println(<span class="string">"num = "</span>, num)</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">3</span> * time.Second):</span><br><span class="line"><span class="comment">// 经过了3秒</span></span><br><span class="line">fmt.Println(<span class="string">"超时"</span>)</span><br><span class="line">quit &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">ch &lt;- i</span><br><span class="line"><span class="comment">// 等待1秒再读取</span></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从超时通道获取到信息，退出进程</span></span><br><span class="line">&lt;-quit</span><br><span class="line">fmt.Println(<span class="string">"程序结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="控制性能"><a href="#控制性能" class="headerlink" title="控制性能"></a>控制性能</h4><p>使用下面命令设置程序运行占用的cpu核数。（默认使用机器的最大核数）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序运行占用的cpu核数</span></span><br><span class="line">runtime.GOMAXPROCS(逻辑CPU数量)</span><br><span class="line"><span class="comment">// 查询机器的cpu核数</span></span><br><span class="line">runtime.NumCPU()</span><br></pre></td></tr></table></figure><p>逻辑CPU的数量：</p><ul><li>&lt;1：不修改任何数值。</li><li>=1：单核心执行。</li><li><blockquote><p>1：多核并发执行。</p></blockquote></li></ul><h3 id="五、reflect"><a href="#五、reflect" class="headerlink" title="五、reflect"></a>五、reflect</h3><p>程序在编译时变量被转换为内存地址，变量名不会被编译器写入到可执行部分，所以在运行程序时程序无法获取自身的信息。但是 <strong>反射</strong> 可以在程序运行期对程序本身进行访问和修改。</p><table><thead><tr><th>类型</th><th>作用</th></tr></thead><tbody><tr><td>reflect.ValueOf()</td><td>获取输入参数接口中的数据的值，如果为空则返回0 &lt;- 注意是0</td></tr><tr><td>reflect.TypeOf()</td><td>动态获取输入参数接口中的值的类型，如果为空则返回nil &lt;- 注意是nil</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 定义一个Enum类型</span></span><br><span class="line"><span class="keyword">type</span> Enum <span class="keyword">float32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name Enum = <span class="number">3.1415926</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeOf会返回目标数据的类型，比如int/float/struct/指针等</span></span><br><span class="line">reflectType := reflect.TypeOf(name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// valueOf返回目标数据的的值，比如上文的 3.1415926</span></span><br><span class="line">reflectValue := reflect.ValueOf(name)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"类型: "</span>, reflectType)</span><br><span class="line">fmt.Println(<span class="string">"类型的名称: "</span>, reflectType.Name())</span><br><span class="line">fmt.Println(<span class="string">"类型的种类: "</span>, reflectType.Kind())</span><br><span class="line">fmt.Println(<span class="string">"变量值: "</span>, reflectValue)</span><br><span class="line">fmt.Println(<span class="string">"变量值的种类: "</span>, reflectValue.Kind())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>变量类型是指针与指针指向的元素：需要使用Elem方法。</li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Field(i int) StructField</td><td>根据索引返回索引对应的结构体字段的信息，当值不是结构体或索引超界时发生宕机</td></tr><tr><td>NumField() int</td><td>返回结构体成员字段数量，当类型不是结构体或索引超界时发生宕机</td></tr><tr><td>FieldByName(name string) (StructField, bool)</td><td>根据给定字符串返回字符串对应的结构体字段的信息，没有找到时 bool 返回 false，当类型不是结构体或索引超界时发生宕机</td></tr><tr><td>FieldByIndex(index []int) StructField</td><td>多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息，没有找到时返回零值。当类型不是结构体或索引超界时发生宕机</td></tr><tr><td>FieldByNameFunc(match func(string) bool) (StructField,bool)</td><td>根据匹配函数匹配需要的字段，当值不是结构体或索引超界时发生宕机</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 声明一个空结构体</span></span><br><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建cat的实例</span></span><br><span class="line">ins := &amp;cat&#123;&#125;</span><br><span class="line"><span class="comment">// 获取结构体实例的反射类型对象</span></span><br><span class="line">typeOfCat := reflect.TypeOf(ins)</span><br><span class="line"><span class="comment">// 显示反射类型对象的名称和种类</span></span><br><span class="line">fmt.Printf(<span class="string">"name:'%v' kind:'%v'\n"</span>, typeOfCat.Name(), typeOfCat.Kind())</span><br><span class="line"><span class="comment">// 取类型的元素</span></span><br><span class="line">typeOfCat = typeOfCat.Elem()</span><br><span class="line"><span class="comment">// 显示反射类型对象的名称和种类</span></span><br><span class="line">fmt.Printf(<span class="string">"element name: '%v', element kind: '%v'\n"</span>, typeOfCat.Name(), typeOfCat.Kind())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 reflect.Type 的 Field() 方法会返回 StructField 结构，这个结构描述结构体的成员信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StructField <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span>          <span class="comment">// 字段名</span></span><br><span class="line">    PkgPath <span class="keyword">string</span>       <span class="comment">// 字段路径</span></span><br><span class="line">    Type      Type       <span class="comment">// 字段反射类型对象</span></span><br><span class="line">    Tag       StructTag  <span class="comment">// 字段的结构体标签</span></span><br><span class="line">    Offset    <span class="keyword">uintptr</span>    <span class="comment">// 字段在结构体中的相对偏移</span></span><br><span class="line">    Index     []<span class="keyword">int</span>      <span class="comment">// Type.FieldByIndex中的返回的索引值</span></span><br><span class="line">    Anonymous <span class="keyword">bool</span>       <span class="comment">// 是否为匿名字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 声明一个空结构体</span></span><br><span class="line">    <span class="keyword">type</span> cat <span class="keyword">struct</span> &#123;</span><br><span class="line">        Name <span class="keyword">string</span></span><br><span class="line">        <span class="comment">// 带有结构体tag的字段。tag：类似添加的注解，格式 `key1:"value1" key2:"value2"`</span></span><br><span class="line">        Type <span class="keyword">int</span> <span class="string">`json:"type" id:"100"`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建cat的实例</span></span><br><span class="line">    ins := cat&#123;Name: <span class="string">"mimi"</span>, Type: <span class="number">1</span>&#125;</span><br><span class="line">    <span class="comment">// 获取结构体实例的反射类型对象</span></span><br><span class="line">    typeOfCat := reflect.TypeOf(ins)</span><br><span class="line">    <span class="comment">// 遍历结构体所有成员</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; typeOfCat.NumField(); i++ &#123;</span><br><span class="line">        <span class="comment">// 获取每个成员的结构体字段类型</span></span><br><span class="line">        fieldType := typeOfCat.Field(i)</span><br><span class="line">        <span class="comment">// 输出成员名和tag</span></span><br><span class="line">        fmt.Printf(<span class="string">"name: %v  tag: '%v'\n"</span>, fieldType.Name, fieldType.Tag)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过字段名, 找到字段类型信息</span></span><br><span class="line">    <span class="keyword">if</span> catType, ok := typeOfCat.FieldByName(<span class="string">"Type"</span>); ok &#123;</span><br><span class="line">        <span class="comment">// 从tag中取出需要的tag</span></span><br><span class="line">        fmt.Println(catType.Tag.Get(<span class="string">"json"</span>), catType.Tag.Get(<span class="string">"id"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反射三大定律"><a href="#反射三大定律" class="headerlink" title="反射三大定律"></a>反射三大定律</h4><ul><li>定律一：反射可以将“接口类型变量”转换为“反射类型对象” ：普通变量 -&gt; 接口变量 -&gt; 反射对象：<br>•</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Type</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Value</span></span></span><br></pre></td></tr></table></figure><h5 id="1-反射可以将“接口类型变量”转换为“反射类型对象"><a href="#1-反射可以将“接口类型变量”转换为“反射类型对象" class="headerlink" title="1.反射可以将“接口类型变量”转换为“反射类型对象"></a>1.反射可以将“接口类型变量”转换为“反射类型对象</h5><p>普通变量 -&gt; 接口变量 -&gt; 反射对象：</p><ul><li>1.我们调用 reflect.TypeOf(name) 时，name被存储在一个空接口变量中,然后被传递过去；</li></ul><p><img src="/image/Golang03/Golang03_010.png" alt=""></p><ul><li>2.接着<strong>reflect.TypeOf</strong> 或者 <strong>ValueOf</strong> 对空接口变量转换为 <strong>reflect.Type</strong> 或 <strong>reflect.Value</strong>。打个断点看看，如下图所示：</li></ul><p><img src="/image/Golang03/Golang03_011.png" alt=""></p><h5 id="2-反射可以将“反射类型对象”转换为“接口类型变量”"><a href="#2-反射可以将“反射类型对象”转换为“接口类型变量”" class="headerlink" title="2.反射可以将“反射类型对象”转换为“接口类型变量”"></a>2.反射可以将“反射类型对象”转换为“接口类型变量”</h5><p>反射对象 -&gt; 接口变量：使用的是Value 的Interface函数，是把实际的值赋值给空接口变量，它的声明如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Interface</span><span class="params">()</span> <span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> x MyInt = <span class="number">7</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line"><span class="comment">// 通过 Interface 方法恢复其接口类型，然后再通过 接口断言获取值</span></span><br><span class="line">y := v.Interface().(MyInt)</span><br><span class="line">fmt.Printf(<span class="string">"类型：%T\n"</span>, y)</span><br><span class="line">fmt.Println(<span class="string">"值："</span>, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-要修改“反射类型对象”其值必须是“可写的”"><a href="#3-要修改“反射类型对象”其值必须是“可写的”" class="headerlink" title="3.要修改“反射类型对象”其值必须是“可写的”"></a>3.要修改“反射类型对象”其值必须是“可写的”</h5><ul><li>通过 CanSet 方法判断 reflect.Value 类型变量的“可写性”,看一下下面的例子：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 声明整型变量a并赋初值</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1024</span></span><br><span class="line"><span class="comment">// 获取变量a的反射值对象</span></span><br><span class="line">valueOfA := reflect.ValueOf(a)</span><br><span class="line">fmt.Println(<span class="string">"可写性:"</span>, valueOfA.CanSet())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可写性</strong>，其实就是 <strong>可以被寻址</strong> 。</p><h4 id="通过反射修改变量的值"><a href="#通过反射修改变量的值" class="headerlink" title="通过反射修改变量的值"></a>通过反射修改变量的值</h4><ul><li>1.获取元素的地址，获取其反射值对象</li><li>2.获取其反射值对象的元素，修改值</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 声明整型变量a并赋初值</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1024</span></span><br><span class="line"><span class="comment">// 获取变量a的反射值对象(a的地址)</span></span><br><span class="line">valueOfA := reflect.ValueOf(&amp;a)</span><br><span class="line"><span class="comment">// 取出a地址的元素(a的值)</span></span><br><span class="line">valueOfA = valueOfA.Elem()</span><br><span class="line"><span class="comment">// 修改a的值为1</span></span><br><span class="line">valueOfA.SetInt(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 打印a的值</span></span><br><span class="line">fmt.Println(valueOfA.Int())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果变量类型是结构体，需要考虑字段是否可以被导出。（首字符大写，小写会被隐蔽）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;</span><br><span class="line">LegCount <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取dog实例地址的反射值对象</span></span><br><span class="line">valueOfDog := reflect.ValueOf(&amp;dog&#123;&#125;)</span><br><span class="line"><span class="comment">// 取出dog实例地址的元素</span></span><br><span class="line">valueOfDog = valueOfDog.Elem()</span><br><span class="line"><span class="comment">// 获取LegCount字段的值</span></span><br><span class="line">vLegCount := valueOfDog.FieldByName(<span class="string">"LegCount"</span>)</span><br><span class="line"><span class="comment">// 设置LegCount的值</span></span><br><span class="line">vLegCount.SetInt(<span class="number">4</span>)</span><br><span class="line">fmt.Println(vLegCount.Int())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li>取元素、取地址及修改值的属性方法请参考下表：</li></ul><table><thead><tr><th>方法名</th><th>备 注</th></tr></thead><tbody><tr><td>Elem() Value</td><td>取值指向的元素值，类似于语言层*操作。当值类型不是指针或接口时发生宕 机，空指针时返回 nil 的 Value</td></tr><tr><td>Addr() Value</td><td>对可寻址的值返回其地址，类似于语言层&amp;操作。当值不可寻址时发生宕机</td></tr><tr><td>CanAddr() bool</td><td>表示值是否可寻址</td></tr><tr><td>CanSet() bool</td><td>返回值能否被修改。要求值可寻址且是导出的字段</td></tr><tr><td>Set(x Value)</td><td>将值设置为传入的反射值对象的值</td></tr></tbody></table><ul><li>值修改相关方法如下表所示：</li></ul><table><thead><tr><th>Set(x Value)</th><th>将值设置为传入的反射值对象的值</th></tr></thead><tbody><tr><td>Setlnt(x int64)</td><td>使用 int64 设置值。当值的类型不是 int、int8、int16、 int32、int64 时会发生宕机</td></tr><tr><td>SetUint(x uint64)</td><td>使用 uint64 设置值。当值的类型不是 uint、uint8、uint16、uint32、uint64 时会发生宕机</td></tr><tr><td>SetFloat(x float64)</td><td>使用 float64 设置值。当值的类型不是 float32、float64 时会发生宕机</td></tr><tr><td>SetBool(x bool)</td><td>使用 bool 设置值。当值的类型不是 bod 时会发生宕机</td></tr><tr><td>SetBytes(x []byte)</td><td>设置字节数组 []bytes值。当值的类型不是 []byte 时会发生宕机</td></tr><tr><td>SetString(x string)</td><td>设置字符串值。当值的类型不是 string 时会发生宕机</td></tr></tbody></table><h3 id="六、文件读写"><a href="#六、文件读写" class="headerlink" title="六、文件读写"></a>六、文件读写</h3><p>使用语法如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="keyword">string</span>, flag <span class="keyword">int</span>, perm FileMode)</span> <span class="params">(file *File, err error)</span></span></span><br></pre></td></tr></table></figure><ul><li>name :文件的文件名，如果不是在当前路径下需要加上具体路径</li><li>flag：文件的处理参数，表面上是int，实际上是枚举值。,如果要使用多个参数,需要用’|’连接<ul><li>O_RDONLY：只读模式打开文件；</li><li>O_WRONLY：只写模式打开文件；</li><li>O_RDWR：读写模式打开文件；</li><li>O_APPEND：写操作时将数据附加到文件尾部（追加）；</li><li>O_CREATE：如果不存在将创建一个新文件；</li><li>O_EXCL：和 O_CREATE 配合使用，文件必须不存在，否则返回一个错误；</li><li>O_SYNC：当进行一系列写操作时，每次都要等待上次的 I/O 操作完成再进行；</li><li>O_TRUNC：如果可能，在打开时清空文件。</li></ul></li><li>perm：文件读/写/执行权限，同unix，有四位。<ul><li>第一位：<ul><li>4 ： set uid，设置使文件在执行阶段具有文件所有者的权限.</li><li>2 ： set gid，目录被设置该位后, 任何用户在此目录下创建的文件都具有和该目录所属的组相同的组.</li><li>1 ： sticky bit，防删除位.</li></ul></li><li>第二位：文件的所有者拥有的权限，如果同时拥有多种权限，把数字累加<ul><li>4：读</li><li>2：写</li><li>1：执行</li></ul></li><li>第三位：文件属组成员拥有的权限，如果同时拥有多种权限，把数字累加<ul><li>4：读</li><li>2：写</li><li>1：执行</li></ul></li><li>第四位：其他用户拥有的权限，如果同时拥有多种权限，把数字累加<ul><li>4：读</li><li>2：写</li><li>1：执行</li></ul></li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个新文件，</span></span><br><span class="line">filePath := <span class="string">"golang.txt"</span></span><br><span class="line"><span class="comment">// 设置创建和可写</span></span><br><span class="line">file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"文件打开失败"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//及时关闭file句柄</span></span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"><span class="comment">//使用带缓存的 *Writer 写入文件，内容为 5 句 “Hello World”</span></span><br><span class="line">write := bufio.NewWriter(file)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">write.WriteString(<span class="string">"Hello World \n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Flush将缓存的文件真正写入到文件中</span></span><br><span class="line">write.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">filePath := <span class="string">"golang.txt"</span></span><br><span class="line"><span class="comment">// 设置读写权限和追加模式</span></span><br><span class="line">file, err := os.OpenFile(filePath, os.O_RDWR|os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"文件打开失败"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//及时关闭file句柄</span></span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"><span class="comment">//读原来文件的内容，并且显示在终端</span></span><br><span class="line">reader := bufio.NewReader(file)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">str, err := reader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Print(str)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写入文件时，使用带缓存的 *Writer</span></span><br><span class="line">write := bufio.NewWriter(file)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">write.WriteString(<span class="string">"Hello Golang \n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Flush将缓存的文件真正写入到文件中</span></span><br><span class="line">write.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="各种格式文件处理"><a href="#各种格式文件处理" class="headerlink" title="各种格式文件处理"></a>各种格式文件处理</h4><h5 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h5><p>JSON 文件内容一般是这样子：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"key1"</span>:<span class="string">"value1"</span>,<span class="attr">"key2"</span>:<span class="string">"value2"</span>,<span class="attr">"key3"</span>:[<span class="string">"value3"</span>,<span class="string">"value4"</span>,<span class="string">"value5"</span>]&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用内置的 encoding/json 标准库去处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Website <span class="keyword">struct</span> &#123;</span><br><span class="line">Name   <span class="keyword">string</span> <span class="string">`xml:"name,attr"`</span></span><br><span class="line">Url    <span class="keyword">string</span></span><br><span class="line">Course []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 1.写入文件</span></span><br><span class="line"><span class="comment">// 定义了写个文件内容</span></span><br><span class="line">infoWrite := []Website&#123;&#123;<span class="string">"Golang"</span>, <span class="string">"https://golang.org/"</span>, []<span class="keyword">string</span>&#123;<span class="string">"http://www.baidu.com/"</span>&#125;&#125;,</span><br><span class="line">&#123;<span class="string">"Java"</span>, <span class="string">"https://www.java.com/zh_CN/"</span>, []<span class="keyword">string</span>&#123;<span class="string">"http://www.google.com/java/"</span>&#125;&#125;&#125;</span><br><span class="line"><span class="comment">// 创建文件</span></span><br><span class="line">filePtrWrite, err := os.Create(<span class="string">"info.json"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"文件创建失败"</span>, err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建Json编码器</span></span><br><span class="line">encoder := json.NewEncoder(filePtrWrite)</span><br><span class="line">err = encoder.Encode(infoWrite)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"编码错误"</span>, err.Error())</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"编码成功"</span>)</span><br><span class="line">&#125;</span><br><span class="line">filePtrWrite.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.读取文件</span></span><br><span class="line">filePtrRead, err := os.Open(<span class="string">"./info.json"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"文件打开失败 [Err:%s]"</span>, err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> filePtrRead.Close()</span><br><span class="line"><span class="keyword">var</span> infoRead []Website</span><br><span class="line"><span class="comment">// 创建json解码器</span></span><br><span class="line">decoder := json.NewDecoder(filePtrRead)</span><br><span class="line">err = decoder.Decode(&amp;infoRead)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"解码失败"</span>, err.Error())</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"解码成功"</span>)</span><br><span class="line">fmt.Println(infoRead)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h5><p>对于XML，我们可以使用 encoidng/xml 包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/xml"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Website <span class="keyword">struct</span> &#123;</span><br><span class="line">Name   <span class="keyword">string</span> <span class="string">`xml:"name,attr"`</span></span><br><span class="line">Url    <span class="keyword">string</span></span><br><span class="line">Course []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 1.写入文件</span></span><br><span class="line"><span class="comment">// 定义写入信息</span></span><br><span class="line">infoWrite := Website&#123;<span class="string">"Golang"</span>, <span class="string">"https://golang.org/"</span>, []<span class="keyword">string</span>&#123;<span class="string">"http://www.baidu.com/"</span>&#125;&#125;</span><br><span class="line">f1, err := os.Create(<span class="string">"./info.xml"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"文件创建失败"</span>, err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 序列化到文件中</span></span><br><span class="line">encoder := xml.NewEncoder(f1)</span><br><span class="line">err = encoder.Encode(infoWrite)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"编码错误："</span>, err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"编码成功"</span>)</span><br><span class="line">&#125;</span><br><span class="line">f1.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.读取文件</span></span><br><span class="line"><span class="comment">// 打开xml文件</span></span><br><span class="line">f2, err := os.Open(<span class="string">"./info.xml"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"文件打开失败：%v"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f2.Close()</span><br><span class="line">infoRead := Website&#123;&#125;</span><br><span class="line"><span class="comment">//创建 xml 解码器</span></span><br><span class="line">decoder := xml.NewDecoder(f2)</span><br><span class="line">err = decoder.Decode(&amp;infoRead)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"解码失败：%v"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"解码成功"</span>)</span><br><span class="line">fmt.Println(infoRead)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Gob"><a href="#Gob" class="headerlink" title="Gob"></a>Gob</h5><p>Gob（即 Go binary 的缩写），Go语言自己以二进制形式序列化和反序列化程序数据的格式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/gob"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 1.写入文件</span></span><br><span class="line">info := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"name"</span>:    <span class="string">"Golang"</span>,</span><br><span class="line"><span class="string">"website"</span>: <span class="string">"https://golang.org/"</span>,</span><br><span class="line">&#125;</span><br><span class="line">name := <span class="string">"demo.gob"</span></span><br><span class="line">File1, _ := os.OpenFile(name, os.O_RDWR|os.O_CREATE, <span class="number">0777</span>)</span><br><span class="line">enc := gob.NewEncoder(File1)</span><br><span class="line"><span class="keyword">if</span> err := enc.Encode(info); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">File1.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.读取文件</span></span><br><span class="line"><span class="keyword">var</span> M <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">File2, _ := os.Open(<span class="string">"demo.gob"</span>)</span><br><span class="line">D := gob.NewDecoder(File2)</span><br><span class="line">D.Decode(&amp;M)</span><br><span class="line">fmt.Println(M)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h5><p>关于其他二进制文件，可以使用 encoding/binary处理。</p><p>语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Write</span><span class="params">(w io.Writer, order ByteOrder, data <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Read</span><span class="params">(r io.Reader, order ByteOrder, data <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><ul><li>w:可以读出字节流的数据源</li><li>r:可以写入字节流的数据源</li><li>order:指定写入/读取数据的字节序<ul><li>binary.LittleEndian:小端模式,按照从低地址到高地址的顺序,存放据的低位字节到高位字节</li><li>binary.BigEndian:大端模式,按照从低地址到高地址的顺序,存放数据的高位字节到低位字节</li></ul></li><li>data:必须是定长值、定长值的切片、定长值的指针</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/binary"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Website <span class="keyword">struct</span> &#123;</span><br><span class="line">Url <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readNextBytes</span><span class="params">(file *os.File, number <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">bytes := <span class="built_in">make</span>([]<span class="keyword">byte</span>, number)</span><br><span class="line">_, err := file.Read(bytes)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"解码失败"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bytes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 1.写入文件</span></span><br><span class="line">file1, err := os.Create(<span class="string">"output.bin"</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">info := Website&#123;</span><br><span class="line"><span class="keyword">int32</span>(i),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"文件创建失败 "</span>, err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> binBuf bytes.Buffer</span><br><span class="line">binary.Write(&amp;binBuf, binary.LittleEndian, info)</span><br><span class="line">b := binBuf.Bytes()</span><br><span class="line">_, err = file1.Write(b)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"编码失败"</span>, err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"编码成功"</span>)</span><br><span class="line">file1.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.读取文件</span></span><br><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line">file2, err := os.Open(<span class="string">"output.bin"</span>)</span><br><span class="line"><span class="keyword">defer</span> file2.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"文件打开失败"</span>, err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">m := Website&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">data := readNextBytes(file2, <span class="number">4</span>)</span><br><span class="line">buffer := bytes.NewBuffer(data)</span><br><span class="line">err = binary.Read(buffer, binary.LittleEndian, &amp;m)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"二进制文件读取失败"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"第"</span>, i, <span class="string">"个值为："</span>, m)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"archive/zip"</span></span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 1.压缩文件</span></span><br><span class="line"><span class="comment">// 创建一个缓冲区用来保存压缩文件内容</span></span><br><span class="line">buf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line"><span class="comment">// 创建一个压缩文档</span></span><br><span class="line">w := zip.NewWriter(buf)</span><br><span class="line"><span class="comment">// 将文件加入压缩文档</span></span><br><span class="line"><span class="keyword">var</span> files = []<span class="keyword">struct</span> &#123;</span><br><span class="line">Name, Body <span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;<span class="string">"Golang.txt"</span>, <span class="string">"https://golang.org/"</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">f, err := w.Create(file.Name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">_, err = f.Write([]<span class="keyword">byte</span>(file.Body))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭压缩文档</span></span><br><span class="line">err := w.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将压缩文档内容写入文件</span></span><br><span class="line">f, err := os.OpenFile(<span class="string">"file.zip"</span>, os.O_CREATE|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">buf.WriteTo(f)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.解压文件</span></span><br><span class="line"><span class="comment">// 打开一个zip格式文件</span></span><br><span class="line">r, err := zip.OpenReader(<span class="string">"file.zip"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> r.Close()</span><br><span class="line"><span class="comment">// 迭代压缩文件中的文件，打印出文件中的内容</span></span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> r.File &#123;</span><br><span class="line">fmt.Printf(<span class="string">"文件名: %s\n"</span>, f.Name)</span><br><span class="line">rc, err := f.Open()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建文件</span></span><br><span class="line">w, err := os.Create(f.Name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line">_, err = io.CopyN(w, rc, <span class="keyword">int64</span>(f.UncompressedSize64))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">w.Close()</span><br><span class="line">rc.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h5><ul><li>压缩的步骤如下：<ul><li>1.创建一个文件 x.tar，然后向 x.tar 写入 tar 头部信息；</li><li>2.打开要被 tar 的文件，向 x.tar 写入头部信息，然后向 x.tar 写入文件信息；</li><li>3.当有多个文件需要被 tar 时，重复第二步直到所有文件都被写入到 x.tar 中；</li><li>4.关闭 x.tar，完成打包。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"archive/tar"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f, err := os.Create(<span class="string">"./output.tar"</span>) <span class="comment">//创建一个 tar 文件</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line">tw := tar.NewWriter(f)</span><br><span class="line"><span class="keyword">defer</span> tw.Close()</span><br><span class="line">fileinfo, err := os.Stat(<span class="string">"Golang.txt"</span>) <span class="comment">//获取文件相关信息</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">hdr, err := tar.FileInfoHeader(fileinfo, <span class="string">""</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">err = tw.WriteHeader(hdr) <span class="comment">//写入头文件信息</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">f1, err := os.Open(<span class="string">"Golang.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">m, err := io.Copy(tw, f1) <span class="comment">//将Golang.txt文件中的信息写入压缩包中</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>解压的步骤如下：<ul><li>1.打开文件 x.tar，然后从这个 tar 头部中循环读取存储在这个归档文件内的文件头信息；</li><li>2.从这个文件头里读取文件名，以这个文件名创建文件，然后向这个文件里写入数据即可；</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"archive/tar"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f, err := os.Open(<span class="string">"output.tar"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"文件打开失败"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line">r := tar.NewReader(f)</span><br><span class="line"><span class="keyword">for</span> hdr, err := r.Next(); err != io.EOF; hdr, err = r.Next() &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fileinfo := hdr.FileInfo()</span><br><span class="line">fmt.Println(fileinfo.Name())</span><br><span class="line">f, err := os.Create(fileinfo.Name()+<span class="string">"2"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line">_, err = io.Copy(f, r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="各种格式的速度以及大小对比"><a href="#各种格式的速度以及大小对比" class="headerlink" title="各种格式的速度以及大小对比"></a>各种格式的速度以及大小对比</h4><table><thead><tr><th>后缀</th><th>读取</th><th>写入</th><th>大小(KiB)</th><th>读/写LOC</th><th>格式</th></tr></thead><tbody><tr><td>.gob</td><td>0.3</td><td>0.2</td><td>7948</td><td>21 + 11 =32</td><td>Go二进制</td></tr><tr><td>.gob.gz</td><td>0.5</td><td>1.5</td><td>2589</td><td></td><td></td></tr><tr><td>json</td><td>4.5</td><td>2.2</td><td>16283</td><td>32+17 = 49</td><td>JSON</td></tr><tr><td>.json.gz</td><td>4.5</td><td>3.4</td><td>2678</td><td></td><td></td></tr><tr><td>.xml</td><td>6.7</td><td>1.2</td><td>18917</td><td>45 + 30 = 75</td><td>XML</td></tr><tr><td>.xml.gz</td><td>6.9</td><td>2.7</td><td>2730</td><td></td><td></td></tr><tr><td>.txt</td><td>1.9</td><td>1.0</td><td>12375</td><td>86 + 53 = 139</td><td>纯文本（UTF-8）</td></tr><tr><td>.txt.gz</td><td>2.2</td><td>2.2</td><td>2514</td><td></td><td></td></tr><tr><td>.bin</td><td>1.7</td><td>3.5</td><td>7250</td><td>128 + 87 = 215</td><td>自定义二进制</td></tr><tr><td>.bin.gz</td><td>1.6</td><td>2.6</td><td>2400</td><td></td></tr></tbody></table><p>More info: <a href="http://c.biancheng.net/golang/" target="_blank" rel="noopener">Golang</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　本文章主要介绍 Golang 的基本语法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://lightalight.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang（二）Go语言的基本语法(上)</title>
    <link href="https://lightalight.github.io/2021/03/15/Golang02/"/>
    <id>https://lightalight.github.io/2021/03/15/Golang02/</id>
    <published>2021-03-15T14:23:32.000Z</published>
    <updated>2022-07-03T06:55:18.921Z</updated>
    
    <content type="html"><![CDATA[<p>　　本文章主要介绍 Golang 的基本语法。</p><a id="more"></a><h2 id="Quick-Guide"><a href="#Quick-Guide" class="headerlink" title="Quick Guide"></a>Quick Guide</h2><h3 id="一、变量"><a href="#一、变量" class="headerlink" title="一、变量"></a>一、变量</h3><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><ul><li>基本<ul><li>布尔型</li><li>数值<ul><li>整型</li><li>浮点</li><li>复数</li></ul></li><li>字符串</li></ul></li><li>派生<ul><li>指针</li><li>数值</li><li>结构</li><li>管道</li><li>函数</li><li>切片</li></ul></li></ul><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准格式</span></span><br><span class="line"><span class="keyword">var</span> 变量名(命名规则遵循骆驼命名法,例如:aBit) 变量类型</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量格式</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a <span class="keyword">int</span></span><br><span class="line">    b <span class="keyword">string</span></span><br><span class="line">    c []<span class="keyword">float32</span></span><br><span class="line">    d <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">    <span class="title">e</span> <span class="title">struct</span></span> &#123;</span><br><span class="line">        x <span class="keyword">int</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c++</span></span><br><span class="line"><span class="keyword">int</span>* a,b; <span class="comment">//a 是指针而 b 不是</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="keyword">var</span> a, b *<span class="keyword">int</span> <span class="comment">//a b 都是指针</span></span><br></pre></td></tr></table></figure><h5 id="简短格式"><a href="#简短格式" class="headerlink" title="简短格式"></a>简短格式</h5><ul><li>定义变量,同时显式初始化</li><li>不能提供数据类型</li><li>只能用在函数内部</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">名字 := 表达式</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main    <span class="comment">// 声明 main 包</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span>       <span class="comment">// 导入 fmt 包，打印字符串是需要用到</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   <span class="comment">// 声明 main 主函数</span></span><br><span class="line">i, j := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    fmt.Println(i,j) <span class="comment">// 打印 Hello World!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h5><p>匿名变量是一个下画线”_”(空白标识符),仅用于声明,不能存储值.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main    <span class="comment">// 声明 main 包</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span>       <span class="comment">// 导入 fmt 包，打印字符串是需要用到</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetData</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>, <span class="number">200</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a, _ := GetData()</span><br><span class="line">    _, b := GetData()</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="变量同时赋值"><a href="#变量同时赋值" class="headerlink" title="变量同时赋值"></a>变量同时赋值</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main    <span class="comment">// 声明 main 包</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span>       <span class="comment">// 导入 fmt 包，打印字符串是需要用到</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   <span class="comment">// 声明 main 主函数</span></span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">200</span></span><br><span class="line">    b, a = a, b</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h4><ul><li>函数内定义的变量称为局部变量</li><li>函数外定义的变量称为全局变量</li><li>函数定义中的变量称为形式参数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//全局变量 a</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    num := a + b</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//局部变量 a 和 b</span></span><br><span class="line">    c,d := <span class="number">3</span>,<span class="number">4</span></span><br><span class="line">    f := sum(c, d)</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h4><ul><li>Go语言不存在隐式类型转换,所以类型转换都必须显式声明</li><li><em>只有相同底层类型的变量之间才可以进行转换（例如 int16 转换成 int32）.不同将引起编译错误（例如 bool 转换为 int）</em></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型 B 的值 = 类型 B(类型 A 的值)</span></span><br><span class="line">valueOfTypeB = typeB(valueOfTypeA)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 初始化一个32位整型值</span></span><br><span class="line">        <span class="keyword">var</span> a <span class="keyword">int32</span> = <span class="number">1008600</span></span><br><span class="line">        <span class="comment">// 输出变量的十六进制形式和十进制值</span></span><br><span class="line">        fmt.Printf(<span class="string">"int32: 0x%x %d\n"</span>, a, a)</span><br><span class="line">        <span class="comment">// 将a变量数值转换为十六进制, 发生数值截断</span></span><br><span class="line">        b := <span class="keyword">int16</span>(a)</span><br><span class="line">        <span class="comment">// 输出变量的十六进制形式和十进制值</span></span><br><span class="line">        fmt.Printf(<span class="string">"int16: 0x%x %d\n"</span>, b, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong><strong>字符串和数值类型的相互转换</strong></strong></p><p>  Go中的 strconv 包( Atoi()、Itia()、parse 系列函数、format 系列函数、append 系列函数等)为我们提供了字符串和基本数据类型之间的转换功能.</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str1 := <span class="string">"10010"</span></span><br><span class="line">str2 := <span class="string">"t"</span></span><br><span class="line">    <span class="comment">// 字符串转换数字</span></span><br><span class="line">num1, err := strconv.Atoi(str1)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%v 转换失败！"</span>, str1)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"type:%T value:%#v\n"</span>, num1, num1)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 字符串转换数字</span></span><br><span class="line">num2, err := strconv.Atoi(str2)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%v 转换失败！"</span>, str2)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"type:%T value:%#v\n"</span>, num2, num2)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 字符串转换布尔型</span></span><br><span class="line">boo1, err := strconv.ParseBool(str1)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"str1: %v\n"</span>, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(boo1)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 字符串转换布尔型</span></span><br><span class="line">boo2, err := strconv.ParseBool(str2)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"str2: %v\n"</span>, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(boo2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="特殊的变量"><a href="#特殊的变量" class="headerlink" title="特殊的变量"></a>特殊的变量</h4><p>一个变量存储一个值的内存地址</p><ul><li>声明指针变量</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> var_name var_type = var_value</span><br><span class="line"><span class="keyword">var</span> ptr *var_type</span><br></pre></td></tr></table></figure><ul><li>为指针变量赋值变量的存储地址</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr := &amp;var_name</span><br></pre></td></tr></table></figure><ul><li>访问指针变量中指向地址的值</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*ptr</span><br></pre></td></tr></table></figure><ul><li><em>当一个指针被定义后没有分配到任何变量时,它的值为 nil</em></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">int</span>= <span class="number">10</span>   <span class="comment">/* 声明实际变量 */</span></span><br><span class="line">   <span class="keyword">var</span> ak *<span class="keyword">int</span>  <span class="comment">/* 1.声明指针变量 */</span></span><br><span class="line"></span><br><span class="line">   ak = &amp;a  <span class="comment">/* 2.为指针变量赋值变量的存储地址 */</span></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">"a 变量的地址是: %x\n"</span>, &amp;a  )</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 指针变量的存储地址 */</span></span><br><span class="line">   fmt.Printf(<span class="string">"ak 变量储存的指针地址: %x\n"</span>, ak )</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 3.使用指针访问值 */</span></span><br><span class="line">   fmt.Printf(<span class="string">"*ak 变量的值: %d\n"</span>, *ak )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>Go语言中的常量使用关键字 const 定义，用于存储不会改变的数据，常量是在编译时被创建的，即使定义在函数内部也是如此，并且只能是布尔型、数字型（整数型、浮点型和复数）和字符串型。由于编译时的限制，定义常量的表达式必须为能被编译器求值的常量表达式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pi = <span class="number">3.14159</span> <span class="comment">// 相当于 math.Pi 的近似值</span></span><br></pre></td></tr></table></figure><h6 id="iota-常量生成器"><a href="#iota-常量生成器" class="headerlink" title="iota 常量生成器"></a>iota 常量生成器</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Weekday <span class="keyword">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Sunday Weekday = <span class="literal">iota</span></span><br><span class="line">    Monday</span><br><span class="line">    Tuesday</span><br><span class="line">    Wednesday</span><br><span class="line">    Thursday</span><br><span class="line">    Friday</span><br><span class="line">    Saturday</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h6 id="无类型常量"><a href="#无类型常量" class="headerlink" title="无类型常量"></a>无类型常量</h6><ul><li>常量并没有一个明确的基础类型</li><li>编译器为这些没有明确的基础类型的数字常量提供比基础类型更高精度的算术运算</li></ul><h4 id="变量的生命周期"><a href="#变量的生命周期" class="headerlink" title="变量的生命周期"></a>变量的生命周期</h4><p>变量的生命周期指的是在程序运行期间变量有效存在的时间间隔。</p><ul><li>函数内定义的变量称为局部变量:从声明语句直到该变量不再被引用为止</li><li>函数外定义的变量称为全局变量:程序的运行周期一致</li><li>函数定义中的变量称为形式参数:函数被调用的时候创建</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">var</span> num <span class="keyword">int</span> <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    num = <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> t := <span class="number">0</span>; t &lt; num; t += <span class="number">1</span> &#123;</span><br><span class="line">x := <span class="keyword">int</span>(t) <span class="comment">// t 形式参数 x 局部变量</span></span><br><span class="line">fmt.Printf(<span class="string">"x: %d\n"</span>, x)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TypeAlias = Type</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将NewInt定义为int类型</span></span><br><span class="line"><span class="keyword">type</span> NewInt <span class="keyword">int</span></span><br><span class="line"><span class="comment">// 将int取一个别名叫IntAlias</span></span><br><span class="line"><span class="keyword">type</span> IntAlias = <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义商标结构</span></span><br><span class="line"><span class="keyword">type</span> Brand <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为Brand定义一个别名FakeBrand</span></span><br><span class="line"><span class="keyword">type</span> FakeBrand = Brand</span><br></pre></td></tr></table></figure><ul><li>TypeAlias 只是 Type 的别名，本质上 TypeAlias 与 Type 是同一个类型，</li></ul><h4 id="关键字与标识符"><a href="#关键字与标识符" class="headerlink" title="关键字与标识符"></a>关键字与标识符</h4><h5 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h5><p>关键字即是被Go语言赋予了特殊含义的单词，也可以称为保留字。</p><table><thead><tr><th>break</th><th>default</th><th>func</th><th>interface</th><th>select</th></tr></thead><tbody><tr><td>case</td><td>defer</td><td>go</td><td>map</td><td>struct</td></tr><tr><td>chan</td><td>else</td><td>goto</td><td>package</td><td>switch</td></tr><tr><td>const</td><td>fallthrough</td><td>if</td><td>range</td><td>type</td></tr><tr><td>continue</td><td>for</td><td>import</td><td>return</td><td>var</td></tr></tbody></table><h5 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h5><p>标识符是指Go语言对各种变量、方法、函数等命名时使用的字符序列，标识符由若干个字母、下划线<code>_</code><br>、和数字组成，且第一个字符必须是字母。通俗的讲就是凡可以自己定义的名称都可以叫做标识符。</p><ul><li>由 26 个英文字母、0~9、<code>_</code>组成；</li><li>不能以数字开头，例如 var 1num int 是错误的；</li><li>Go语言中严格区分大小写；</li><li>标识符不能包含空格；</li><li>不能以系统保留关键字作为标识符，比如 break，if 等等。</li></ul><h3 id="二、注释"><a href="#二、注释" class="headerlink" title="二、注释"></a>二、注释</h3><p><strong>注释的定义及使用</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一行注释</span></span><br><span class="line"><span class="comment">第二行注释</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="三、语句"><a href="#三、语句" class="headerlink" title="三、语句"></a>三、语句</h3><h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><h5 id="if"><a href="#if" class="headerlink" title="if"></a>if</h5><p>语法如下:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式 &#123;</span><br><span class="line">   <span class="comment">/* 在布尔表达式为 true 时执行 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> 布尔表达式 &#123;</span><br><span class="line">   <span class="comment">/* 在布尔表达式为 true 时执行 */</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="comment">/* 在布尔表达式为 false 时执行 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> 布尔表达式<span class="number">1</span> &#123;</span><br><span class="line">   <span class="comment">/* 在布尔表达式1为 true 时执行 */</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> 布尔表达式<span class="number">2</span>&#123;</span><br><span class="line">   <span class="comment">/* 在布尔表达式2为 true 时执行 */</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="comment">/* 在布尔表达式1 2都为 false 时执行 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"在布尔表达式为 true 时执行\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="literal">false</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"在布尔表达式为 true 时执行\n"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"在布尔表达式为 false 时执行\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="literal">false</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"在布尔表达式1为 true 时执行\n"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="literal">false</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"在布尔表达式2为 true 时执行\n"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"在布尔表达式1和2都为 false 时执行\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>关键字if和左边的大括号{必须同一行,关键字else必须和右边的大括号}在同一行,这两条规则都是被编译器强制规定的。</em></strong></p><h5 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h5><p>switch 用于基于不同条件执行不同动作，每一个 case 最后自带 break 语句,匹配成功后就不会执行其他 case,如果需要执行后面的 case,可以使用 fallthrough.</p><p>语法如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> <span class="keyword">var</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> val1:</span><br><span class="line">    <span class="comment">/* var 为 val1 时执行 */</span></span><br><span class="line">    <span class="keyword">case</span> val2:</span><br><span class="line">    <span class="comment">/* var 为 val2 时执行 */</span></span><br><span class="line">    <span class="keyword">case</span> val3,val4,val5:</span><br><span class="line">    <span class="comment">/* var 为 val3或val4或val5 时执行 */</span></span><br><span class="line">    <span class="comment">/* 你可以定义任意数量的 case */</span></span><br><span class="line">    <span class="keyword">default</span>:<span class="comment">//可选</span></span><br><span class="line">    <span class="comment">/* var 都不满足上面的值执行 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> 布尔表达式<span class="number">1</span>:</span><br><span class="line">    <span class="comment">/* 在布尔表达式1为 true 时执行 */</span></span><br><span class="line">    <span class="keyword">case</span> 布尔表达式<span class="number">2</span>:</span><br><span class="line">    <span class="comment">/* 在布尔表达式2为 true 时执行 */</span></span><br><span class="line">    <span class="keyword">case</span> 布尔表达式<span class="number">3</span>,布尔表达式<span class="number">4</span>,布尔表达式<span class="number">5</span>:</span><br><span class="line">    <span class="comment">/* 在布尔表达式3或者4或者5为 true 时执行 */</span></span><br><span class="line">    <span class="comment">/* 你可以定义任意数量的 case */</span></span><br><span class="line">    <span class="keyword">default</span>:<span class="comment">//可选</span></span><br><span class="line">    <span class="comment">/* var 都不满足上面的条件执行 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><h5 id="for"><a href="#for" class="headerlink" title="for"></a>for</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 控制变量赋初值; 循环控制条件; 控制变量增量或减量 &#123; </span><br><span class="line">   <span class="comment">/* 循环控制条件为 true 时执行 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">   <span class="comment">/* 无限循环执行 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类似while</span></span><br><span class="line"><span class="keyword">for</span> 循环控制条件 &#123; </span><br><span class="line">   <span class="comment">/* 循环控制条件为 true 时执行 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> inedex,value:= <span class="keyword">range</span> (字符串/数组/切片)&#123; </span><br><span class="line">   <span class="comment">/* 对字符串、数组、切片等进行迭代输出元素 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">sum += i</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(sum)</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">10</span>; j &lt;= <span class="number">0</span>; j-- &#123;</span><br><span class="line">sum += j</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(sum)</span><br><span class="line"><span class="keyword">for</span> sum &lt;= <span class="number">10</span> &#123;</span><br><span class="line">sum += sum</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(sum)</span><br><span class="line"><span class="keyword">for</span> sum &lt;= <span class="number">10</span> &#123;</span><br><span class="line">sum += sum</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(sum)</span><br><span class="line"><span class="comment">// for &#123;</span></span><br><span class="line"><span class="comment">// sum++ // 无限循环下去</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// fmt.Println(sum) // 无法输出</span></span><br><span class="line">strings := []<span class="keyword">string</span>&#123;<span class="string">"google"</span>, <span class="string">"alibaba"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, s := <span class="keyword">range</span> strings &#123;</span><br><span class="line">fmt.Println(i, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">numbers := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, x := <span class="keyword">range</span> numbers &#123;</span><br><span class="line">fmt.Printf(<span class="string">"第 %d 位的值 = %d\n"</span>, i, x)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h4><p>可以控制语句的执行过程.</p><ul><li>break:用于中断当前 for 循环或跳出 switch 语句</li><li>continue:跳过当前循环剩余的语句,进行下一轮循环</li><li>goto:将跳转到被标记的语句</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line"><span class="keyword">if</span> <span class="number">1</span> == <span class="number">1</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"this is break."</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line"><span class="keyword">if</span> <span class="number">1</span> == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">fmt.Println(<span class="string">"this is skip statement."</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">LOOP:</span><br><span class="line"><span class="keyword">for</span> i &lt;= <span class="number">10</span> &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">5</span> &#123;</span><br><span class="line"><span class="comment">// 跳过迭代</span></span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">goto</span> LOOP</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"i的值为 : %d\n"</span>, i)</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、函数"><a href="#四、函数" class="headerlink" title="四、函数"></a>四、函数</h3><h4 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h4><ul><li><p>函数声明:包括函数名、形式参数列表、返回值列表（可省略）以及函数体,语法如下:</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(形式参数列表)</span><span class="params">(返回值列表)</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><pre><code>- 形式参数列表:函数的参数名以及类型,这些参数作为局部变量,其值由参数调用者提供- 返回值列表:函数返回值的变量名以及类型,如果函数返回一个无名变量或者没有返回值,则返回值列表的括号是可以省略的</code></pre><ul><li><p>调用函数</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回值变量列表 = 函数名(参数列表)</span><br></pre></td></tr></table></figure></li></ul><pre><code>- 函数名：需要调用的函数名。- 参数列表：参数变量以逗号分隔，尾部无须以分号结尾。- 返回值变量列表：多个返回值使用逗号分隔。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> x + y &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="params">(z <span class="keyword">int</span>)</span></span> &#123; z = x - y; <span class="keyword">return</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zero</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span></span>    &#123; fmt.Printf(<span class="string">"0"</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zero</span><span class="params">(args ...<span class="keyword">int</span>)</span></span>    &#123; fmt.Printf(<span class="string">"0"</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, add(<span class="number">2</span>, <span class="number">1</span>)) <span class="comment">// 不带有变量名的返回值</span></span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, sub(<span class="number">2</span>, <span class="number">1</span>)) <span class="comment">// 带有变量名的返回值</span></span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, zero)      <span class="comment">// 没有返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><ul><li><p>声明 语法如下:</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(参数列表)</span><span class="params">(返回参数列表)</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br><span class="line">调用</span><br></pre></td></tr></table></figure></li></ul><pre><code>- 在定义时调用匿名函数- 作为回调函数:把函数作为值保存到变量中,然后调用函数变量<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在定义时调用匿名函数,传递参数为 10086</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(phone <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"hello"</span>, phone)</span><br><span class="line">    &#125;(<span class="number">10086</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匿名将匿名函数体保存到f()中</span></span><br><span class="line">    f := <span class="function"><span class="keyword">func</span><span class="params">(phone <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"hello"</span>, phone)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用f()调用</span></span><br><span class="line">    f(<span class="number">10086</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h5 id="引用了外部变量的匿名函数–闭包"><a href="#引用了外部变量的匿名函数–闭包" class="headerlink" title="引用了外部变量的匿名函数–闭包"></a>引用了外部变量的匿名函数–闭包</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备一个字符串</span></span><br><span class="line">  str := <span class="string">"hello world"</span></span><br><span class="line">  <span class="comment">// 创建一个匿名函数</span></span><br><span class="line">  foo := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匿名函数中访问str</span></span><br><span class="line">    str = <span class="string">"hello dude"</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调用匿名函数</span></span><br><span class="line">  foo()</span><br><span class="line">  fmt.Printf(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>一种作用 于特定类型变量 的函数 。这种特定类型变量叫做接收器（ Receiver ） 。<br>如果将特定类型理解为结构体或“类”时，接收器的概念就类似于其他语言中的 this 或 者 self。<br>在 Go 语言中，接收器的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(variable_name variable_data_type)</span> <span class="title">function_name</span><span class="params">()</span> [<span class="title">return_type</span>]</span>&#123;</span><br><span class="line">    <span class="comment">/* 函数体*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义结构体 */</span></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">  radius <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该 method 属于 Circle 类型对象中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span> <span class="title">getArea</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">  <span class="comment">//c.radius 即为 Circle 类型对象中的属性</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">3.14</span> * c.radius * c.radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> c1 Circle</span><br><span class="line">  c1.radius = <span class="number">10.00</span></span><br><span class="line">  fmt.Println(<span class="string">"圆的面积 = "</span>, c1.getArea())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">(args ...variable_data_type)</span> [<span class="title">return_type</span>]</span>&#123;</span><br><span class="line">    <span class="comment">/* 函数体*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myArgs</span><span class="params">(args ...<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> _, arg := <span class="keyword">range</span> args &#123;</span><br><span class="line">    fmt.Println(arg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  myArgs(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="延迟执行语句–defer"><a href="#延迟执行语句–defer" class="headerlink" title="延迟执行语句–defer"></a>延迟执行语句–defer</h4><p>将其后面跟随的语句进行延迟处理,在 defer 归属的函数即将返回时,将延迟处理的语句按 defer 的逆序执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"defer begin"</span>)</span><br><span class="line">  <span class="comment">// 将defer放入延迟调用栈</span></span><br><span class="line">  <span class="keyword">defer</span> fmt.Println(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">defer</span> fmt.Println(<span class="number">2</span>)</span><br><span class="line">  <span class="comment">// 最后一个放入, 位于栈顶, 最先调用</span></span><br><span class="line">  <span class="keyword">defer</span> fmt.Println(<span class="number">3</span>)</span><br><span class="line">  fmt.Println(<span class="string">"defer end"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>More info: <a href="http://c.biancheng.net/golang/" target="_blank" rel="noopener">Golang</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　本文章主要介绍 Golang 的基本语法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://lightalight.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang（一）Golang的基本概念</title>
    <link href="https://lightalight.github.io/2021/02/15/Golang01/"/>
    <id>https://lightalight.github.io/2021/02/15/Golang01/</id>
    <published>2021-02-15T14:23:32.000Z</published>
    <updated>2022-07-03T06:54:00.614Z</updated>
    
    <content type="html"><![CDATA[<p>　　Go语言（或 Golang）起源于 2007 年，并在 2009 年正式对外发布。Go 是 Google的 Robert Griesemer，Rob Pike 及 Ken Thompson 开发的一种静态强类型、编译型语言。它的主要目标是“兼具<a href="http://c.biancheng.net/python/" target="_blank" rel="noopener">Python</a>等动态语言的开发速度和 C/<a href="http://c.biancheng.net/cplus/" target="_blank" rel="noopener">C++</a>等编译型语言的性能与安全性”。<br>　　本文章主要介绍 Golang 的特点和部署使用。</p><a id="more"></a><h2 id="Quick-Guide"><a href="#Quick-Guide" class="headerlink" title="Quick Guide"></a>Quick Guide</h2><h3 id="一、特点"><a href="#一、特点" class="headerlink" title="一、特点"></a>一、特点</h3><ul><li>类C语言：相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等思想，还有编译后机器码的运行效率以及和现有操作系统的无缝适配。</li><li>不损失应用程序性能的情况下降低代码的复杂性，具有“部署简单、并发性好、语言设计良好、执行性能好”等优势</li><li>强大的网络编程和并发编程支持</li><li>没有类和继承的概念，通过接口（interface）的概念来实现多态性</li></ul><h3 id="二、优势"><a href="#二、优势" class="headerlink" title="二、优势"></a>二、优势</h3><ul><li><a href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="noopener">编程热度</a></li><li>开发和运行效率兼得:Go拥有接近C的运行效率和接近PHP的开发效率</li></ul><p><img src="/image/Golang01/Golang01_001.png" alt=""></p><ul><li>简洁强大的并发:</li></ul><p><img src="/image/Golang01/Golang01_002.png" alt=""></p><ul><li>学习难度低：类C的语法,如果熟悉C语言及其派生语言,一周就可以写出高性能的应用</li></ul><h3 id="三、安装部署"><a href="#三、安装部署" class="headerlink" title="三、安装部署"></a>三、安装部署</h3><h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><p>例如window用户：</p><ul><li>1.点击<a href="https://golang.google.cn/dl/" target="_blank" rel="noopener">官网</a>，选择对应系统包安装，点击下载</li></ul><p><img src="/image/Golang01/Golang01_003.png" alt=""></p><ul><li>2.下载完一路点击安装就可以了。安装完成后，在安装目录下将生成一些目录和文件</li><li>3.设置环境变量<ul><li>win+E,然后右键<strong>这台电脑</strong>→<strong>属性</strong>→<strong>高级系统设置</strong>→<strong>环境变量</strong>，如下图所示。</li><li>在弹出的菜单里点击新建三个变量并配置到<strong>Path</strong>上。<ul><li><strong>GOROOT</strong>:刚才go的安装路径</li><li><strong>GOBIN</strong>:go的执行程序路径</li><li><strong>GOPATH</strong>:准备使用go进行开发的工程路径,</li></ul></li></ul></li></ul><p><img src="/image/Golang01/Golang01_004.png" alt=""><br><img src="/image/Golang01/Golang01_005.png" alt=""></p><h3 id="四、开发工具"><a href="#四、开发工具" class="headerlink" title="四、开发工具"></a>四、开发工具</h3><ol><li>Goland:是由 JetBrains 公司专门为开发者提供的一个符合人体工程学的商业 IDE。</li><li>LiteIDE:一款专门针对 Go 开发的集成开发环境，在编辑、编译和运行 Go 程序和项目方面都有非常好的支持。</li><li>Sublime Text:是一个革命性的跨平台（Linux、Mac OS X、Windows）文本编辑器，它支持编写非常多的编程语言代码。对于 Go 而言，它有一个插件叫做 GoSublime 来支持代码补全和代码模版。</li><li>GoClipse: Eclipse 的插件，拥有非常多的特性以及通过 GoCode 来实现代码补全功能。</li><li>VS Code: 是一款由微软公司开发的，能运行在 Mac OS X、Windows 和 Linux 上的跨平台开源代码编辑器</li></ol><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li>1.在自己建好的<strong>GOPATH</strong>下，新建三个目录<ul><li>src 目录：放置项目和库的源文件；</li><li>pkg 目录：放置编译后生成的包/库的归档文件；</li><li>bin 目录：放置编译后生成的可执行文件</li></ul></li><li><p>2.在src下面创建main目录,然后再目录下新建main.go,然后进行语言入门打卡操作</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main    <span class="comment">// 声明 main 包</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span>       <span class="comment">// 导入 fmt 包，打印字符串是需要用到</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   <span class="comment">// 声明 main 主函数</span></span><br><span class="line">    fmt.Println(<span class="string">"Hello World!"</span>) <span class="comment">// 打印 Hello World!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>3.编译和运行代码:如果是Goland使用ctrl+shift+F10,也可以使用下面命令:<ul><li>go build fileName :将代码编译成二进制的可执行文件，但是需要手动运行该二进制文件</li><li>go run fileName :在编译后直接运行程序，编译过程中会产生一个临时文件，但不会生成可执行文件</li></ul></li></ul><h3 id="五、命令工具"><a href="#五、命令工具" class="headerlink" title="五、命令工具"></a>五、命令工具</h3><ul><li>go build：编译命令<ul><li>-v: 编译时显示包名</li><li>-p n 开启并发编译，默认情况下该值为 CPU 逻辑核数</li><li>-a 强制重新构建</li><li>-n 打印编译时会用到的所有命令，但不真正执行</li><li>-x 打印编译时会用到的所有命令</li><li>-race 开启竞态检测</li></ul></li><li>go clean：清除编译文件<ul><li>i 清除关联的安装的包和可运行文件，也就是通过go install安装的文件；</li><li>n 把需要执行的清除命令打印出来，但是不执行，这样就可以很容易的知道底层是如何运行的；</li><li>r 循环的清除在 import 中引入的包；</li><li>x 打印出来执行的详细命令，其实就是 -n 打印的执行版本；</li><li>cache 删除所有go build命令的缓存</li><li>testcache 删除当前包所有的测试结果</li></ul></li><li>go run：编译并运行</li><li>go install：编译并安装</li><li>go get：一键获取代码、编译并安装<ul><li>-v 显示操作流程的日志及信息，方便检查错误</li><li>-u 下载丢失的包，但不会更新已经存在的包</li><li>-d 只下载，不安装</li><li>-insecure 允许使用不安全的 HTTP 方式进行下载操作</li></ul></li><li>go generate：在编译前自动化生成某类代码<ul><li>run 正则表达式匹配命令行，仅执行匹配的命令；</li><li>v 输出被处理的包名和源文件名；</li><li>n 显示不执行命令；</li><li>x 显示并执行命令；</li></ul></li><li>go test：单元测试命令</li><li>go fmt：格式化代码文件<ul><li>-l 仅把那些不符合格式化规范的、需要被命令程序改写的源码文件的绝对路径打印到标准输出。而不是把改写后的全部内容都打印到标准输出。</li><li>-w 把改写后的内容直接写入到文件中，而不是作为结果打印到标准输出。</li><li>-r 添加形如“a[b:len(a)] -&gt; a[b:]”的重写规则。如果我们需要自定义某些额外的格式化规则，就需要用到它。</li><li>-s 简化文件中的代码。</li><li>-d 只把改写前后内容的对比信息作为结果打印到标准输出。而不是把改写后的全部内容都打印到标准输出。 命令程序将使用 diff 命令对内容进行比对。在 Windows 操作系统下可能没有 diff 命令，需要另行 安装。</li><li>-e 打印所有的语法错误到标准输出。如果不使用此标记，则只会打印每行的第 1 个错误且只打印前 10 个错误。</li><li>-comments 是否保留源码文件中的注释。在默认情况下，此标记会被隐式的使用，并且值为 true。</li><li>-tabwidth 此标记用于设置代码中缩进所使用的空格数量，默认值为 8。要使此标记生效，需要使用“-tabs”标记并把值设置为 false。</li><li>-tabs 是否使用 tab（’\t’）来代替空格表示缩进。在默认情况下，此标记会被隐式的使用，并且值为 true。</li><li>-cpuprofile 是否开启 CPU 使用情况记录，并将记录内容保存在此标记值所指的文件中。</li></ul></li><li>go pprof：性能分析工具<em>**</em></li></ul><h3 id="六、外部工具"><a href="#六、外部工具" class="headerlink" title="六、外部工具"></a>六、外部工具</h3><h4 id="godoc"><a href="#godoc" class="headerlink" title="godoc"></a><strong>godoc</strong></h4><p>godoc 工具会从 Go 程序和包文件中提取顶级声明的首行注释以及每个对象的相关注释，并生成相关文档，也可以作为一个提供在线文档浏览的 web 服务器，Go语言官网（<a href="https://golang.google.cn/" target="_blank" rel="noopener">https://golang.google.cn/</a><br>）就是通过这种形式实现的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get golang.org/x/tools/cmd/godoc</span><br></pre></td></tr></table></figure><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>由于防火墙的原因，国内的用户可能无法通过go get 命令来获取 godoc 工具，这时候就需要大家来手动操作了。</p><ul><li>首先从 GitHub（<a href="https://github.com/golang/tools.git" target="_blank" rel="noopener">https://github.com/golang/tools.git</a>） 下载 golang.org/x/tools 包；</li><li>然后将下载得到的文件解压到 GOPATH 下的 src\golang.org\x\tools 目录中，没有的话可以手动创建；</li><li>打开 GOPATH 下的 src\golang.org\x\tools\cmd\godoc 目录，在该目录下打开命令行工具，并执行<code>go build</code> 命令，生成 godoc.exe 可执行文件；</li><li>最后，将生成的 godoc.exe 文件移动到 GOPATH 下的 bin 目录中。（需要把 GOPATH 下的 bin 目录添加到环境变量 Path 中）</li></ul><h5 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h5><p>完成上述操作后就可以使用 godoc 工具了，godoc 工具一般有以下几种用法：</p><ul><li>go doc package：获取包的文档注释，例如<code>go doc fmt</code> 会显示使用 godoc 生成的 fmt 包的文档注释；</li><li>go doc package/subpackage：获取子包的文档注释，例如<code>go doc container/list</code>；</li><li>go doc package function：获取某个函数在某个包中的文档注释，例如<code>go doc fmt Printf</code> 会显示有关 fmt.Printf() 的使用说明。</li></ul><h4 id="gofmt：go-fmt的升级版"><a href="#gofmt：go-fmt的升级版" class="headerlink" title="gofmt：go fmt的升级版"></a>gofmt：go fmt的升级版</h4><h4 id="golint：代码质量的检查"><a href="#golint：代码质量的检查" class="headerlink" title="golint：代码质量的检查"></a>golint：代码质量的检查</h4><p>More info: <a href="http://c.biancheng.net/golang/" target="_blank" rel="noopener">Golang</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　Go语言（或 Golang）起源于 2007 年，并在 2009 年正式对外发布。Go 是 Google的 Robert Griesemer，Rob Pike 及 Ken Thompson 开发的一种静态强类型、编译型语言。它的主要目标是“兼具&lt;a href=&quot;http://c.biancheng.net/python/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Python&lt;/a&gt;等动态语言的开发速度和 C/&lt;a href=&quot;http://c.biancheng.net/cplus/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;C++&lt;/a&gt;等编译型语言的性能与安全性”。&lt;br&gt;　　本文章主要介绍 Golang 的特点和部署使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://lightalight.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>部署Rap2</title>
    <link href="https://lightalight.github.io/2021/01/15/%E9%83%A8%E7%BD%B2Rap2/"/>
    <id>https://lightalight.github.io/2021/01/15/部署Rap2/</id>
    <published>2021-01-15T14:23:32.000Z</published>
    <updated>2022-07-03T03:18:39.281Z</updated>
    
    <content type="html"><![CDATA[<p>Rap2是一个可视化接口管理工具,通过分析接口结构，动态生成模拟数据，校验真实接口正确性.本文章介绍如何在Centos7.5下面使用dokcer部署Rap2。<br><a id="more"></a></p><h2 id="Quick-Guide"><a href="#Quick-Guide" class="headerlink" title="Quick Guide"></a>Quick Guide</h2><p><img src="/image/部署Rap2_001.jpg" alt=""></p><h3 id="直接使用"><a href="#直接使用" class="headerlink" title="直接使用"></a>直接使用</h3><p>如果想直接使用，可以点击<a href="http://rap2.taobao.org/" target="_blank" rel="noopener">taobao</a>通过申请一个账号后，即可在里面进行接口的编写、测试。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h4><ul><li>安装docker</li><li>安装docker-compose</li></ul><h4 id="后端部署"><a href="#后端部署" class="headerlink" title="后端部署"></a>后端部署</h4><p>rap2-delos: 后端数据API服务器，基于Koa + MySQL</p><ul><li>1.部署  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir rap2</span><br><span class="line"><span class="built_in">cd</span> rap2</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/thx/rap2-delos.git</span><br><span class="line"><span class="built_in">cd</span> rap2-delos</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></li></ul><p><img src="/image/部署Rap2_002.png" alt=""></p><ul><li>2.初始化数据库  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it rap2-delos sh </span><br><span class="line">node scripts/init</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="/image/部署Rap2_003.png" alt=""></p><ul><li>3.重新启动服务  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></li></ul><p><img src="/image/部署Rap2_004.png" alt=""></p><ul><li>4.测试  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl localhost:38080</span><br></pre></td></tr></table></figure></li></ul><p><img src="/image/部署Rap2_005.png" alt=""></p><h4 id="前端部署"><a href="#前端部署" class="headerlink" title="前端部署"></a>前端部署</h4><p>rap2-dolores: 前端静态资源，基于React</p><ul><li><p>1.拉取代码</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/thx/rap2-dolores.git</span><br><span class="line"><span class="built_in">cd</span> rap2-dolores</span><br></pre></td></tr></table></figure></li><li><p>2.创建Dockerfile,复制下面内容到里面</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi Dockerfile</span><br></pre></td></tr></table></figure><p>  Dockerfile中的内容为：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取10.1.0版本的node镜像</span></span><br><span class="line">FROM node:10.1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 维护人</span></span><br><span class="line">MAINTAINER ryn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建工作目录</span></span><br><span class="line">RUN mkdir -p /home/rap2-dolores</span><br><span class="line">WORKDIR /home/rap2-dolores</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将代码拷贝至工作目录</span></span><br><span class="line">COPY . /home/rap2-dolores</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局安装http-server服务器</span></span><br><span class="line">RUN npm install -g http-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局安装node-sass(一定要带--unsafe-perm，否则会报错)</span></span><br><span class="line">RUN npm install --unsafe-perm -g node-sass</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包</span></span><br><span class="line">RUN npm run build</span><br></pre></td></tr></table></figure></li><li><p>3.创建docker-compose,把下面内容拷贝进去</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi docker-compose.yml</span><br></pre></td></tr></table></figure><p>  docker-compose.yml中的内容为：</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2.2'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  delores:</span></span><br><span class="line">    <span class="comment"># 容器名称</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">rap2-dolores</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 通过Dockerfile来构建本地镜像</span></span><br><span class="line"><span class="attr">    build:</span> <span class="string">.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 通过images来构建，这里的地址暂不适用，因为src/config中的配置需要根据自己的服务器来动态构建</span></span><br><span class="line">    <span class="comment"># image rynxiao/rap2-dolores-nodejs</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 指定工作目录</span></span><br><span class="line"><span class="attr">    working_dir:</span> <span class="string">/home/rap2-dolores</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 指定生产环境</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">NODE_ENV=production</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment"># 启动http-server，并映射端口到容器内部8081上</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">/bin/sh</span> <span class="bullet">-c</span> <span class="string">'http-server ./build -s -p 8081'</span></span><br><span class="line"><span class="attr">    privileged:</span> <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># expose port 38081</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"38081:8081"</span></span><br></pre></td></tr></table></figure></li><li><p>4.更改src/config/config.prod.js中的配置，将接口请求地址指向你的后端服务器</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi src/config/config.prod.js</span><br></pre></td></tr></table></figure>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  serve: <span class="string">'http://&lt;后端服务器ip&gt;:38080'</span>,</span><br><span class="line">  keys: [<span class="string">'some secret hurr'</span>],</span><br><span class="line">  session: &#123;</span><br><span class="line">    key: <span class="string">'koa:sess'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>5.启动服务</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></li><li><p>6.使用浏览器访问访问http://{前端地址}:38081</p></li></ul><p><img src="/image/部署Rap2_006.png" alt=""></p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li><p>1.注册帐号<br>  <img src="/image/部署Rap2_007.png" alt=""></p></li><li><p>2.注册成功后，进去创建一个项目仓库<br>  <img src="/image/部署Rap2_008.png" alt=""><br>  <img src="/image/部署Rap2_009.png" alt=""></p></li><li><p>3.仓库建好以后，我们进入仓库，点击新建接口<br>  <img src="/image/部署Rap2_010.png" alt=""><br>  <img src="/image/部署Rap2_011.png" alt=""></p></li><li><p>4.选择新建接口编辑参数，参数语法参考<a href="https://github.com/nuysoft/Mock/wiki/Syntax-Specification" target="_blank" rel="noopener">mock.js语法规范文档</a><br>  <img src="/image/部署Rap2_012.png" alt=""><br>  <img src="/image/部署Rap2_013.png" alt=""></p></li><li><p>5.点击测试<br>  <img src="/image/部署Rap2_014.png" alt=""></p></li></ul><p>More info: <a href="https://github.com/thx/rap2-delos" target="_blank" rel="noopener">Github</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Rap2是一个可视化接口管理工具,通过分析接口结构，动态生成模拟数据，校验真实接口正确性.本文章介绍如何在Centos7.5下面使用dokcer部署Rap2。&lt;br&gt;
    
    </summary>
    
    
      <category term="环境部署" scheme="https://lightalight.github.io/tags/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>接口工具HttpRunner</title>
    <link href="https://lightalight.github.io/2020/12/15/%E6%8E%A5%E5%8F%A3%E5%B7%A5%E5%85%B7HttpRunner/"/>
    <id>https://lightalight.github.io/2020/12/15/接口工具HttpRunner/</id>
    <published>2020-12-15T11:23:32.000Z</published>
    <updated>2022-07-03T03:17:16.765Z</updated>
    
    <content type="html"><![CDATA[<p>HttpRunner 是一款面向 HTTP(S) 协议的通用测试框架，只需编写维护一份 YAML/JSON 脚本，即可实现自动化测试、性能测试、线上监控、持续集成等多种测试需求。本文章介绍在Windows7如何安装和使用HttpRunner。<br><a id="more"></a></p><h2 id="Quick-Guide"><a href="#Quick-Guide" class="headerlink" title="Quick Guide"></a>Quick Guide</h2><p><img src="/image/接口工具HttpRunner_001.png" alt=""></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li><p>1.使用pip安装</p>  <figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install httprunner</span><br></pre></td></tr></table></figure></li><li><p>2.验证安装</p>  <figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hrun -V</span><br></pre></td></tr></table></figure></li></ul><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ul><li><p>1.新建测试项目</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hrun --startproject NewApiTest</span><br></pre></td></tr></table></figure><p><img src="/image/接口工具HttpRunner_002.png" alt=""></p></li></ul><ul><li>2.目录结构说明<ul><li>debugtalk.py：该文件所在目录将作为项目工程的根目录，api 文件夹都必须与其放置在相同目录</li><li>api 文件夹：存储接口定义描述</li><li>reports 文件夹：存储 HTML 测试报告</li><li>testcases 文件夹（非必须）：存储测试用例，文件夹也可以使用其它名称</li><li>testsuite 文件夹（非必须）：测试测试场景，文件夹也可以使用其它名称</li></ul></li></ul><ul><li>3.文件类型说明<ul><li>YAML/JSON（必须）：测试用例文件，存储接口测试相关信息</li><li>debugtalk.py（可选）：存储项目中逻辑运算辅助函数<ul><li>该文件存在时，将作为项目根目录定位标记，其所在目录即被视为项目工程根目录</li><li>该文件不存在时，运行测试的所在路径（CWD）将被视为项目工程根目录</li><li>测试用例文件中的相对路径（例如.csv）均需基于项目工程根目录</li><li>运行测试后，测试报告文件夹（reports）会生成在项目工程根目录</li></ul></li><li>.env（可选）：存储项目环境变量，通常用于存储项目敏感信息</li><li>.csv（可选）：项目数据文件，用于进行数据驱动</li><li>reports：默认生成测试报告的存储文件夹</li></ul></li></ul><ul><li>4.测试用例结构<ul><li>测试用例集（testsuite）：对应一个文件夹，包含单个或多个测试用例（YAML/JSON）文件</li><li>测试用例（testcase）：对应一个 YAML/JSON 文件，包含单个或多个测试步骤</li><li>测试步骤（teststep）：对应 YAML/JSON 文件中的一个 test，描述单次接口测试的全部内容，包括发起接口请求、解析响应结果、校验结果等</li></ul></li></ul><ul><li><p>5.测试用例文件结构（YAML/JSON）</p><ul><li>config：作为整个测试用例的全局配置项</li><li>test：对应单个测试步骤（teststep），测试用例存在顺序关系，运行时将从前往后依次运行各个测试步骤。各个测试步骤（test）的变量空间相互独立，互不影响。需在多个测试步骤（test）中传递参数值，则需要使用 extract 关键字，并且只能从前往后传递。<ul><li>若某变量在 config 中定义了，在某 test 中没有定义，则该 test 会继承该变量</li><li>若某变量在 config 和某 test 中都定义了，则该 test 中使用自己定义的变量值</li></ul></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    "config": &#123;...&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    "test": &#123;...&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    "test": &#123;...&#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li><p>config参数说明</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">"config": &#123;</span><br><span class="line">    "name": "testcase description",</span><br><span class="line">    "parameters": [</span><br><span class="line">        &#123;"user_agent": ["iOS/10.1", "iOS/10.2", "iOS/10.3"]&#125;,</span><br><span class="line">        &#123;"app_version": "$&#123;P(app_version.csv)&#125;"&#125;,</span><br><span class="line">        &#123;<span class="attr">"os_platform"</span>: <span class="string">"$&#123;get_os_platform()&#125;"</span>&#125;</span><br><span class="line">    ],</span><br><span class="line">    "variables": [</span><br><span class="line">        &#123;"user_agent": "iOS/10.3"&#125;,</span><br><span class="line">        &#123;"device_sn": "$&#123;gen_random_string(15)&#125;"&#125;,</span><br><span class="line">        &#123;<span class="attr">"os_platform"</span>: <span class="string">"ios"</span>&#125;</span><br><span class="line">    ],</span><br><span class="line">    "request": &#123;</span><br><span class="line">        "base_url": "http://127.0.0.1:5000",</span><br><span class="line">        "headers": &#123;</span><br><span class="line">            "Content-Type": "application/json",</span><br><span class="line">            "device_sn": "$device_sn"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    "output": [</span><br><span class="line">        <span class="string">"token"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><table><thead><tr><th>Key</th><th>required</th><th>format</th><th>descrption</th></tr></thead><tbody><tr><td>name</td><td>Yes</td><td>string</td><td>测试用例的名称，在测试报告中将作为标题</td></tr><tr><td>variables</td><td>No</td><td>list of dict</td><td>定义的全局变量，作用域为整个用例</td></tr><tr><td>parameters</td><td>No</td><td>list of dict</td><td>全局参数，用于实现数据化驱动，作用域为整个用例</td></tr><tr><td>request</td><td>No</td><td>dict</td><td>request 的公共参数，作用域为整个用例；常用参数包括 base_url 和 headers</td></tr><tr><td>base_url</td><td>No</td><td>string</td><td>测试用例请求 URL 的公共 host，指定该参数后，test 中的 url 可以只描述 path 部分</td></tr><tr><td>headers</td><td>No</td><td>dict</td><td>request 中 headers 的公共参数，作用域为整个用例</td></tr><tr><td>output</td><td>No</td><td>list</td><td>整个用例输出的参数列表，可输出的参数包括公共的 variable 和 extract 的参数; 在 log-level 为 debug 模式下，会在 terminal 中打印出参数内容</td></tr></tbody></table><ul><li><p>test参数说明</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">"test": &#123;</span><br><span class="line">    "name": "get token with $user_agent, $os_platform, $app_version",</span><br><span class="line">    "request": &#123;</span><br><span class="line">        "url": "/api/get-token",</span><br><span class="line">        "method": "POST",</span><br><span class="line">        "headers": &#123;</span><br><span class="line">            "app_version": "$app_version",</span><br><span class="line">            "os_platform": "$os_platform",</span><br><span class="line">            "user_agent": "$user_agent"</span><br><span class="line">        &#125;,</span><br><span class="line">        "json": &#123;</span><br><span class="line">            "sign": "$&#123;get_sign($user_agent, $device_sn, $os_platform, $app_version)&#125;"</span><br><span class="line">        &#125;,</span><br><span class="line">        "extract": [</span><br><span class="line">            &#123;<span class="attr">"token"</span>: <span class="string">"content.token"</span>&#125;</span><br><span class="line">        ],</span><br><span class="line">        "validate": [</span><br><span class="line">            &#123;"eq": ["status_code", 200]&#125;,</span><br><span class="line">            &#123;"eq": ["headers.Content-Type", "application/json"]&#125;,</span><br><span class="line">            &#123;<span class="attr">"eq"</span>: [<span class="string">"content.success"</span>, <span class="literal">true</span>]&#125;</span><br><span class="line">        ],</span><br><span class="line">        "setup_hooks": [],</span><br><span class="line">        "teardown_hooks": []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><table><thead><tr><th>Key</th><th>required</th><th>format</th><th>descrption</th></tr></thead><tbody><tr><td>name</td><td>Yes</td><td>string</td><td>测试步骤的名称，在测试报告中将作为测试步骤的名称</td></tr><tr><td>request</td><td>Yes</td><td>dict</td><td>HTTP 请求的详细内容；可用参数详见 python-requests 官方文档</td></tr><tr><td>variables</td><td>No</td><td>list of dict</td><td>测试步骤中定义的变量，作用域为当前测试步骤</td></tr><tr><td>extract</td><td>No</td><td>list</td><td>从当前 HTTP 请求的响应结果中提取参数，并保存到参数变量中（例如token），后续测试用例可通过$token的形式进行引用</td></tr><tr><td>validate</td><td>No</td><td>list</td><td>测试用例中定义的结果校验项，作用域为当前测试用例，用于实现对当前测试用例运行结果的校验</td></tr><tr><td>setup_hooks</td><td>No</td><td>list</td><td>在 HTTP 请求发送前执行 hook 函数，主要用于准备工作</td></tr><tr><td>teardown_hooks</td><td>No</td><td>list</td><td>在 HTTP 请求发送后执行 hook 函数，主要用户测试后的清理工作</td></tr></tbody></table><ul><li><p>6.创建测试用例文件</p><p><img src="/image/接口工具HttpRunner_003.png" alt=""></p></li></ul><ul><li><p>7.运行</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hrun test_demo.yaml</span><br></pre></td></tr></table></figure><p><img src="/image/接口工具HttpRunner_004.png" alt=""></p></li><li><p>8.报告</p><p><img src="/image/接口工具HttpRunner_005.png" alt=""></p></li></ul><h3 id="HttpRunnerManager"><a href="#HttpRunnerManager" class="headerlink" title="HttpRunnerManager"></a>HttpRunnerManager</h3><p>HttpRunnerManager是基于HttpRunner的接口自动化测试平台,该工具是对 HttpRunner的包装和Web图形化, 另外还增加了一些新概念(项目/模块)用来组织用例</p><ul><li>1.前置<ul><li>安装mysql(推荐5.7+),并设置为utf-8编码，创建相应HttpRunner数据库，设置好相应用户名、密码，启动mysql</li><li>安装rabbitmq,需要先安装erlang</li></ul></li></ul><ul><li><p>2.下载</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/HttpRunner/HttpRunnerManager.git</span><br></pre></td></tr></table></figure></li><li><p>3.修改配置</p><p>打开HttpRunnerManager/HttpRunnerManager/settings.py配置对应mysql和rabbitmq信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改DATABASES字典为创建的mysql数据库信息和邮件发送账号</span></span><br><span class="line"><span class="keyword">if</span> DEBUG:</span><br><span class="line">    DATABASES = &#123;</span><br><span class="line">        <span class="string">'default'</span>: &#123;</span><br><span class="line">            <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,</span><br><span class="line">            <span class="string">'NAME'</span>: <span class="string">'HttpRunnerManager'</span>,  <span class="comment"># 新建数据库名</span></span><br><span class="line">            <span class="string">'USER'</span>: <span class="string">'root'</span>,  <span class="comment"># 数据库登录名</span></span><br><span class="line">            <span class="string">'PASSWORD'</span>: <span class="string">''</span>,  <span class="comment"># 数据库登录密码</span></span><br><span class="line">            <span class="string">'HOST'</span>: <span class="string">'127.0.0.1'</span>,  <span class="comment"># 数据库所在服务器ip地址</span></span><br><span class="line">            <span class="string">'PORT'</span>: <span class="string">'3306'</span>,  <span class="comment"># 监听端口 默认3306即可</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    STATICFILES_DIRS = (</span><br><span class="line">        os.path.join(BASE_DIR, <span class="string">'static'</span>),  <span class="comment"># 静态文件额外目录</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    DATABASES = &#123;</span><br><span class="line">        <span class="string">'default'</span>: &#123;</span><br><span class="line">            <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,</span><br><span class="line">            <span class="string">'NAME'</span>: <span class="string">'HttpRunnerManager'</span>,  <span class="comment"># 新建数据库名</span></span><br><span class="line">            <span class="string">'USER'</span>: <span class="string">'root'</span>,  <span class="comment"># 数据库登录名</span></span><br><span class="line">            <span class="string">'PASSWORD'</span>: <span class="string">''</span>,  <span class="comment"># 数据库登录密码</span></span><br><span class="line">            <span class="string">'HOST'</span>: <span class="string">'127.0.0.1'</span>,  <span class="comment"># 数据库所在服务器ip地址</span></span><br><span class="line">            <span class="string">'PORT'</span>: <span class="string">'3306'</span>,  <span class="comment"># 监听端口 默认3306即可</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    STATIC_ROOT = os.path.join(BASE_DIR, <span class="string">'static'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改worker配置为搭建rabbitmq的信息</span></span><br><span class="line">djcelery.setup_loader()</span><br><span class="line">CELERY_ENABLE_UTC = <span class="keyword">True</span></span><br><span class="line">CELERY_TIMEZONE = <span class="string">'Asia/Shanghai'</span></span><br><span class="line">BROKER_URL = <span class="string">'amqp://guest:guest@127.0.0.1:5672//'</span>  <span class="comment"># 127.0.0.1即为rabbitmq-server所在服务器ip地址</span></span><br><span class="line">CELERYBEAT_SCHEDULER = <span class="string">'djcelery.schedulers.DatabaseScheduler'</span></span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">'djcelery.backends.database:DatabaseBackend'</span></span><br><span class="line">CELERY_ACCEPT_CONTENT = [<span class="string">'application/json'</span>]</span><br><span class="line">CELERY_TASK_SERIALIZER = <span class="string">'json'</span></span><br><span class="line">CELERY_RESULT_SERIALIZER = <span class="string">'json'</span></span><br><span class="line"></span><br><span class="line">CELERY_TASK_RESULT_EXPIRES = <span class="number">7200</span>  <span class="comment"># celery任务执行结果的超时时间，</span></span><br><span class="line">CELERYD_CONCURRENCY = <span class="number">10</span>  <span class="comment"># celery worker的并发数 也是命令行-c指定的数目 根据服务器配置实际更改 默认10</span></span><br><span class="line">CELERYD_MAX_TASKS_PER_CHILD = <span class="number">100</span>  <span class="comment"># 每个worker执行了多少任务就会死掉，我建议数量可以大一些，默认100</span></span><br></pre></td></tr></table></figure></li><li><p>4.安装依赖</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure></li><li><p>5.生成表结构</p><p>切换到HttpRunnerManager目录 生成数据库迁移脚本,并生成表结构</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations ApiManager #生成数据迁移脚本</span><br><span class="line">python manage.py migrate  #应用到db生成数据表</span><br></pre></td></tr></table></figure></li><li><p>6.创建用户</p><p>创建超级用户，用户后台管理数据库，并按提示输入相应用户名，密码，邮箱。 如不需用，可跳过此步骤</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br></pre></td></tr></table></figure></li><li><p>7.启动服务</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py runserver <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8000</span></span><br></pre></td></tr></table></figure></li><li><p>8.访问</p><ul><li>注册和登录:浏览器输入 <a href="http://127.0.0.1:8000/api/register/" target="_blank" rel="noopener">http://127.0.0.1:8000/api/register/</a> ,平台的使用可以参考<a href="https://github.com/HttpRunner/HttpRunnerManager#新手入门指导" target="_blank" rel="noopener">新手入门指导</a></li></ul><p><img src="/image/接口工具HttpRunner_006.png" alt=""><br><img src="/image/接口工具HttpRunner_007.png" alt=""><br><img src="/image/接口工具HttpRunner_008.png" alt=""></p><ul><li>运维:浏览器输入 <a href="http://127.0.0.1:8000/admin/" target="_blank" rel="noopener">http://127.0.0.1:8000/admin/</a> 输入之前创建的超级用户名、密码，登录后台运维管理系统，可后台管理数据<br><img src="/image/接口工具HttpRunner_009.png" alt=""></li></ul></li></ul><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><ul><li><p>httprunner可以复用python的开源测试框架locust,locust的安装与使用可以看 <a href="/2017/07/15/性能工具Locust/" title="这里">这里</a> ，使用locust对yaml/json用例文件中的接口进行压测</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locusts -f D://testcases//test_demo.yaml</span><br></pre></td></tr></table></figure><p><img src="/image/接口工具HttpRunner_010.png" alt=""></p></li><li><p>web监控器启动成功，我们点击转到locust的<a href="http://localhost:8089/" target="_blank" rel="noopener">web页面</a>,配置压测参数：</p><p><img src="/image/接口工具HttpRunner_011.png" alt=""></p></li><li><p>观察结果<br><img src="/image/接口工具HttpRunner_012.png" alt=""></p></li></ul><p>More info: <a href="https://cn.httprunner.org/" target="_blank" rel="noopener">中文文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HttpRunner 是一款面向 HTTP(S) 协议的通用测试框架，只需编写维护一份 YAML/JSON 脚本，即可实现自动化测试、性能测试、线上监控、持续集成等多种测试需求。本文章介绍在Windows7如何安装和使用HttpRunner。&lt;br&gt;
    
    </summary>
    
    
      <category term="接口" scheme="https://lightalight.github.io/tags/%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>部署OpenResty</title>
    <link href="https://lightalight.github.io/2020/11/15/%E9%83%A8%E7%BD%B2OpenResty/"/>
    <id>https://lightalight.github.io/2020/11/15/部署OpenResty/</id>
    <published>2020-11-15T13:03:06.000Z</published>
    <updated>2022-07-03T03:16:43.091Z</updated>
    
    <content type="html"><![CDATA[<p>OpenResty是一个基于Nginx的可伸缩的Web平台，默认集成了Lua开发环境。文章介绍如何在居于Centos7.5安装OpenResty。<br><a id="more"></a></p><h2 id="Quick-Deploy"><a href="#Quick-Deploy" class="headerlink" title="Quick Deploy"></a>Quick Deploy</h2><h3 id="部署准备"><a href="#部署准备" class="headerlink" title="部署准备"></a>部署准备</h3><ul><li>1.检查依赖库(perl 5.6.1+, libreadline, libpcre, libssl, gcc, curl)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ldconfig  -v | grep -E <span class="string">'readline|pcre|openssl'</span></span><br><span class="line">yum list installed | grep -E <span class="string">'perl|gcc|curl'</span></span><br></pre></td></tr></table></figure><ul><li>2.安装依赖库(也可以不检查,直接使用下面命令安装)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install readline-devel pcre-devel openssl-devel perl gcc curl</span><br></pre></td></tr></table></figure><h3 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h3><ul><li>1.下载安装包</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://openresty.org/download/openresty-1.13.6.2.tar.gz</span><br></pre></td></tr></table></figure><ul><li>2.解压安装包</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf openresty-1.13.6.2.tar.gz</span><br></pre></td></tr></table></figure><ul><li>3.编译(默认情况下程序会安装到 /usr/local/openresty 目录,你可以使用 ./configure –help 查看更多的配置选项)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> openresty-1.13.6.2</span><br><span class="line">./configure</span><br><span class="line">make </span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h3 id="重要目录说明"><a href="#重要目录说明" class="headerlink" title="重要目录说明"></a>重要目录说明</h3><ul><li>nginx <ul><li>sbin<ul><li>nignx 启动程序</li></ul></li><li>logs<ul><li>access.log 访问日志</li><li>error.log 错误日志</li></ul></li><li>conf<ul><li>nginx.con 配置文件</li></ul></li></ul></li></ul><h3 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h3><ul><li>1.创建日志和配置目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir  /home/<span class="built_in">test</span>/logs/conf/</span><br><span class="line"><span class="built_in">cd</span> /home/<span class="built_in">test</span>/</span><br><span class="line">mkdir  logs/ conf/</span><br></pre></td></tr></table></figure><ul><li>2.打开配置文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi  conf/nginx.conf</span><br></pre></td></tr></table></figure><ul><li>3.新增配置</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#启动一个进程</span><br><span class="line">worker_processes  <span class="number">1</span>; </span><br><span class="line">#设置错误日志目录</span><br><span class="line">error_log logs/<span class="built_in">error</span>.<span class="built_in">log</span>;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        #设置端口</span><br><span class="line">        listen <span class="number">9000</span>;</span><br><span class="line">        #设置访问路径</span><br><span class="line">        location / &#123;</span><br><span class="line">            default_type text/html;</span><br><span class="line">            #设置返回内容</span><br><span class="line">            content_by_lua <span class="string">'</span></span><br><span class="line"><span class="string">                ngx.say("&lt;p&gt;Hello, World!&lt;/p&gt;")</span></span><br><span class="line"><span class="string">            '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3.启动 OpenResty (如果没有任何输出，说明启动成功，-p 指定我们的项目目录，-c 指定配置文件)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/openresty/nginx/sbin/nginx -p /home/<span class="built_in">test</span>/ -c /home/<span class="built_in">test</span>/conf/nginx.conf</span><br></pre></td></tr></table></figure><ul><li>4.访问OpenResty(通过curl或者浏览器访问,返回 Hello World为启动成功)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:9000/</span><br></pre></td></tr></table></figure><p>More info: <a href="https://openresty.org/cn/installation.html" target="_blank" rel="noopener">新手上路</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OpenResty是一个基于Nginx的可伸缩的Web平台，默认集成了Lua开发环境。文章介绍如何在居于Centos7.5安装OpenResty。&lt;br&gt;
    
    </summary>
    
    
      <category term="环境部署" scheme="https://lightalight.github.io/tags/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    
      <category term="nginx" scheme="https://lightalight.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>ELK（三）Kibana</title>
    <link href="https://lightalight.github.io/2020/10/15/ELK03/"/>
    <id>https://lightalight.github.io/2020/10/15/ELK03/</id>
    <published>2020-10-15T11:23:32.000Z</published>
    <updated>2020-09-20T09:45:13.126Z</updated>
    
    <content type="html"><![CDATA[<p>　　Kibana 是一个针对Elasticsearch的开源分析及可视化平台，用来搜索、查看交互存储在Elasticsearch索引中的数据。使用 Kibana，可以通过各种图表进行高级数据分析及展示。<br>　　本文章主要介绍 Kibana 的入门知识。</p><a id="more"></a><h2 id="Quick-Guide"><a href="#Quick-Guide" class="headerlink" title="Quick Guide"></a>Quick Guide</h2><p>　　Kibana架构为Elasticsearch定制，可以将任何结构化和非结构化数据加入Elasticsearch索引。Kibana还充分利用了Elasticsearch强大的搜索和分析功能。</p><h3 id="一、优点"><a href="#一、优点" class="headerlink" title="一、优点"></a>一、优点</h3><ul><li>整合你的数据：Kibana能够更好地处理海量数据，并据此创建柱形图、折线图、散点图、直方图、饼图和地图。</li><li>复杂数据分析：Kibana提升了Elasticsearch分析能力，能够更加智能地分析数据，执行数学转换并且根据要求对数据切割分块。</li><li>让更多团队成员受益：强大的数据库可视化接口让各业务岗位都能够从数据集合受益。</li><li>接口灵活，分享更容易：使用Kibana可以更加方便地创建、保存、分享数据，并将可视化数据快速交流。</li><li>配置简单：Kibana的配置和启用非常简单，用户体验非常友好。Kibana 4自带Web服务器，可以快速启动运行。</li><li>可视化多数据源： Kibana可以非常方便地把来自<a href="https://www.elastic.co/products/logstash" target="_blank" rel="noopener">Logstash</a>、<a href="https://www.elastic.co/products/hadoop" target="_blank" rel="noopener">ES-Hadoop</a>、<a href="https://www.elastic.co/products/beats" target="_blank" rel="noopener">Beats</a>或第三方技术的数据整合到Elasticsearch，支持的第三方技术包括<a href="http://flume.apache.org/" target="_blank" rel="noopener">Apache Flume</a>、<a href="http://www.fluentd.org/" target="_blank" rel="noopener">Fluentd</a>等。 </li><li>简单数据导出： Kibana可以方便地导出感兴趣的数据，与其它数据集合并融合后快速建模分析，发现新结果。 </li></ul><h3 id="二、安装部署"><a href="#二、安装部署" class="headerlink" title="二、安装部署"></a>二、安装部署</h3><ul><li>1.已经安装Elasticsearch</li><li>2.从<a href="https://www.elastic.co/downloads/kibana" target="_blank" rel="noopener">官网</a>下载解压(与ES相同的版本)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /hadoop/software</span><br><span class="line">wget https://artifacts.elastic.co/downloads/kibana/kibana-5.5.1-linux-x86_64.tar.gz</span><br><span class="line">tar -zxvf kibana-5.5.1-linux-x86_64.tar.gz -C /hadoop/install</span><br><span class="line">mv kibana-5.5.1-linux-x86_64 kibana</span><br></pre></td></tr></table></figure><ul><li>3.安装 x-pack</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kibana-plugin install x-pack</span><br></pre></td></tr></table></figure><ul><li>3.配置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /hadoop/install/kibana/</span><br><span class="line">vi config/kibana.yml</span><br><span class="line"></span><br><span class="line">添加内容：</span><br><span class="line">server.host: <span class="string">"master"</span></span><br><span class="line">elasticsearch.url: <span class="string">"http://master:9200"</span></span><br><span class="line">kibana.index: <span class="string">".kibana"</span></span><br></pre></td></tr></table></figure><ul><li>4.启动kibana</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先启动ES，必须是在root下运行，否则会报错，启动失败</span></span><br><span class="line">bin/kibana</span><br></pre></td></tr></table></figure><ul><li>5.访问：打开 <a href="http://localhost:5601" target="_blank" rel="noopener">http://localhost:5601</a> （默认的用户名：elastic，密码：changeme）</li></ul><p><img src="/image//ELK03/ELK03_001.png" alt=""></p><ul><li>6.修改密码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT -u elastic <span class="string">'localhost:9200/_xpack/security/user/kibana/_password'</span> -d <span class="string">'&#123;</span></span><br><span class="line"><span class="string">  "password" : "123456"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>7.单击侧面导航中的 Discover 进入 Kibana 的数据探索功能：</li></ul><p><img src="/image//ELK03/ELK03_002.png" alt=""></p><ul><li>8.使用查询栏编写语句查询</li></ul><p><img src="/image//ELK03/ELK03_003.png" alt=""></p><h3 id="三、加载自定义索引"><a href="#三、加载自定义索引" class="headerlink" title="三、加载自定义索引"></a>三、加载自定义索引</h3><ul><li>1.单击 Management 选项<br><img src="/image//ELK03/ELK03_004.png" alt=""></li><li>2.然后单击 Index Patterns 选项。<br><img src="/image//ELK03/ELK03_005.png" alt=""></li><li>3.点击Create index pattern定义一个新的索引模式。<br><img src="/image//ELK03/ELK03_006.png" alt=""></li><li>4.点击Next step<br><img src="/image//ELK03/ELK03_007.png" alt=""></li><li>5.点击Create index pattern<br><img src="/image//ELK03/ELK03_008.png" alt=""></li><li>6.出来如下界面，列出了所有index中的字段<br><img src="/image//ELK03/ELK03_009.png" alt=""></li><li>7.接下来，我们再来使用一下kibana查看已经导入的索引数据<br><img src="/image//ELK03/ELK03_010.png" alt=""><br><img src="/image//ELK03/ELK03_011.png" alt=""></li></ul><h3 id="四、搜索数据"><a href="#四、搜索数据" class="headerlink" title="四、搜索数据"></a>四、搜索数据</h3><p>　　左上方是 填入条件过滤，右上方是数据的时间范围，左侧栏是 搜索结果的展示字段（具体参考<a href="https://www.elastic.co/guide/cn/kibana/current/discover.html" target="_blank" rel="noopener">官方文档</a>）</p><p><img src="/image//ELK03/ELK03_012.png" alt=""></p><p>More info: <a href="https://www.cnblogs.com/chenqionghe/p/12503181.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">Kibana</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　Kibana 是一个针对Elasticsearch的开源分析及可视化平台，用来搜索、查看交互存储在Elasticsearch索引中的数据。使用 Kibana，可以通过各种图表进行高级数据分析及展示。&lt;br&gt;　　本文章主要介绍 Kibana 的入门知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="elk" scheme="https://lightalight.github.io/tags/elk/"/>
    
      <category term="kibana" scheme="https://lightalight.github.io/tags/kibana/"/>
    
  </entry>
  
  <entry>
    <title>ELK（二）Logstash</title>
    <link href="https://lightalight.github.io/2020/09/15/ELK02/"/>
    <id>https://lightalight.github.io/2020/09/15/ELK02/</id>
    <published>2020-09-15T11:23:32.000Z</published>
    <updated>2020-09-20T09:45:12.973Z</updated>
    
    <content type="html"><![CDATA[<p>　　Logstash 是一个开源数据收集引擎，具有实时管道功能。Logstash 可以动态地将来自不同数据源的数据统一起来，并将数据标准化到你所选择的目的地。<br>　　本文章主要介绍 Logstash 的入门知识。</p><a id="more"></a><h2 id="Quick-Guide"><a href="#Quick-Guide" class="headerlink" title="Quick Guide"></a>Quick Guide</h2><p>　　<strong>Logstash</strong>是一个开源的服务器端数据处理管道，可以同时从多个数据源获取数据，并对其进行转换，然后将其发送到你最喜欢的“存储”。（Elasticsearch）</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><h4 id="1-输入：采集各种样式、大小和来源的数据"><a href="#1-输入：采集各种样式、大小和来源的数据" class="headerlink" title="1.输入：采集各种样式、大小和来源的数据"></a>1.输入：采集各种样式、大小和来源的数据</h4><p>　　数据往往以各种各样的形式，或分散或集中地存在于很多系统中。Logstash 支持各种输入选择 ，可以在同一时间从众多常用来源捕捉事件。能够以连续的流式传输方式，轻松地从您的日志、指标、Web 应用、数据存储以及各种 AWS 服务采集数据。</p><p><img src="/image/ELK02/ELK02_001.png" alt=""></p><h4 id="2-过滤器：实时解析和转换数据"><a href="#2-过滤器：实时解析和转换数据" class="headerlink" title="2.过滤器：实时解析和转换数据"></a>2.过滤器：实时解析和转换数据</h4><p>　　数据从源传输到存储库的过程中，Logstash 过滤器能够解析各个事件，识别已命名的字段以构建结构，并将它们转换成通用格式，以便更轻松、更快速地分析和实现商业价值。Logstash 能够动态地转换和解析数据，不受格式或复杂度的影响：</p><ul><li>利用 Grok 从非结构化数据中派生出结构</li><li>从 IP 地址破译出地理坐标</li><li>将 PII 数据匿名化，完全排除敏感字段</li><li>整体处理不受数据源、格式或架构的影响</li></ul><p><img src="/image/ELK02/ELK02_002.png" alt=""></p><h4 id="3-输出：选择你的存储，导出你的数据"><a href="#3-输出：选择你的存储，导出你的数据" class="headerlink" title="3.输出：选择你的存储，导出你的数据"></a>3.输出：选择你的存储，导出你的数据</h4><p>　　尽管 Elasticsearch 是我们的首选输出方向，能够为我们的搜索和分析带来无限可能，但它并非唯一选择。<br>　　Logstash 提供众多输出选择，您可以将数据发送到您要指定的地方，并且能够灵活地解锁众多下游用例。</p><p><img src="/image/ELK02/ELK02_003.png" alt=""></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="1-前置"><a href="#1-前置" class="headerlink" title="1.前置"></a>1.前置</h4><p>安装 java 8 以上版本（包含）</p><h4 id="2-官网下载解压"><a href="#2-官网下载解压" class="headerlink" title="2.官网下载解压"></a>2.<a href="https://www.elastic.co/downloads/logstash" target="_blank" rel="noopener">官网</a>下载解压</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/logstash/logstash-5.6.1.tar.gz -o /hadoop/software</span><br><span class="line">tar -zxvf /hadoop/software/logstash-5.6.1.tar.gz -C /hadoop/install</span><br><span class="line">mv /hadoop/install/logstash-5.6.1 /hadoop/install/logstash</span><br></pre></td></tr></table></figure><h4 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h4><ul><li>1.简单输出到控制台</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cd</span> <span class="string">/hadoop/install/logstash</span></span><br><span class="line"><span class="string">bin/logstash</span> <span class="bullet">-e</span> <span class="string">'input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;'</span></span><br></pre></td></tr></table></figure><ul><li>2.新建配置文件：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi logstash.conf</span><br></pre></td></tr></table></figure><p>配置内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">input &#123; </span><br><span class="line">   file &#123;</span><br><span class="line">    <span class="built_in">type</span> =&gt; <span class="string">"server"</span></span><br><span class="line">    codec =&gt;json</span><br><span class="line">    <span class="comment">#读取文件的位置，一定准确，否则elasticsearch读取不到</span></span><br><span class="line">    path  =&gt;<span class="string">"/logs/finance/1.log</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string"> filter &#123;</span></span><br><span class="line"><span class="string">       grok &#123;</span></span><br><span class="line"><span class="string">              match =&gt; &#123; "</span>message<span class="string">" =&gt; "</span>^%&#123;TIMESTAMP_ISO8601&#125;<span class="string">" &#125;</span></span><br><span class="line"><span class="string">       &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">output &#123;</span></span><br><span class="line"><span class="string">  elasticsearch &#123; </span></span><br><span class="line"><span class="string">       hosts =&gt; ["</span>localhost:9200<span class="string">"]  #写入到elasticsearch中的地址信息</span></span><br><span class="line"><span class="string">   index =&gt; "</span>trace_test_log<span class="string">"    #文档索引</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>3.使用配置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/logstash -f logstash.conf</span><br></pre></td></tr></table></figure><ul><li>4.访问<a href="http://localhost:9600/" target="_blank" rel="noopener">http://localhost:9600/</a> </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　Logstash 是一个开源数据收集引擎，具有实时管道功能。Logstash 可以动态地将来自不同数据源的数据统一起来，并将数据标准化到你所选择的目的地。&lt;br&gt;　　本文章主要介绍 Logstash 的入门知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="elk" scheme="https://lightalight.github.io/tags/elk/"/>
    
      <category term="logstash" scheme="https://lightalight.github.io/tags/logstash/"/>
    
  </entry>
  
  <entry>
    <title>ELK（一）Elasticsearch</title>
    <link href="https://lightalight.github.io/2020/08/15/ELK01/"/>
    <id>https://lightalight.github.io/2020/08/15/ELK01/</id>
    <published>2020-08-15T11:23:32.000Z</published>
    <updated>2020-09-20T09:45:13.085Z</updated>
    
    <content type="html"><![CDATA[<p>　　Elasticsearch（ 数据搜索引擎持久化 ）、Logstash （ 数据收集 ） 、 Kibana （ 数据分析工具 ）的分析和可视化平台一起开发的。这三个产品被设计成一个集成解决方案，称为“Elastic Stack”（以前称为“ELK stack”）。<br>　　本文章主要介绍 Elasticsearch 的入门知识。</p><a id="more"></a><h2 id="Quick-Guide"><a href="#Quick-Guide" class="headerlink" title="Quick Guide"></a>Quick Guide</h2><p>  Elasticsearch是一个开源的分布式. RESTful 风格的搜索和数据分析引擎，它的底层是开源库Apache Lucene。<br>  <a href="https://lucene.apache.org/" target="_blank" rel="noopener">Lucene</a> 可以说是当下最先进. 高性能. 全功能的搜索引擎库——无论是开源还是私有，但它也仅仅只是一个库。为了充分发挥其功能，你需要使用 Java 把 Lucene 集成到应用程序中，使用比较复杂。<br>  为了解决Lucene使用时的繁复性，于是Elasticsearch便应运而生。它使用 Java 对Lucene 做了一层封装，提供了一套简单一致的 RESTful API 来帮助我们实现存储和检索。</p><h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><p>　　Elasticsearch 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。</p><table><thead><tr><th>关系型数据库（MySQL）</th><th>Elasticsearch</th></tr></thead><tbody><tr><td>数据库database</td><td>索引 index</td></tr><tr><td>表 table</td><td>类型 type</td></tr><tr><td>数据行 row</td><td>文档 document</td></tr><tr><td>数据列 column</td><td>字段 field</td></tr></tbody></table><p>　　Elasticsearch 的文件存储是面向文档型数据库，一条数据在这里就是一个文档，用JSON作为文档序列化的格式，比如下面这条用户数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span> :     <span class="string">"John"</span>,</span><br><span class="line">    <span class="attr">"sex"</span> :      <span class="string">"Male"</span>,</span><br><span class="line">    <span class="attr">"age"</span> :      <span class="number">25</span>,</span><br><span class="line">    <span class="attr">"birthDate"</span>: <span class="string">"1990/05/01"</span>,</span><br><span class="line">    <span class="attr">"about"</span> :    <span class="string">"I love to go rock climbing"</span>,</span><br><span class="line">    <span class="attr">"interests"</span>: [ <span class="string">"sports"</span>, <span class="string">"music"</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　用Mysql这样的数据库存储就会容易想到建立一张User表，有name、sex等字段，在 Elasticsearch 里这就是一个属于User的类型，各种各样的类型存在于一个索引当中。<br>　　一个 Elasticsearch 集群可以包含多个索引(数据库)，也就是说其中包含了很多类型(表)。这些类型中包含了很多的文档(行)，然后每个文档中又包含了很多的字段(列)。Elasticsearch的交互，可以使用Java API，也可以直接使用HTTP的Restful API方式。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 插入一条记录，可以简单发送一个HTTP的请求</span><br><span class="line">PUT /megacorp/employee/1  ( /&lt;索引名称&gt;/&lt;类型名称&gt;/&lt;指定id&gt; )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span> :     <span class="string">"John"</span>,</span><br><span class="line">    <span class="attr">"sex"</span> :      <span class="string">"Male"</span>,</span><br><span class="line">    <span class="attr">"age"</span> :      <span class="number">25</span>,</span><br><span class="line">    <span class="attr">"about"</span> :    <span class="string">"I love to go rock climbing"</span>,</span><br><span class="line">    <span class="attr">"interests"</span>: [ <span class="string">"sports"</span>, <span class="string">"music"</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新、查询也是类似这样的操作，具体操作手册可以参考 <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html" target="_blank" rel="noopener">Elasticsearch权威指南</a></p><h3 id="二、Elasticsearch-模块结构"><a href="#二、Elasticsearch-模块结构" class="headerlink" title="二、Elasticsearch 模块结构"></a>二、Elasticsearch 模块结构</h3><p><img src="/image/ELK01/ELK01_001.png" alt=""></p><ol><li>第一层：Gateway层：Elasticsearch  索引的持久化存储方式 。 ElasticSearch 默认先把索引存储在内存中，然后当内存满的时候，再持久化到Gateway里。当ES集群关闭或重启的时候，它就会从Gateway里去读取索引数据。比如LocalFileSystem和HDFS、AS3等。 </li><li>第二层：Distributed lucene directory层： Lucene里的一些列索引文件组成的目录。它负责管理这些索引文件。包括数据的读取、写入，以及索引的添加和合并等。 </li><li>第三层：Elasticsearch 对数据的加工处理方式，mapping：定义索引下面type字段的处理规则，比如：索引如何建立数据类型等等，相当于关系型数据里面的schema。River是一个运行在 Elasticsearch 集群内部的一个插件，主要是用来从外部获取异构数据，然后在 Elasticsearch 里创建索引，常见的插件有rabbitmq. twitter river。</li><li>第四层：是 Elasticsearch 自动发现节点的机制。Zen是用来实现节点自动发现，还有master节点选取用的，假如maste出现了故障，不能工作了，那么其它节点会自动选举，然后产生一个新的master。Elasticsearch 是基于P2P的系统，它首先头通过广播机制寻找存在的节点，然后再通过多播协议来进行节点间的通信，同时也支持点对点交互。</li><li>第五层：是 Elasticsearch 的脚本执行功能，有了这个功能很方便的对查询出来的数据进行加工处理，脚本类型：mvel. js. python等。</li><li>第六层：3rd plugins：意思是 Elasticsearch 支持安装很多第三方插件。</li><li>第七层：是 Elasticsearch 的交互方式，支持三种协议：thrift. memcached. http，其中 Elasticsearch 是默认用http协议传输的。</li><li>Restful Style API：是 Elasticsearch 的API支持模式，现在这个RESTFUL这样的API接口的标准是非常流行的</li><li>java(Netty)：Elasticsearch 采用了java语言，同时java语言也是对 Elasticsearch 支持度最好的语言，因为这个lucene是基于java开发的。</li></ol><h3 id="三、安装部署"><a href="#三、安装部署" class="headerlink" title="三、安装部署"></a>三、安装部署</h3><ul><li><p>0.安装 java 8 以上版本（包含）</p></li><li><p>1.下载安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.5.1.zip</span><br><span class="line">unzip elasticsearch-5.5.1.zip</span><br><span class="line">cd elasticsearch-5.5.1/</span><br></pre></td></tr></table></figure></li><li><p>2.启动 Elasticsearch</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch</span><br></pre></td></tr></table></figure><p><strong>如果这时报错”max virtual memory areas vm.maxmapcount [65530] is too low”，要运行命令（ sudo sysctl -w vm.max_map_count=262144 ）。</strong></p><ul><li>3.验证</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl localhost:9200</span><br></pre></td></tr></table></figure><h3 id="四、使用"><a href="#四、使用" class="headerlink" title="四、使用"></a>四、使用</h3><p>　　Elasticsearch提供了多种交互使用方式，包括Java API和RESTful API 。现在主要介绍RESTful API ，所有其他语言可以使用RESTful API 通过端口 9200 和 Elasticsearch 进行通信，你可以用你最喜爱的 web 客户端访问 Elasticsearch ，也可以使用 curl 命令来和 Elasticsearch 交互。<br>　　一个Elasticsearch请求和任何 HTTP 请求一样，都由若干相同的部件组成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X &lt;VERB&gt;  <span class="string">'&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;'</span>  -d  <span class="string">'&lt;BODY&gt;'</span></span><br></pre></td></tr></table></figure><p>　　返回的数据格式为JSON，因为Elasticsearch中的文档以JSON格式储存。其中被 &lt; &gt; 标记的部件：</p><table><thead><tr><th>部件</th><th>说明</th></tr></thead><tbody><tr><td>VERB</td><td>适当的 HTTP <em>方法</em> 或 <em>谓词</em> : <code>GET</code>、 <code>POST</code>、 <code>PUT</code>、 <code>HEAD</code> 或者 <code>DELETE</code>。</td></tr><tr><td>PROTOCOL</td><td><code>http</code> 或者 <code>https</code>（如果你在 Elasticsearch 前面有一个 <code>https</code> 代理）</td></tr><tr><td>HOST</td><td>Elasticsearch 集群中任意节点的主机名，或者用 <code>localhost</code> 代表本地机器上的节点。</td></tr><tr><td>PORT</td><td>运行 Elasticsearch HTTP 服务的端口号，默认是 <code>9200</code> 。</td></tr><tr><td>PATH</td><td>API 的终端路径（例如 <code>_count</code> 将返回集群中文档数量）。Path 可能包含多个组件，例如：<code>_cluster/stats</code> 和 <code>_nodes/stats/jvm</code> 。</td></tr><tr><td>QUERY_STRING</td><td>任意可选的查询字符串参数 (例如 <code>?pretty</code> 将格式化地输出 JSON 返回值，使其更容易阅读)</td></tr><tr><td>BODY</td><td>一个 JSON 格式的请求体 (如果请求需要的话)</td></tr></tbody></table><h4 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1.基本操作"></a>1.基本操作</h4><ul><li><p>1.插入数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT <span class="string">'localhost:9200/&lt;index_name&gt;/&lt;type_name&gt;/&lt;id&gt;'</span>  -d <span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  "user": "xiaoming",</span></span><br><span class="line"><span class="string">  "position": "engineer"</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure></li><li><p>2.删除数据</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X DELETE <span class="string">'localhost:9200/&lt;index_name&gt;/&lt;type_name&gt;/&lt;id&gt;'</span></span><br></pre></td></tr></table></figure><ul><li><p>3.修改数据（使用插入方式也可以修改数据）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST <span class="string">'localhost:9200/&lt;index_name&gt;/&lt;type_name&gt;/&lt;id&gt;/_update'</span>  -d <span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  "user": "daming",</span></span><br><span class="line"><span class="string">  "position": "engineer"</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure></li><li><p>4.查询数据</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pretty 代表易读格式</span></span><br><span class="line">curl -X GET <span class="string">'localhost:9200/&lt;index_name&gt;/&lt;type_name&gt;/&lt;id&gt;?pretty=true'</span></span><br></pre></td></tr></table></figure><h4 id="2-高级查询"><a href="#2-高级查询" class="headerlink" title="2.高级查询"></a>2.高级查询</h4><ul><li><p>1.返回所有记录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET <span class="string">'localhost:9200/&lt;index_name&gt;/&lt;type_name&gt;/_search'</span></span><br></pre></td></tr></table></figure></li><li><p>2.条件搜索</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询user等于daming的记录，每次从位置1开始（默认是从位置0开始），只返回一条结果。</span></span><br><span class="line">curl <span class="string">'localhost:9200/&lt;index_name&gt;/&lt;type_name&gt;/_search'</span>  -d <span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  "query" : &#123; "match" : &#123; "user" : "daming" &#125;&#125;,</span></span><br><span class="line"><span class="string">  "size": 1,</span></span><br><span class="line"><span class="string">  "from": 1,</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询user等于daming或者xiaoming的记录</span></span><br><span class="line">curl <span class="string">'localhost:9200/&lt;index_name&gt;/&lt;type_name&gt;/_search'</span>  -d <span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  "query" : &#123; "match" : &#123; "user" : "daming xiaoming" &#125;&#125;,</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询user等于daming且position等于engineer的记录</span></span><br><span class="line">curl <span class="string">'localhost:9200/&lt;index_name&gt;/&lt;type_name&gt;/_search'</span>  -d <span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  "query": &#123;</span></span><br><span class="line"><span class="string">    "bool": &#123;</span></span><br><span class="line"><span class="string">      "must": [</span></span><br><span class="line"><span class="string">        &#123; "match": &#123; "user": "daming" &#125; &#125;,</span></span><br><span class="line"><span class="string">        &#123; "match": &#123; "position": "engineer" &#125; &#125;</span></span><br><span class="line"><span class="string">      ]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started.html" target="_blank" rel="noopener">ElasticSearch 官方手册</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　Elasticsearch（ 数据搜索引擎持久化 ）、Logstash （ 数据收集 ） 、 Kibana （ 数据分析工具 ）的分析和可视化平台一起开发的。这三个产品被设计成一个集成解决方案，称为“Elastic Stack”（以前称为“ELK stack”）。&lt;br&gt;　　本文章主要介绍 Elasticsearch 的入门知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="elk" scheme="https://lightalight.github.io/tags/elk/"/>
    
      <category term="elasticsearch" scheme="https://lightalight.github.io/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>大数据（十六）Hue</title>
    <link href="https://lightalight.github.io/2020/07/15/%E5%A4%A7%E6%95%B0%E6%8D%AE16/"/>
    <id>https://lightalight.github.io/2020/07/15/大数据16/</id>
    <published>2020-07-15T11:23:32.000Z</published>
    <updated>2020-09-20T09:51:24.255Z</updated>
    
    <content type="html"><![CDATA[<p>Hue （Hadoop User Experience Hadoop用户体验）是一个开源的 Apache Hadoop UI系统，由Cloudera Desktop演化而来，最后Cloudera公司将其贡献给Apache基金会的Hadoop社区，它是基于Python Web框架Django实现的。通过使用HUE我们可以在浏览器端的Web控制台上与Hadoop集群进行交互，来分析处理数据。</p><p>本文章主要介绍 Hue 和 在centos环境下如何安装 。</p><a id="more"></a><h2 id="Quick-Guide"><a href="#Quick-Guide" class="headerlink" title="Quick Guide"></a>Quick Guide</h2><h3 id="一、用途"><a href="#一、用途" class="headerlink" title="一、用途"></a>一、用途</h3><ul><li>访问HDFS和文件浏览</li><li>通过web调试和开发hive以及数据结果展示</li><li>查询solr和结果展示，报表生成</li><li>通过web调试和开发impala交互式SQL Query</li><li>spark调试和开发</li><li>Pig开发和调试</li><li>oozie任务的开发，监控，和工作流协调调度</li><li>Hbase数据查询和修改，数据展示</li><li>Hive的元数据（metastore）查询</li><li>MapReduce任务进度查看，日志追踪</li><li>创建和提交MapReduce，Streaming，Java job任务</li><li>Sqoop2的开发和调试</li><li>Zookeeper的浏览和编辑</li><li>数据库（MySQL，PostGres，SQlite，Oracle）的查询和展示</li></ul><h3 id="二、架构"><a href="#二、架构" class="headerlink" title="二、架构"></a>二、架构</h3><p>从总体上来讲，Hue应用采用的是B/S架构，该web应用的后台采用python编程语言别写的。大体上可以分为三层，分别是前端view层、Web服务层和Backend服务层。Web服务层和Backend服务层之间使用RPC的方式调用。</p><p><img src="/image/大数据16/大数据16_001.png" alt=""></p><h3 id="三、安装"><a href="#三、安装" class="headerlink" title="三、安装"></a>三、安装</h3><h4 id="1-前置"><a href="#1-前置" class="headerlink" title="1.前置"></a>1.前置</h4><ul><li>1.安装 <code>python</code> 和 <code>maven</code></li><li>2.安装 <code>hadoop</code> 和 <code>hive</code> </li><li>3.创建应用类服务专有用户</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -g hadoop hue</span><br></pre></td></tr></table></figure><ul><li>4.安装依赖包</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install ant asciidoc cyrus-sasl-devel cyrus-sasl-gssapi gcc gcc-c++ krb5-devel libtidy libxml2-devel libxslt-devel openldap-devel python-devel sqlite-devel openssl-devel mysql-devel gmp-devel</span><br></pre></td></tr></table></figure><h4 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h4><ul><li>2.1.下载安装包(<a href="http://gethue.com" target="_blank" rel="noopener">官网</a>或者github)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yum install git -y</span><br><span class="line"><span class="built_in">cd</span> /hadoop/install</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/cloudera/hue.git branch-4.7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名</span></span><br><span class="line">mv branch-4.7 hue</span><br></pre></td></tr></table></figure><ul><li><p>2.2.切换用户 hue</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown -R  hue:hadoop hue</span><br><span class="line">su hue</span><br></pre></td></tr></table></figure></li><li><p>2.3.编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> hue</span><br><span class="line">make apps</span><br></pre></td></tr></table></figure></li><li><p>2.4.修改 <code>/usr/local/hue/desktop/conf/pseudo-distributed.ini</code></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[desktop]</span><br><span class="line">    # 安全秘钥，存储session的加密处理</span><br><span class="line">    secret_key=dfsahjfhflsajdhfljahl</span><br><span class="line">    # Time zone name</span><br><span class="line">    time_zone=Asia/Shanghai</span><br><span class="line">    # Enable or disable debug mode.</span><br><span class="line">    django_debug_mode=false</span><br><span class="line">    # Enable or disable backtrace for server error</span><br><span class="line">    http_500_debug_mode=false</span><br><span class="line">    # This should be the hadoop cluster admin</span><br><span class="line">    ## default_hdfs_superuser=hdfs</span><br><span class="line">    default_hdfs_superuser=root</span><br><span class="line">    # 不启用的模块</span><br><span class="line">    # app_blacklist=impala,security,rdbms,jobsub,pig,hbase,sqoop,zookeeper,metastore,indexer</span><br><span class="line">[[database]]</span><br><span class="line">       # 数据库引擎类型</span><br><span class="line">       engine=mysql</span><br><span class="line">       # 数据库主机地址</span><br><span class="line">       host=master</span><br><span class="line">       # 数据库端口</span><br><span class="line">       port=3306</span><br><span class="line">       # 数据库用户名</span><br><span class="line">       user=root</span><br><span class="line">       # 数据库密码</span><br><span class="line">       password=123456</span><br><span class="line">       # 数据库库名</span><br><span class="line">       name=hue</span><br></pre></td></tr></table></figure><h4 id="3-hue集成hadoop"><a href="#3-hue集成hadoop" class="headerlink" title="3.hue集成hadoop"></a>3.hue集成hadoop</h4><ul><li>3.1.修改配置文件，增加代理用户hue<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi <span class="variable">$HADOOP_HOME</span>/etc/hadoop/core-site.xml</span><br></pre></td></tr></table></figure></li></ul><p>新增内容：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.proxyuser.hue.hosts<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>*<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.proxyuser.hue.groups<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>*<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>3.2.配置hue:修改 desktop/conf/pseudo-distributed.ini文件</li></ul><p>修改标签 <code>[[hdfs_clusters]]</code> 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[hadoop]</span><br><span class="line"></span><br><span class="line">  # Configuration for HDFS NameNode</span><br><span class="line">  # ------------------------------------------------------------------------</span><br><span class="line">  [[hdfs_clusters]]</span><br><span class="line">    # HA support by using HttpFs</span><br><span class="line"></span><br><span class="line">    [[[default]]]</span><br><span class="line">      # Enter the filesystem uri</span><br><span class="line">      fs_defaultfs=hdfs://master:54310</span><br><span class="line"></span><br><span class="line">      # NameNode logical name.</span><br><span class="line">      logical_name=master</span><br><span class="line"></span><br><span class="line">      # Use WebHdfs/HttpFs as the communication mechanism.</span><br><span class="line">      # Domain should be the NameNode or HttpFs host.</span><br><span class="line">      # Default port is 14000 for HttpFs.</span><br><span class="line">      ## webhdfs_url=http://localhost:50070/webhdfs/v1</span><br><span class="line">      webhdfs_url=http://master:9870/webhdfs/v1</span><br><span class="line"></span><br><span class="line">      # Change this if your HDFS cluster is Kerberos-secured</span><br><span class="line">      ## security_enabled=false</span><br><span class="line"></span><br><span class="line">      # In secure mode (HTTPS), if SSL certificates from YARN Rest APIs</span><br><span class="line">      # have to be verified against certificate authority</span><br><span class="line">      ## ssl_cert_ca_verify=True</span><br><span class="line"></span><br><span class="line">      # Directory of the Hadoop configuration</span><br><span class="line">      ## hadoop_conf_dir=$HADOOP_CONF_DIR when set or &apos;/etc/hadoop/conf&apos;</span><br><span class="line">      hadoop_conf_dir=$HADOOP_CONF_DIR</span><br></pre></td></tr></table></figure></p><p>修改标签 <code>[[yarn_clusters]]</code> 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># Configuration for YARN (MR2)</span><br><span class="line">  # ------------------------------------------------------------------------</span><br><span class="line">  [[yarn_clusters]]</span><br><span class="line"></span><br><span class="line">    [[[default]]]</span><br><span class="line">      # Enter the host on which you are running the ResourceManager</span><br><span class="line">      ## resourcemanager_host=localhost</span><br><span class="line">      resourcemanager_host=master</span><br><span class="line"></span><br><span class="line">      # The port where the ResourceManager IPC listens on</span><br><span class="line">      ## resourcemanager_port=8032</span><br><span class="line"></span><br><span class="line">      # Whether to submit jobs to this cluster</span><br><span class="line">      submit_to=True</span><br><span class="line"></span><br><span class="line">      # Resource Manager logical name (required for HA)</span><br><span class="line">      ## logical_name=</span><br><span class="line"></span><br><span class="line">      # Change this if your YARN cluster is Kerberos-secured</span><br><span class="line">      ## security_enabled=false</span><br><span class="line"></span><br><span class="line">      # URL of the ResourceManager API</span><br><span class="line">      ## resourcemanager_api_url=http://localhost:8088</span><br><span class="line">      resourcemanager_api_url=http://master:8088</span><br><span class="line"></span><br><span class="line">      # URL of the ProxyServer API</span><br><span class="line">      ## proxy_api_url=http://localhost:8088</span><br><span class="line">      proxy_api_url=http://master:8088</span><br><span class="line"></span><br><span class="line">      # URL of the HistoryServer API</span><br><span class="line">      ## history_server_api_url=http://localhost:19888</span><br><span class="line">      history_server_api_url=http://master:19888</span><br><span class="line"></span><br><span class="line">      # URL of the Spark History Server</span><br><span class="line">      ## spark_history_server_url=http://localhost:18088</span><br><span class="line">      spark_history_server_url=http://master:18080</span><br><span class="line"></span><br><span class="line">      # Change this if your Spark History Server is Kerberos-secured</span><br><span class="line">      ## spark_history_server_security_enabled=false</span><br><span class="line"></span><br><span class="line">      # In secure mode (HTTPS), if SSL certificates from YARN Rest APIs</span><br><span class="line">      # have to be verified against certificate authority</span><br><span class="line">      ## ssl_cert_ca_verify=True</span><br></pre></td></tr></table></figure></p><h4 id="4-hue集成hive配置"><a href="#4-hue集成hive配置" class="headerlink" title="4.hue集成hive配置"></a>4.hue集成hive配置</h4><ul><li><p>4.1.拷贝配置 <code>hive-site.xml</code> 到目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/<span class="built_in">local</span>/hue/hive/conf</span><br><span class="line">cp /hadoop/install/apache-hive-3.1.2/conf/hive-site.xml /usr/<span class="built_in">local</span>/hue/hive</span><br><span class="line">/conf/</span><br></pre></td></tr></table></figure></li><li><p>4.2.修改<code>desktop/conf/pseudo-distributed.ini</code>的标签<code>[beeswax]</code></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[beeswax]</span><br><span class="line">    # hiveServer2 服务地址(填主机名，kerberos要用)</span><br><span class="line">    hive_server_host=master</span><br><span class="line">    # hiveServer2服务端口</span><br><span class="line">    hive_server_port=10000</span><br><span class="line">    # hiveServer2 hive-site.xml配置文件存放位置</span><br><span class="line">    hive_conf_dir=/usr/local/hue/hive/conf</span><br></pre></td></tr></table></figure><h4 id="5-hue集成spark配置"><a href="#5-hue集成spark配置" class="headerlink" title="5.hue集成spark配置"></a>5.hue集成spark配置</h4><ul><li><p>5.1.启动spark的thrift server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /hadoop/install/spark/sbin</span><br><span class="line">start-thriftserver.sh --master yarn --deploy-mode client</span><br></pre></td></tr></table></figure></li><li><p>5.2.安装livy</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /hadoop/software</span><br><span class="line">wget http://livy.incubator.apache.org/download/apache-livy-0.6.0-incubating-bin</span><br><span class="line">.zip</span><br><span class="line">unzip apache-livy-0.6.0-incubating-bin.zip -C </span><br><span class="line">mv apache-livy-0.6.0-incubating-bin /hadoop/install/livy-0.6.0</span><br></pre></td></tr></table></figure></li><li><p>5.3.创建livy的 <code>livy-env.sh</code> 配置文件和<code>log</code>目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd livy-0.6.0/conf/</span><br><span class="line">cp livy-env.sh.template livy-env.sh</span><br><span class="line">mkdir -p /data/livy/logs</span><br></pre></td></tr></table></figure></li><li><p>5.4.在 <code>livy-env.sh</code> 新建配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export HADOOP_CONF_DIR=/hadoop/install/hadoop/etc/hadoop</span><br><span class="line">export SPARK_HOME=/hadoop/install/spark</span><br><span class="line">export LIVY_LOG_DIR=/data/livy/logs</span><br><span class="line">export LIVY_PID_DIR=/data/livy/pid</span><br></pre></td></tr></table></figure></li><li><p>5.5.配置 <code>livy.conf</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp livy.conf.template livy.conf</span><br></pre></td></tr></table></figure></li><li><p>5.6.在<code>livy.conf</code>文件中加入以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># What port to start the server on.</span><br><span class="line">livy.server.port = 8998</span><br><span class="line"># What spark master Livy sessions should use.</span><br><span class="line">livy.spark.master = yarn</span><br><span class="line"># What spark deploy mode Livy sessions should use.</span><br><span class="line">livy.spark.deploy-mode = client</span><br></pre></td></tr></table></figure></li><li><p>5.7.启动livy</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/hadoop/install/livy-0.6.0/bin/livy-server start</span><br></pre></td></tr></table></figure></li><li><p>5.8.修改 <code>desktop/conf/pseudo-distributed.ini</code> 文件的标签<code>[spark]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">###########################################################################</span><br><span class="line"># Settings to configure the Spark application.</span><br><span class="line">###########################################################################</span><br><span class="line"></span><br><span class="line">[spark]</span><br><span class="line">  # The Livy Server URL.</span><br><span class="line">  ## livy_server_url=http://localhost:8998</span><br><span class="line">  livy_server_url=http://master:8998</span><br><span class="line"></span><br><span class="line">  # Configure Livy to start in local &apos;process&apos; mode, or &apos;yarn&apos; workers.</span><br><span class="line">  ## livy_server_session_kind=yarn</span><br><span class="line">  livy_server_session_kind=yarn</span><br><span class="line"></span><br><span class="line">  # Whether Livy requires client to perform Kerberos authentication.</span><br><span class="line">  ## security_enabled=false</span><br><span class="line"></span><br><span class="line">  # Whether Livy requires client to use csrf protection.</span><br><span class="line">  ## csrf_enabled=false</span><br><span class="line"></span><br><span class="line">  # Host of the Sql Server</span><br><span class="line">  ## sql_server_host=localhost</span><br><span class="line">  sql_server_host=master</span><br><span class="line"></span><br><span class="line">  # Port of the Sql Server</span><br><span class="line">  ## sql_server_port=10000</span><br><span class="line">  sql_server_port=10000</span><br><span class="line"></span><br><span class="line">  # Choose whether Hue should validate certificates received from the server.</span><br><span class="line">  ## ssl_cert_ca_verify=true</span><br><span class="line"></span><br><span class="line">###########################################################################</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-MySql初始化"><a href="#6-MySql初始化" class="headerlink" title="6.MySql初始化"></a>6.MySql初始化</h4><ul><li><p>1.建一个名为hue的库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登录mysql数据库</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"><span class="comment"># 创建数据库hue</span></span><br><span class="line">create database hue;</span><br><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line">create user <span class="string">'hue'</span>@<span class="string">'%'</span> identified by <span class="string">'123456'</span>;</span><br><span class="line"><span class="comment"># 授权</span></span><br><span class="line">grant all privileges on hue.* to <span class="string">'hue'</span>@<span class="string">'%'</span>;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure></li><li><p>2.生成表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">build/env/bin/hue syncdb</span><br><span class="line">build/env/bin/hue migrate</span><br></pre></td></tr></table></figure></li></ul><h4 id="7-启动hue"><a href="#7-启动hue" class="headerlink" title="7.启动hue"></a>7.启动hue</h4><ol><li>启动hue<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/env/bin/supervisor &amp;</span><br></pre></td></tr></table></figure></li></ol><ul><li>2.验证:访问 <a href="http://master:8000" target="_blank" rel="noopener">http://master:8000</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hue （Hadoop User Experience Hadoop用户体验）是一个开源的 Apache Hadoop UI系统，由Cloudera Desktop演化而来，最后Cloudera公司将其贡献给Apache基金会的Hadoop社区，它是基于Python Web框架Django实现的。通过使用HUE我们可以在浏览器端的Web控制台上与Hadoop集群进行交互，来分析处理数据。&lt;/p&gt;
&lt;p&gt;本文章主要介绍 Hue 和 在centos环境下如何安装 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="大数据" scheme="https://lightalight.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="hue" scheme="https://lightalight.github.io/tags/hue/"/>
    
  </entry>
  
  <entry>
    <title>大数据（十五）Flink</title>
    <link href="https://lightalight.github.io/2020/06/15/%E5%A4%A7%E6%95%B0%E6%8D%AE15/"/>
    <id>https://lightalight.github.io/2020/06/15/大数据15/</id>
    <published>2020-06-15T11:23:32.000Z</published>
    <updated>2020-09-20T09:51:24.417Z</updated>
    
    <content type="html"><![CDATA[<p>这几年大数据的飞速发展，出现了很多热门的开源社区，其中著名的有 Hadoop、Storm，以及后来的 Spark，他们都有着各自专注的应用场景。</p><p>Spark 掀开了内存计算的先河，也以内存为赌注，赢得了内存计算的飞速发展。Spark 的火热地掩盖了其他分布式计算的系统身影，例如 Flink在这个时候默默地发展着。在国外一些社区，有很多人将大数据的计算引擎分成了 4 代，当然也有很多人不会认同,我们先姑且这么认为和讨论。</p><p>首先第一代的计算引擎，无疑就是 Hadoop 承载的 MapReduce。这里大家应该都不会对 MapReduce 陌生，它将计算分为两个阶段，分别为 Map 和 Reduce。对于上层应用来说，就不得不想方设法去拆分算法，甚至于不得不在上层应用实现多个 Job 的串联，以完成一个完整的算法，例如迭代计算。<br>由于这样的弊端，催生了支持 DAG 框架的产生,因此支持 DAG 的框架被划分为第二代计算引擎，如 Tez 以及更上层的 Oozie。这里我们不去细究各种 DAG 实现之间的区别，不过对于当时的 Tez 和 Oozie 来说，大多还是批处理的任务。</p><p>接下来就是以 Spark 为代表的第三代的计算引擎。第三代计算引擎的特点主要是 Job 内部的 DAG 支持（不跨越 Job），以及强调的实时计算。在这里，很多人也会认为第三代计算引擎也能够很好的运行批处理的 Job。随着第三代计算引擎的出现，促进了上层应用快速发展，例如各种迭代计算的性能以及对流计算和 SQL 等的支持。Flink 的诞生就被归在了第四代。这应该主要表现在 Flink 对流计算的支持，以及更一步的实时性上面。当然 Flink 也可以支持 Batch 的任务，以及 DAG 的运算。</p><p>本文章主要介绍 Flink 和 在centos环境下如何安装 。</p><a id="more"></a><h2 id="Quick-Guide"><a href="#Quick-Guide" class="headerlink" title="Quick Guide"></a>Quick Guide</h2><h3 id="Flink-介绍"><a href="#Flink-介绍" class="headerlink" title="Flink 介绍"></a>Flink 介绍</h3><p>Apache Flink是一个框架和分布式处理引擎，用于对无界和有界数据流进行有状态计算。Flink设计为在所有常见的集群环境中运行，以内存速度和任何规模执行计算。</p><h4 id="1-批处理和流处理"><a href="#1-批处理和流处理" class="headerlink" title="1. 批处理和流处理"></a>1. 批处理和流处理</h4><p>数据集分为有界数据集和无界数据集：</p><ul><li>有界数据集：有界数据流就是指输入的数据有始有终。例如数据可能是一分钟或者一天的交易数据等等。处理这种有界数据流的方式也被称之为批处理；</li><li>无界数据集：有界数据流就是指有始无终的数据，数据一旦开始生成就会持续不断的产生新的数据，即数据没有时间边界源源不断（比如日志），处理这种有界数据流的方式也被称之为流处理。</li></ul><p><strong>我们一般所说的数据流是指数据集，而流数据则是指数据流中的数据。流处理更复杂，因为需要考虑到数据的顺序错乱和系统容错等。</strong></p><p><img src="/image/大数据15/大数据15_001.png" alt=""></p><h4 id="二、架构的演变"><a href="#二、架构的演变" class="headerlink" title="二、架构的演变"></a>二、架构的演变</h4><ul><li>1.传统单体数据架构<br>传统单体数据架构中，数据集中存储，架构分成计算层和存储层。这种架构初期效率很高，但是随着 业务种类越来越多，系统越来越难以维护升级，此外 database 是唯一准确的数据源，每个 application 都需要访问 database 来获取对应的数据，一旦 database 发生改变或者出现问题，将会对整个业务系统产生影响。</li></ul><p><img src="/image/大数据15/大数据15_002.png" alt=""></p><ul><li>2.微服务架构<br>微服务架构的核心是：1个 application 由多个小的且相互独立的微型服务组成，各服务的开发和发布不存在依赖关系，这样整个系统相比于之前的传统单体数据架构就更加灵活。</li></ul><p><img src="/image/大数据15/大数据15_003.png" alt=""></p><ul><li>3.大数据 lambada 架构<br>lambada 架构分两种处理途径，Speed layer 负责批处理（比如 Hadoop MapReduce），Batch layer 则负责流处理（比如 Storm）。这种架构存在问题：框架较多会导致平台复杂度高、运维成本高。虽说后面 Spark 框架能够同时支持批计算和流计算，但是Spark Streaming 的流计算本质上依旧是微批处理并非实时流计算。</li></ul><p><img src="/image/大数据15/大数据15_004.png" alt=""></p><ul><li><p>4.Flink</p><p>相比于 Spark Streaming的微批处理模式，Flink 通过 Google Dataflow 模型实现了实时流计算框架，<strong>将有界数据集转换成无界数据集统一进行流式处理</strong>。Flink 具有如下优势：</p><ul><li>流处理特性<ul><li><strong>高吞吐、低延时、高性能</strong>；</li><li>支持事件时间（Event Time）概念：大多数框架中<strong>窗口计算</strong>采用<strong>系统时间</strong>（即Event 到达计算框架是 host 的当前时刻），而 Flink 则能够基于<strong>事件时间</strong>（即 Event 本身产生的时刻，当然也可以基于其他类型）语义进行窗口计算。基于事件驱动的优势在于即使 Event 到达的顺序乱了，框架也能够准确知道<strong>事件的时序性</strong>；</li><li>支持高度灵活的窗口计算操作：流处理中，数据就像stream 一样源源不断地进入到框架中进行处理。有时需要通过窗口的方式对 stream 进行一定范围内的聚合计算。比如统计某网页在过去1分钟内的点击数。这种情况下就需要定义一个窗口，收集最近1分钟内的数据，并对这些数据进行计算。Flink 的窗口计算包括Time、Count、Session、Data-driven 等类型的窗口操作，可以灵活使用<strong>触发条件定制化来达到复杂的计算需求</strong>；</li><li>基于轻量级分布式<strong>快照（Snapshot）实现容错</strong>机制：Flink 可以分布运行在多达上千个节点上，将一个大型计算任务流程分解成多个小的计算stage，再分布到节点上并行处理。任务执行过程中，分布式Snapshot（通过 Save points 实现） 的 Checkpoints能够将状态信息进行持久化到存储介质中（比如磁盘），一旦某些任务出现异常，就能够<strong>从Checkpoints 中恢复任务</strong>，从而确保数据处理过程中的一致性；</li><li>基于 JVM 实现独立的内存管理：大数据处理中内存管理是非常重要的部分，Flink 实现了<strong>自身管理内存</strong>的机制，且通过 <strong>序列化/反序列化</strong>方法将所有数据对象转换成二进制存储在内存中，降低数据存储 size 的同时，更高效地利用内存，<strong>降低 JVM GC 对框架性能的影响</strong>。</li></ul></li><li>API支持<ul><li>对Streaming数据类应用，提供DataStream API</li><li>对批处理类应用，提供DataSet API（支持Java/Scala）</li></ul></li><li>Libraries支持<ul><li>支持机器学习（FlinkML）</li><li>支持图分析（Gelly）</li><li>支持关系数据处理（Table）</li><li>支持复杂事件处理（CEP）</li></ul></li><li>整合支持<ul><li>支持Flink on YARN</li><li>支持HDFS</li><li>支持来自Kafka的输入数据</li><li>支持Apache HBase</li><li>支持Hadoop程序</li><li>支持Tachyon</li><li>支持ElasticSearch</li><li>支持RabbitMQ</li><li>支持Apache Storm</li><li>支持S3</li><li>支持XtreemFS</li></ul></li><li>生态圈<br><img src="/image/大数据15/大数据15_005.png" alt=""></li></ul></li></ul><h3 id="三、Flink应用场景"><a href="#三、Flink应用场景" class="headerlink" title="三、Flink应用场景"></a>三、Flink应用场景</h3><ul><li>实时智能推荐；</li><li>复杂事件处理；</li><li>实时欺诈检测；</li><li>实时数仓与 ETL；</li><li>流数据分析；</li><li>实时报表分析。</li></ul><h3 id="四、Flink运行架构"><a href="#四、Flink运行架构" class="headerlink" title="四、Flink运行架构"></a>四、Flink运行架构</h3><ul><li><p>1.术语</p><ul><li><strong>Client</strong>：用来提交任务给 JobManage</li><li><strong>JobManager（指挥者，JVM 进程）</strong>：JobManagers是在Flink主服务器中运行的组件之一。用于任务调度（分发任务给 TaskManager 去执行）、协调检查点和协调故障恢复；</li><li><strong>Task</strong>：基本的工作单元，由Flink的运行时执行任务。任务是封装运算符或运算符链的一个并行实例。</li><li><strong>TaskManager（一个对应一个 JVM 进程）</strong>：worker节点执行任务的数据流，缓冲器以及交换数据流；</li><li><strong>TaskManager Slots</strong> ：用来分割资源，控制worker可以接受多少个任务。</li><li><strong>Akka</strong>：所有组件之间的通信，包括任务状态、Checkpoint 触发等消息。</li><li><strong>Netty</strong>：数据的传输</li><li><strong>Parallelism</strong>： 并行度 </li></ul></li><li><p>2.任务提交和处理流程</p><ul><li>Client 将 application（任务） 提交到 Flink cluster，并于 JobManager 创建 Akka 连接，然后将application 提交给 JobManager；提交方式包括：</li><li>CLI（类似 Spark-submit）；</li><li>Flink WebUI 提交；</li><li>应用程序中指定 JobManager 的 RPC 网络端口构建 Execution Environment 提交 Flink 应用；</li><li>根据 Flink 集群中 TaskManager 上 TaskSlot 的使用情况，为提交的 application `分配 TaskSlots 资源 并命令 TaskManager 启动 application；</li><li>TaskManager 从 JobManager 接收计算任务，然后使用 Slot 资源启动 application，建立数据接入的网络连接、接收数据、处理数据；各 TaskManaer 之间的数据交互通过数据流进行；</li><li>JobManager 和 TaskManager 之间通过 Actor System 进行通信，application 的执行进度会发送给 client 端；在执行 application 过程中，JobManager 会触发 Checkpoints 操作，每个 TaskManager 收到 Checkpoints 触发指令后，会完成 Checkpoint 操作；</li><li>application 执行完成后，执行状态将会反馈给 client 端，并释放掉 TaskManager 中的资源供下一次提交任务使用。</li></ul></li></ul><p><img src="/image/大数据15/大数据15_006.png" alt=""></p><h3 id="五、Flink中的编程模型"><a href="#五、Flink中的编程模型" class="headerlink" title="五、Flink中的编程模型"></a>五、Flink中的编程模型</h3><h4 id="1-编程模型"><a href="#1-编程模型" class="headerlink" title="1.编程模型"></a>1.编程模型</h4><p>在Flink，编程模型的抽象层级主要分为以下4种，越往下抽象度越低，编程越复杂，灵活度越高。</p><p><img src="/image/大数据15/大数据15_007.png" alt=""></p><p>这4层中，一般用于开发的是第二层，即DataStrem/DataSetAPI。用户可以使用DataStream API处理无界数据流，使用DataSet API处理有界数据流。同时这两个API都提供了各种各样的接口来处理数据。例如常见的map、filter、flatMap等等，而且支持python，scala，java等编程语言，后面的demo主要以scala为主。</p><ol><li>Stateful Stream Processiing<ol><li>位于最底层，是core API的底层实现</li><li>process Function</li><li>利用低阶，构建一些新组件（比如：利用其定时做一定情况下的匹配和缓存）</li><li>灵活度高，但看法比较复杂</li></ol></li><li>Core APIS<ol><li>DataStream 流式处理</li><li>DataSet 批量处理</li></ol></li><li>Table &amp; SQL<ol><li>SQL构建在Table之上，都需要构建Table环境。</li><li>不同类型的Table构建不同的Table环境。</li><li>Table可以与DataStream或者DataSet进行相互转换。</li><li>Streaming SQL不同存储的SQL， 最终会转化为流式执行计划</li></ol></li></ol><h4 id="2-构建流程"><a href="#2-构建流程" class="headerlink" title="2.构建流程"></a>2.构建流程</h4><ol><li>构建计算环境（决定采用哪种计算执行方式）</li><li>创建Source（可以多个数据源）</li><li>对数据进行不同方式的转换（提供丰富的算子）</li><li>对结果的数据进行Sink（可以输出到多个地方）</li></ol><p><img src="/image/大数据15/大数据15_008.png" alt=""></p><h3 id="六、安装"><a href="#六、安装" class="headerlink" title="六、安装"></a>六、安装</h3><ul><li>0.前置<ul><li>安装java</li><li>Hadoop</li><li>scala</li></ul></li><li><p>1.Flink的下载：：从<a href="http://flink.apache.org/downloads.html" target="_blank" rel="noopener">官网</a>选择对应Flink版本下载</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /hadoop/software</span><br><span class="line">wget http://mirrors.tuna.tsinghua.edu.cn/apache/flink/flink/flink-1.11.1/flink-1.11.1-bin-scala_2.11.tgz</span><br></pre></td></tr></table></figure></li><li><p>2.解压安装：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zvxf flink-1.11.1-bin-scala_2.11.tgz -C /hadoop/install</span><br><span class="line"><span class="built_in">cd</span> /hadoop/install</span><br><span class="line">mv flink-1.11.1-bin-scala_2.11 flink</span><br></pre></td></tr></table></figure></li><li><p>3.配置环境变量：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 追加内容：</span></span><br><span class="line"><span class="built_in">export</span> FLINK_HOME=/hadoop/install/flink</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$FLINK_HOME</span>/bin</span><br></pre></td></tr></table></figure></li><li><p>4.使环境变量生效</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure></li></ul><h3 id="七、部署"><a href="#七、部署" class="headerlink" title="七、部署"></a>七、部署</h3><p>Flink 有三种部署模式，分别是 Local、Standalone Cluster（ 依赖于 Zookeeper 来实现 JobManager 的 HA ） 和 Yarn Cluster（ 依靠 Yarn 本身来对 JobManager 做 HA  ）。</p><h4 id="1-Local-模式"><a href="#1-Local-模式" class="headerlink" title="1.Local 模式"></a>1.Local 模式</h4><p>对于 Local 模式来说，JobManager 和 TaskManager 会公用一个 JVM 来完成 Workload。如果要验证一个简单的应用，Local 模式是最方便的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start-local.sh</span><br></pre></td></tr></table></figure><h4 id="2-Standalone-模式"><a href="#2-Standalone-模式" class="headerlink" title="2.Standalone 模式"></a>2.Standalone 模式</h4><p>参考<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.6/quickstart/setup_quickstart.html" target="_blank" rel="noopener">入门教程</a></p><ul><li><p>1.<strong>部署规划</strong></p><p>  | 节点名称 | master | worker | zookeeper |<br>  | ——– | —— | —— | ——— |<br>  | master   | master |        | zookeeper |<br>  | node1    |        | worker | zookeeper |<br>  | node2    |        | worker | zookeeper |<br>  | node3    |        | worker | zookeeper |</p></li><li><p>2.<strong>修改配置文件</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> flink/conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.修改masters</span></span><br><span class="line">vi masters</span><br><span class="line"></span><br><span class="line">修改内容如下：</span><br><span class="line">master:8081</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.修改slaves</span></span><br><span class="line">vi slaves</span><br><span class="line"></span><br><span class="line">修改内容如下：</span><br><span class="line">node1</span><br><span class="line">node2</span><br><span class="line">node3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.修改flink-conf.yaml </span></span><br><span class="line">vi flink-conf.yaml </span><br><span class="line"></span><br><span class="line">修改内容如下：</span><br><span class="line">taskmanager.numberOfTaskSlots：2</span><br><span class="line">jobmanager.rpc.address: master</span><br></pre></td></tr></table></figure><p>  可选配置:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">每个JobManager（jobmanager.heap.mb）的可用内存量</span><br><span class="line">每个TaskManager（taskmanager.heap.mb）的可用内存量</span><br><span class="line">每台机器的可用CPU数量（taskmanager.numberOfTaskSlots）</span><br><span class="line">集群中的CPU总数（parallelism.default）</span><br><span class="line">临时目录（taskmanager.tmp.dirs</span><br></pre></td></tr></table></figure></li></ul><ul><li>3.<strong>拷贝安装包到各节点</strong>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scp -r flink/ hadoop@node1:`<span class="built_in">pwd</span>`</span><br><span class="line">scp -r flink/ hadoop@node2:`<span class="built_in">pwd</span>`</span><br><span class="line">scp -r flink/ hadoop@node3:`<span class="built_in">pwd</span>`</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>4.<strong>启动flink</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start-cluster.sh</span><br></pre></td></tr></table></figure></li><li><p>5.WebUI查看:访问<a href="http://master:8081" target="_blank" rel="noopener">http://master:8081</a></p></li></ul><p><strong>注：这里只是集群模式而已，在实际场景中，我们一般需要配置为HA，防止Jobmanager突然挂掉，导致整个集群或者任务执行失败的情况发生。下面介绍一下Standalone HA模式的搭建安装</strong></p><h4 id="3-Standalone-HA模式"><a href="#3-Standalone-HA模式" class="headerlink" title="3.Standalone HA模式"></a>3.Standalone HA模式</h4><p>依赖于 Zookeeper 来实现 JobManager 的 HA。在 Zookeeper 的帮助下，一个 Standalone 的 Flink 集群会同时有多个活着的 JobManager，其中只有一个处于工作状态，其他处于 Standby 状态。当工作中的 JobManager 失去连接后（如宕机或 Crash），Zookeeper 会从 Standby 中选举新的 JobManager 来接管 Flink 集群。 </p><ul><li><p>1.更改conf/flink-conf.yaml配置文件 </p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#jobmanager.rpc.address: master</span></span><br><span class="line">high-availability:zookeeper                             <span class="comment">#指定高可用模式（必须）</span></span><br><span class="line">high-availability.zookeeper.quorum:master:2181,node1:2181,node2:2181,node3:2181 <span class="comment"># ZooKeeper仲裁是ZooKeeper服务器的复制组，它提供分布式协调服务（必须）</span></span><br><span class="line">high-availability.storageDir:hdfs:///flink/ha/       <span class="comment">#JobManager元数据保存在文件系统storageDir中，只有指向此状态的指针存储在ZooKeeper中（必须）</span></span><br><span class="line">high-availability.zookeeper.path.root:/flink         <span class="comment">#根ZooKeeper节点，在该节点下放置所有集群节点（推荐） </span></span><br><span class="line">high-availability.cluster-id:/flinkCluster           ＃自定义集群（推荐）</span><br><span class="line">state.backend: filesystem</span><br><span class="line">state.checkpoints.dir: hdfs:///flink/checkpoints</span><br><span class="line">state.savepoints.dir: hdfs:///flink/checkpoints</span><br></pre></td></tr></table></figure></li><li><p>2.修改conf/masters</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">master:8081</span><br><span class="line">node1:8081</span><br></pre></td></tr></table></figure></li><li><p>3.分发配置文件，将刚刚修改的配置文件 masters 和 flink-conf.yaml 分发至另外三个节点。</p></li><li>4.重启flink集群：start-cluster.sh</li></ul><h4 id="4-Yarn-Cluster"><a href="#4-Yarn-Cluster" class="headerlink" title="4.Yarn Cluster"></a>4.Yarn Cluster</h4><p>Yarn Cluaster 模式来说，Flink 就要依靠 Yarn 本身来对 JobManager 做 HA 了。</p><p><img src="/image/大数据15/大数据15_009.png" alt=""></p><p>在图中可以看出，Flink 与 Yarn 的关系与 MapReduce 和 Yarn 的关系是一样的。Flink 通过 Yarn 的接口实现了自己的 App Master。当在 Yarn 中部署了 Flink，Yarn 就会用自己的 Container 来启动 Flink 的 JobManager（也就是 App Master）和 TaskManager。</p><p>启动新的Flink YARN会话时，客户端首先检查所请求的资源（容器和内存）是否可用。之后，它将包含Flink和配置的jar上传到HDFS（步骤1）。</p><p>客户端的下一步是请求（步骤2）YARN容器以启动<em>ApplicationMaster</em>（步骤3）。由于客户端将配置和jar文件注册为容器的资源，因此在该特定机器上运行的YARN的NodeManager将负责准备容器（例如，下载文件）。完成后，将启动<em>ApplicationMaster</em>（AM）。</p><p>该<em>JobManager</em>和AM在同一容器中运行。一旦它们成功启动，AM就知道JobManager（它自己的主机）的地址。它正在为TaskManagers生成一个新的Flink配置文件（以便它们可以连接到JobManager）。该文件也上传到HDFS。此外，<em>AM</em>容器还提供Flink的Web界面。YARN代码分配的所有端口都是<em>临时端口</em>。这允许用户并行执行多个Flink YARN会话。</p><p>之后，AM开始为Flink的TaskManagers分配容器，这将从HDFS下载jar文件和修改后的配置。完成这些步骤后，即可建立Flink并准备接受作业。</p><ul><li><p>1.修改环境变量</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span>  HADOOP_CONF_DIR=/hadoop/install/hadoop/etc/hadoop</span><br></pre></td></tr></table></figure></li><li><p>2.部署启动 </p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn-session.sh -d -s 2 -tm 800 -n 2</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-n : TaskManager的数量，相当于executor的数量</span><br><span class="line">-s : 每个JobManager的core的数量，executor-cores。建议将slot的数量设置每台机器的处理器数量</span><br><span class="line">-tm : 每个TaskManager的内存大小，executor-memory</span><br><span class="line">-jm : JobManager的内存大小，driver-memory</span><br></pre></td></tr></table></figure></li><li><p>3.Yarn 模式的HA:修改 yarn-site.xml文件（$HADOOP_HOME/etc/hadoop/yarn-site.xml）的 应用最大尝试次数（max-attempts）</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&lt;property&gt;</span></span><br><span class="line">  <span class="string">&lt;name&gt;yarn.resourcemanager.am.max-attempts&lt;/name&gt;</span></span><br><span class="line">  <span class="string">&lt;value&gt;4&lt;/value&gt;</span></span><br><span class="line">  <span class="string">&lt;description&gt;The</span> <span class="string">maximum</span> <span class="string">number</span> <span class="string">of</span> <span class="string">application</span> <span class="string">master</span> <span class="string">execution</span> <span class="string">attempts&lt;/description&gt;</span></span><br><span class="line"><span class="string">&lt;/property&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>More info: <a href="https://www.jianshu.com/p/3b1bccbfa322" target="_blank" rel="noopener">flink</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几年大数据的飞速发展，出现了很多热门的开源社区，其中著名的有 Hadoop、Storm，以及后来的 Spark，他们都有着各自专注的应用场景。&lt;/p&gt;
&lt;p&gt;Spark 掀开了内存计算的先河，也以内存为赌注，赢得了内存计算的飞速发展。Spark 的火热地掩盖了其他分布式计算的系统身影，例如 Flink在这个时候默默地发展着。在国外一些社区，有很多人将大数据的计算引擎分成了 4 代，当然也有很多人不会认同,我们先姑且这么认为和讨论。&lt;/p&gt;
&lt;p&gt;首先第一代的计算引擎，无疑就是 Hadoop 承载的 MapReduce。这里大家应该都不会对 MapReduce 陌生，它将计算分为两个阶段，分别为 Map 和 Reduce。对于上层应用来说，就不得不想方设法去拆分算法，甚至于不得不在上层应用实现多个 Job 的串联，以完成一个完整的算法，例如迭代计算。&lt;br&gt;由于这样的弊端，催生了支持 DAG 框架的产生,因此支持 DAG 的框架被划分为第二代计算引擎，如 Tez 以及更上层的 Oozie。这里我们不去细究各种 DAG 实现之间的区别，不过对于当时的 Tez 和 Oozie 来说，大多还是批处理的任务。&lt;/p&gt;
&lt;p&gt;接下来就是以 Spark 为代表的第三代的计算引擎。第三代计算引擎的特点主要是 Job 内部的 DAG 支持（不跨越 Job），以及强调的实时计算。在这里，很多人也会认为第三代计算引擎也能够很好的运行批处理的 Job。随着第三代计算引擎的出现，促进了上层应用快速发展，例如各种迭代计算的性能以及对流计算和 SQL 等的支持。Flink 的诞生就被归在了第四代。这应该主要表现在 Flink 对流计算的支持，以及更一步的实时性上面。当然 Flink 也可以支持 Batch 的任务，以及 DAG 的运算。&lt;/p&gt;
&lt;p&gt;本文章主要介绍 Flink 和 在centos环境下如何安装 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="大数据" scheme="https://lightalight.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="flink" scheme="https://lightalight.github.io/tags/flink/"/>
    
  </entry>
  
  <entry>
    <title>大数据（十四）Spark</title>
    <link href="https://lightalight.github.io/2020/05/15/%E5%A4%A7%E6%95%B0%E6%8D%AE14/"/>
    <id>https://lightalight.github.io/2020/05/15/大数据14/</id>
    <published>2020-05-15T11:23:32.000Z</published>
    <updated>2020-09-20T09:51:24.346Z</updated>
    
    <content type="html"><![CDATA[<p>Apache Spark 是专为大规模数据处理而设计的快速通用的计算引擎。</p><p>本文章主要介绍 Spark 和 在centos环境下如何安装 。</p><a id="more"></a><h2 id="Quick-Guide"><a href="#Quick-Guide" class="headerlink" title="Quick Guide"></a>Quick Guide</h2><h3 id="一、Hadoop-和-Spark-的关系"><a href="#一、Hadoop-和-Spark-的关系" class="headerlink" title="一、Hadoop 和 Spark 的关系"></a>一、Hadoop 和 Spark 的关系</h3><ul><li><p>Hadoop有两个核心模块，分布式存储模块HDFS和分布式计算模块Mapreduce</p></li><li><p>spark本身并没有提供分布式文件系统，因此spark的分析大多依赖于Hadoop的分布式文件系统HDFS</p></li><li><p>Hadoop的Mapreduce与spark都可以进行数据计算，而相比于Mapreduce，spark的速度更快并且提供的功能更加丰富</p></li></ul><p><img src="/image/大数据14/大数据14_001.jpg" alt=""></p><p><img src="/image/大数据14/大数据14_002.jpg" alt=""><br><img src="/image/大数据14/大数据14_003.jpg" alt=""></p><h3 id="二、-Spark-的特点"><a href="#二、-Spark-的特点" class="headerlink" title="二、 Spark 的特点"></a>二、 Spark 的特点</h3><p>Spark具有如下几个主要特点：</p><ul><li>运行速度快：Spark使用先进的DAG（Directed Acyclic Graph，有向无环图）执行引擎，以支持循环数据流与内存计算，基于内存的执行速度可比Hadoop MapReduce快上百倍，基于磁盘的执行速度也能快十倍；</li><li>容易使用：Spark支持使用Scala、Java、Python和R语言进行编程，简洁的API设计有助于用户轻松构建并行程序，并且可以通过Spark Shell进行交互式编程；</li><li>通用性：Spark提供了完整而强大的技术栈，包括SQL查询、流式计算、机器学习和图算法组件，这些组件可以无缝整合在同一个应用中，足以应对复杂的计算；</li><li>运行模式多样：Spark可运行于独立的集群模式中，或者运行于Hadoop中，也可运行于Amazon EC2等云环境中，并且可以访问HDFS、Cassandra、HBase、Hive等多种数据源。</li></ul><h3 id="三、Spark-架构"><a href="#三、Spark-架构" class="headerlink" title="三、Spark 架构"></a>三、Spark 架构</h3><h4 id="1-Spark生态系统"><a href="#1-Spark生态系统" class="headerlink" title="1.Spark生态系统"></a>1.Spark生态系统</h4><p><img src="/image/大数据14/大数据14_004.jpg" alt=""></p><ul><li>Spark Core：包含Spark的基本功能，尤其是定义RDD的API、操作以及这两者上的动作。其他Spark的库都是构建在RDD和Spark Core之上的</li><li>Spark SQL：提供通过Apache Hive的SQL变体Hive查询语言（HiveQL）与Spark进行交互的API。每个数据库表被当做一个RDD，Spark SQL查询被转换为Spark操作。</li><li>Spark Streaming：对实时数据流进行处理和控制。Spark Streaming允许程序能够像普通RDD一样处理实时数据</li><li>MLlib：一个常用机器学习算法库，算法被实现为对RDD的Spark操作。这个库包含可扩展的学习算法，比如分类、回归等需要对大量数据集进行迭代的操作。</li><li>GraphX：控制图、并行图操作和计算的一组算法和工具的集合。GraphX扩展了RDD API，包含控制图、创建子图、访问路径上所有顶点的操作</li></ul><h4 id="2-架构"><a href="#2-架构" class="headerlink" title="2.架构"></a>2.架构</h4><p><img src="/image/大数据14/大数据14_005.jpg" alt=""></p><h4 id="3-基本概念"><a href="#3-基本概念" class="headerlink" title="3.基本概念"></a>3.基本概念</h4><table><thead><tr><th>Term（术语）</th><th>Meaning（含义）</th></tr></thead><tbody><tr><td>Cluster manager</td><td>一个外部的用于获取集群上资源的服务。（在standalone模式中即为Master主节点，控制整个集群，监控worker;在YARN模式中为资源管理器。</td></tr><tr><td>Driver program</td><td>该进程运行应用的 main() 方法并且创建了 SparkContext。</td></tr><tr><td>RDD</td><td>是弹性分布式数据集（Resilient Distributed Dataset）的简称，是分布式内存的一个抽象概念，提供了一种高度受限的共享内存模型</td></tr><tr><td>DAG</td><td>是Directed Acyclic Graph（有向无环图）的简称，反映RDD之间的依赖关系</td></tr><tr><td>Application</td><td>用户构建在 Spark 上的程序。由集群上的一个 driver 程序和多个 executor 组成。</td></tr><tr><td>Worker node</td><td>任何在集群中可以运行应用代码的节点。</td></tr><tr><td>Executor</td><td>一个为了在 worker 节点上的应用而启动的进程，它运行 task 并且将数据保持在内存中或者硬盘存储。每个应用有它自己的 Executor。</td></tr><tr><td>Task</td><td>一个将要被发送到 Executor 中的工作单元。</td></tr><tr><td>Job</td><td>一个由多个任务组成的并行计算，并且能从 Spark action 中获取响应（例如 save，collect）; 您将在 driver 的日志中看到这个术语。</td></tr><tr><td>Stage</td><td>每个 Job 被拆分成更小的被称作 stage（阶段）的 task（任务）组，stage 彼此之间是相互依赖的（与 MapReduce 中的 map 和 reduce stage 相似）。您将在 driver 的日志中看到这个术语。</td></tr></tbody></table><p>在Spark中，一个应用（Application）由一个任务控制节点（Driver）和若干个作业（Job）构成，一个作业由多个阶段（Stage）构成，一个阶段由多个任务（Task）组成。当执行一个应用时，任务控制节点会向集群管理器（Cluster Manager）申请资源，启动Executor，并向Executor发送应用程序代码和文件，然后在Executor上执行任务，运行结束后，执行结果会返回给任务控制节点，或者写到HDFS或者其他数据库中。</p><p><img src="/image/大数据14/大数据14_006.jpg" alt=""></p><h4 id="4-运行流程"><a href="#4-运行流程" class="headerlink" title="4.运行流程"></a>4.运行流程</h4><p><img src="/image/大数据14/大数据14_007.jpg" alt=""></p><ol><li>构建Spark Application的运行环境，启动SparkContext</li><li>SparkContext向资源管理器（可以是Standalone，Mesos，Yarn）申请运行Executor资源，并启动StandaloneExecutorbackend，</li><li>Executor向SparkContext申请Task</li><li>SparkContext将应用程序分发给Executor</li><li>SparkContext构建成DAG图，将DAG图分解成Stage、将Taskset发送给Task Scheduler，最后由Task Scheduler将Task发送给Executor运行</li><li>Task在Executor上运行，运行完释放所有资源</li></ol><h3 id="四、Spark的部署模式"><a href="#四、Spark的部署模式" class="headerlink" title="四、Spark的部署模式"></a>四、Spark的部署模式</h3><ul><li><p>1.standalone模式<br>与MapReduce1.0框架类似，Spark框架本身也自带了完整的资源调度管理服务，可以独立部署到一个集群中，而不需要依赖其他系统来为其提供资源管理调度服务。在架构的设计上，Spark与MapReduce1.0完全一致，都是由一个Master和若干个Slave构成，并且以槽（slot）作为资源分配单位。不同的是，Spark中的槽不再像MapReduce1.0那样分为Map 槽和Reduce槽，而是只设计了统一的一种槽提供给各种任务来使用。</p></li><li><p>2.Spark on Mesos模式<br>Mesos是一种资源调度管理框架，可以为运行在它上面的Spark提供服务。Spark on Mesos模式中，Spark程序所需要的各种资源，都由Mesos负责调度。由于Mesos和Spark存在一定的血缘关系，因此，Spark这个框架在进行设计开发的时候，就充分考虑到了对Mesos的充分支持，因此，相对而言，Spark运行在Mesos上，要比运行在YARN上更加灵活、自然。目前，Spark官方推荐采用这种模式，所以，许多公司在实际应用中也采用该模式。</p></li><li><p>3.Spark on YARN模式<br>Spark可运行于YARN之上，与Hadoop进行统一部署，即“Spark on YARN”，资源管理和调度依赖YARN，分布式存储则依赖HDFS。</p></li></ul><h3 id="五、部署安装"><a href="#五、部署安装" class="headerlink" title="五、部署安装"></a>五、部署安装</h3><h4 id="0-前置"><a href="#0-前置" class="headerlink" title="0.前置"></a>0.前置</h4><ul><li>安装java</li><li>安装hadoop</li></ul><h4 id="1-安装Scala"><a href="#1-安装Scala" class="headerlink" title="1.安装Scala"></a>1.安装Scala</h4><ul><li><p>0.从<a href="https://www.scala-lang.org/download/" target="_blank" rel="noopener">官网</a>下载安装包到 /hadoop/software</p></li><li><p>1.解压到指定文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /hadoop/software</span><br><span class="line">tar -zxvf scala-2.11.8.tgz -C  /haddop/install</span><br></pre></td></tr></table></figure></li><li><p>2.修改环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在末尾追加内容</span></span><br><span class="line"><span class="built_in">export</span> SCALA_HOME=/haddop/install/scala-2.11.8</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$SCALA_HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></li><li><p>3.使环境变量生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure></li><li><p>4.检查安装是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scala -version</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-安装Spark"><a href="#2-安装Spark" class="headerlink" title="2.安装Spark"></a>2.安装Spark</h4><ul><li><p>0.从<a href="http://spark.apache.org/downloads.html" target="_blank" rel="noopener">官网</a>下载安装包到/hadoop/software</p></li><li><p>1.解压到指定文件</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /hadoop/software</span><br><span class="line">tar -zxvf spark-2.3.3-bin-hadoop2.7.tgz -C  /haddop/install</span><br><span class="line"><span class="built_in">cd</span> /haddop/install</span><br><span class="line">mv spark-2.3.3-bin-hadoop2.7 spark</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>2.修改环境变量</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在末尾追加内容</span></span><br><span class="line"><span class="built_in">export</span> SPARK_HOME=/hadoop/install/spark</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$SPARK_HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></li><li><p>3.使环境变量生效</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-设置部署模式"><a href="#3-设置部署模式" class="headerlink" title="3.设置部署模式"></a>3.设置部署模式</h4><ul><li><p>local模式</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spark-shell</span><br></pre></td></tr></table></figure></li><li><p>Standalone模式</p><ul><li><p>1.配置文件slaves.template</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /haddop/install/spark/conf</span><br><span class="line">cp slaves.template slaves</span><br><span class="line">vi slaves</span><br></pre></td></tr></table></figure><p>添加以下内容 slavexx(看节点数量)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Master</span><br><span class="line">Slave1</span><br><span class="line">Slave2</span><br><span class="line">Slave3</span><br></pre></td></tr></table></figure></li><li><p>2.配置spark-env.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp spark-env.sh.template spark-env.sh</span><br><span class="line">vi spark-env.sh</span><br></pre></td></tr></table></figure><p>添加以下内容 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># JAVA的路径</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=<span class="variable">$&#123;JAVA_HOMRE&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SCALA的路径</span></span><br><span class="line"><span class="built_in">export</span> SCALA_HOME=<span class="variable">$&#123;SCALA_HOME&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># HADOOP的路径</span></span><br><span class="line"><span class="built_in">export</span> HADOOP_CONF_DIR=<span class="variable">$&#123;HADOOP_HOME&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># master的ip或host</span></span><br><span class="line"><span class="built_in">export</span> SPARK_MASTER_IP=master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交任务的端口</span></span><br><span class="line"><span class="built_in">export</span> SPARK_MASTER_PORT=7077</span><br><span class="line"></span><br><span class="line"><span class="comment"># 浏览器访问master的端口</span></span><br><span class="line"><span class="built_in">export</span> SPARK_MASTER_WEBUI_PORT=8080</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个worker从节点能够支配的core的个数</span></span><br><span class="line"><span class="built_in">export</span> SPARK_WORKER_CORES=2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个worker从节点能够支配的内存数</span></span><br><span class="line"><span class="built_in">export</span> SPARK_WORKER_MEMORY=内存大小</span><br><span class="line"></span><br><span class="line"><span class="comment">#每个worker</span></span><br><span class="line"><span class="built_in">export</span> SPARK_WORKER_PORT=7078</span><br><span class="line"><span class="built_in">export</span> SPARK_WORKER_WEBUI_PORT=8081</span><br><span class="line"><span class="built_in">export</span> SPARK_WORKER_INSTANCES=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个worker的数据存放</span></span><br><span class="line"><span class="built_in">export</span> SPARK_WORKER_DIR=<span class="variable">$&#123;SPARK_HOME&#125;</span>/data/tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定Spark executor的内存大小</span></span><br><span class="line"><span class="built_in">export</span> SPARK_EXECUTOR_MEMORY=1G</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定Spark executor 使用的cpu的核的数量</span></span><br><span class="line"><span class="built_in">export</span> SPARK_EXECUTOR_CORES=1</span><br></pre></td></tr></table></figure></li><li><p>3.配置修改Spark-defaults.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp spark-defaults.conf.template spark-defaults.conf</span><br><span class="line">vi spark-defaults.conf</span><br></pre></td></tr></table></figure><p>添加以下内容 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置事件日志为true</span></span><br><span class="line">spark.eventlog.enabled=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置记录删除时间</span></span><br><span class="line">spark.history.fs.cleaner.interval=1d</span><br><span class="line">spark.history.fs.cleaner.maxAge=7d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定事件日志目录</span></span><br><span class="line">spark.eventlog.dir hdfs://nn/user/spark/<span class="built_in">history</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定Driver的内存大小</span></span><br><span class="line">spark.driver.memory 1g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定历史操作日志操作保存路径</span></span><br><span class="line">spark.history.fs.logDirectory hdfs://nn/usr/spark/<span class="built_in">history</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定仓库目录</span></span><br><span class="line">spark.sql.warehouse.dir /user/spark/warehouse</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Yarn模式:在standalone模式的基础上，在客户端的spark-env.sh文件中配置</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> HADOOP_CONF_DIR=<span class="variable">$HADOOP_HOME</span>/etc/hadoop</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Apache Spark 是专为大规模数据处理而设计的快速通用的计算引擎。&lt;/p&gt;
&lt;p&gt;本文章主要介绍 Spark 和 在centos环境下如何安装 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="大数据" scheme="https://lightalight.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="spark" scheme="https://lightalight.github.io/tags/spark/"/>
    
  </entry>
  
  <entry>
    <title>大数据（十三）Sqoop</title>
    <link href="https://lightalight.github.io/2020/04/15/%E5%A4%A7%E6%95%B0%E6%8D%AE13/"/>
    <id>https://lightalight.github.io/2020/04/15/大数据13/</id>
    <published>2020-04-15T11:23:32.000Z</published>
    <updated>2020-09-20T09:51:24.576Z</updated>
    
    <content type="html"><![CDATA[<p>传统的应用程序管理系统，即应用程序与使用RDBMS的关系数据库的交互，是产生大数据的来源之一。由RDBMS生成的这种大数据存储在关系数据库结构中的关系数据库服务器中。</p><p>当大数据存储和Hadoop生态系统的MapReduce，Hive，HBase，Cassandra，Pig等分析器出现时，他们需要一种工具来与关系数据库服务器进行交互，以导入和导出驻留在其中的大数据。在这里，Sqoop在Hadoop生态系统中占据一席之地，以便在关系数据库服务器和Hadoop的HDFS之间提供可行的交互。</p><p>Sqoop(“SQL到Hadoop和Hadoop到SQL):是一个用于在Hadoop和关系数据库服务器之间传输数据的工具。它用于从关系数据库（如MySQL，Oracle）导入数据到Hadoop HDFS，并从Hadoop文件系统导出到关系数据库。它由Apache软件基金会提供。</p><p>本文章主要介绍 Sqoop 和 在centos环境下如何安装 。</p><a id="more"></a><h2 id="Quick-Guide"><a href="#Quick-Guide" class="headerlink" title="Quick Guide"></a>Quick Guide</h2><h3 id="一、流程"><a href="#一、流程" class="headerlink" title="一、流程"></a>一、流程</h3><p><img src="/image/大数据13/大数据13_001.png" alt=""></p><ul><li>Sqoop导入：导入工具从RDBMS向HDFS导入单独的表。表中的每一行都被视为HDFS中的记录。所有记录都以文本文件的形式存储在文本文件中或作为Avro和Sequence文件中的二进制数据存储。</li><li>Sqoop导出：导出工具将一组文件从HDFS导出回RDBMS。给Sqoop输入的文件包含记录，这些记录在表中被称为行。这些被读取并解析成一组记录并用用户指定的分隔符分隔。</li></ul><h3 id="二、工作机制"><a href="#二、工作机制" class="headerlink" title="二、工作机制"></a>二、工作机制</h3><p>将导入或导出命令翻译成 MapReduce 程序来实现 在翻译出的 MapReduce 中主要是对 InputFormat 和 OutputFormat 进行定制</p><h3 id="三、Sqoop版本"><a href="#三、Sqoop版本" class="headerlink" title="三、Sqoop版本"></a>三、Sqoop版本</h3><ul><li>1.sqoop的版本sqoop1和sqoop2是两个不同的版本，它们是完全不兼容的</li><li>2.版本划分方式: apache1.4.X之后的版本是1,1.99.0之上的版本是2</li><li>3.Sqoop2相比sqoop1的优势有：<ul><li>1.它引入的sqoop Server，便于集中化的管理Connector或者其它的第三方插件；</li><li>2.多种访问方式：CLI、Web UI、REST API；</li><li>3.它引入了基于角色的安全机制，管理员可以在sqoop Server上配置不同的角色。</li></ul></li><li>4.Sqoop2和sqoop1的功能性对比：<ul><li>1.它引入的sqoop Server，便于集中化的管理Connector或者其它的第三方插件；</li><li>2.多种访问方式：CLI、Web UI、REST API；</li><li><ol start="3"><li>它引入了基于角色的安全机制，管理员可以在sqoop Server上配置不同的角色。</li></ol></li></ul></li><li>5.Sqoop2和sqoop1的功能性对比：</li></ul><p><img src="/image/大数据13/大数据13_002.png" alt=""></p><ul><li><p>6.Sqoop1和Sqoop2的架构区别：</p><ul><li><p>1.Sqoop1的架构图：</p><p><img src="/image/大数据13/大数据13_003.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">版本号：1.4.X以后的Sqoop1</span><br><span class="line">在架构上：Sqoop1使用Sqoop客户端直接提交代码方式</span><br><span class="line">访问方式：CLI命令行控制台方式访问</span><br><span class="line">安全性：命令或者脚本指定用户数据库名和密码</span><br><span class="line">原理：Sqoop工具接收到客户端的shell命令或者Java api命令后，通过Sqoop中的任务翻译器(Task Translator)将命令转换为对应的MapReduce任务，而后将关系型数据库和Hadoop中的数据进行相互转移，进而完成数据的拷贝</span><br></pre></td></tr></table></figure></li><li><p>2.Sqoop2架构图：<br><img src="/image/大数据13/大数据13_004.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">版本号：1.99.X以上的版本Sqoop2   </span><br><span class="line">在架构上：Sqoop2引入了 Sqoop server,对对connector实现了集中的管理访问方式：REST API、 JAVA API、 WEB UI以及CLI控制台方式进行访问    </span><br><span class="line">   CLI方式访问，会通过交互过程界面，输入的密码信息会被看到，同时Sqoop2引入基亍角色的安全机制，Sqoop2比Sqoop多了一个Server端。</span><br></pre></td></tr></table></figure></li><li><p>3.Sqoop1和Sqoop2优缺点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sqoop1优点：架构部署简单</span><br><span class="line">Sqoop1缺点：命令行方式容易出错，格式紧耦合，无法支持所有数据类型，安全机制不够完善，例如密码暴漏，安装需要root权限，connector必须符合JDBC模型</span><br><span class="line">Sqoop2优点：多种交互方式，命令行，web UI，rest API，conncetor集中化管理，所有的链接安装在Sqoop server上，完善权限管理机制，connector规范化，仅仅负责数据的读写</span><br><span class="line">Sqoop2缺点：Sqoop2的缺点，架构稍复杂，配置部署更繁琐</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="四、Sqoop1的安装"><a href="#四、Sqoop1的安装" class="headerlink" title="四、Sqoop1的安装"></a>四、Sqoop1的安装</h3><p>因为绝大部分企业所使用的sqoop的版本都是 Sqoop1，这边介绍 Sqoop1 的安装。</p><ul><li>1.前提概述<ul><li>1.sqoop就是一个工具,只需要在一个节点上进行安装即可。</li><li>2.需要跟那个组件打交道，就需要安装的节点上有对应组件。</li></ul></li><li>2.下载<ul><li>1.从<a href="http://sqoop.apache.org/" target="_blank" rel="noopener">官网</a>下载,选择 sqoop-1.4.7 下载。</li></ul></li><li><p>3.上传并解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /hadoop/software</span><br><span class="line">tar -zxvf sqoop-1.4.7.bin__hadoop-2.6.0.tar.gz  -C /hadopp/install/</span><br></pre></td></tr></table></figure></li><li><p>4.配置环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/hadoop/.bashrc</span><br><span class="line">vi .bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将下面两行添加到末尾</span></span><br><span class="line"><span class="built_in">export</span> SQOOP_HOME=/hadoop/install/sqoop-1.4.7</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$SQOOP_HOME</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使环境变量生效</span></span><br><span class="line">. .bashrc</span><br></pre></td></tr></table></figure></li><li><p>5.修改配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /hadoop/install/sqoop-1.4.7/conf/</span><br><span class="line">mv sqoop-env-template.sh sqoop-env.sh</span><br><span class="line">vi sqoop-env.sh</span><br></pre></td></tr></table></figure></li></ul><p>修改配置内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> HADOOP_COMMON_HOME=/install/hadoop/hadoop</span><br><span class="line"></span><br><span class="line"><span class="comment">#Set path to where hadoop-*-core.jar is available</span></span><br><span class="line"><span class="built_in">export</span> HADOOP_MAPRED_HOME=/install/hadoop/hadoop</span><br><span class="line"></span><br><span class="line"><span class="comment">#set the path to where bin/hbase is available</span></span><br><span class="line"><span class="built_in">export</span> HBASE_HOME=/hadoop/install/hbase-2.0.5</span><br><span class="line"></span><br><span class="line"><span class="comment">#Set the path to where bin/hive is available</span></span><br><span class="line"><span class="built_in">export</span> HIVE_HOME=/hadoop/install/apache-hive-3.1.2</span><br><span class="line"></span><br><span class="line"><span class="comment">#Set the path for where zookeper config dir is</span></span><br><span class="line"><span class="built_in">export</span> ZOOCFGDIR=/hadoop/install/zookeeper-3.4.12/conf</span><br></pre></td></tr></table></figure></p><ul><li><p>6.增加驱动</p><ul><li>1.从<a href="https://downloads.mysql.com/archives/c-j/" target="_blank" rel="noopener">mysql官网</a>下载对于版本驱动</li><li>2.把驱动放入sqoop1.4.7/lib 目录下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /hadoop/software/mysql-connector-java-5.1.38-bin.jar /hadoop/install/sqoop1.4.7/lib/</span><br></pre></td></tr></table></figure></li></ul></li><li><p>7.验证安装是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqoop-version</span><br></pre></td></tr></table></figure></li></ul><h3 id="五、Sqoop的基本命令"><a href="#五、Sqoop的基本命令" class="headerlink" title="五、Sqoop的基本命令"></a>五、Sqoop的基本命令</h3><ul><li>1.列出MySQL数据有哪些数据库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqoop list-databases --connect jdbc:mysql://master:3306/ --username root --password root</span><br></pre></td></tr></table></figure><ul><li><p>2.列出MySQL中的某个数据库有哪些数据表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqoop list-tables --connect jdbc:mysql://master:3306/ --username root --password root</span><br></pre></td></tr></table></figure></li><li><p>3.创建一张跟mysql中的tbl_test表一样的hive表tbl_hive：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqoop create-hive-table --connect jdbc:mysql://master:3306/ --username root --password root  --table tbl_test  --hive-table tbl_hive</span><br></pre></td></tr></table></figure><ul><li>4.从RDBMS导入到HDFS中</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqoop import (generic-args) (import-args)</span><br></pre></td></tr></table></figure><p>常用参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">--connect &lt;jdbc-uri&gt; jdbc 连接地址</span><br><span class="line">--connection-manager &lt;class-name&gt; 连接管理者</span><br><span class="line">--connection-param-file &lt;filename&gt; 可选参数</span><br><span class="line">--column-family：列族</span><br><span class="line">--driver &lt;class-name&gt; 驱动类</span><br><span class="line">--hadoop-mapred-home &lt;dir&gt; $HADOOP_MAPRED_HOME</span><br><span class="line">--hbase-table：hbase中的table</span><br><span class="line">--hbase-row-key：指定rowkey</span><br><span class="line">--help help 信息</span><br><span class="line">--password &lt;password&gt; 密码</span><br><span class="line">-P 从命令行输入密码</span><br><span class="line">--table ：需要sqoop的表</span><br><span class="line">--username &lt;username&gt; 账号</span><br><span class="line">--verbose 打印流程信息</span><br></pre></td></tr></table></figure></p><p>例子: 导入mysql库中的 tbl_test 的数据到HDFS上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqoop import  --connect jdbc:mysql://master:3306/ --username root --password root  --table tbl_test  -m 1</span><br></pre></td></tr></table></figure><ul><li>5.把MySQL数据库中的表数据导入到Hive中</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqoop import  --connect jdbc:mysql://master:3306/ --username root --password root  --table tbl_test --hive-import -m 1</span><br></pre></td></tr></table></figure><p>导入过程:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一步：导入mysql.tbl_test的数据到hdfs的默认路径</span><br><span class="line">第二步：自动仿造mysql.help_keyword去创建一张hive表, 创建在默认的default库中</span><br><span class="line">第三步：把临时目录中的数据导入到hive表中</span><br></pre></td></tr></table></figure><ul><li>6.把MySQL数据库中的表数据导入到hbase</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要先创建Hbase里面的表</span></span><br><span class="line">sqoop import  --connect jdbc:mysql://master:3306/ --username root --password root  --table tbl_test --hbase-table tbl_hbase --column-family person --hbase-row-key tbl_hbase_key</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传统的应用程序管理系统，即应用程序与使用RDBMS的关系数据库的交互，是产生大数据的来源之一。由RDBMS生成的这种大数据存储在关系数据库结构中的关系数据库服务器中。&lt;/p&gt;
&lt;p&gt;当大数据存储和Hadoop生态系统的MapReduce，Hive，HBase，Cassandra，Pig等分析器出现时，他们需要一种工具来与关系数据库服务器进行交互，以导入和导出驻留在其中的大数据。在这里，Sqoop在Hadoop生态系统中占据一席之地，以便在关系数据库服务器和Hadoop的HDFS之间提供可行的交互。&lt;/p&gt;
&lt;p&gt;Sqoop(“SQL到Hadoop和Hadoop到SQL):是一个用于在Hadoop和关系数据库服务器之间传输数据的工具。它用于从关系数据库（如MySQL，Oracle）导入数据到Hadoop HDFS，并从Hadoop文件系统导出到关系数据库。它由Apache软件基金会提供。&lt;/p&gt;
&lt;p&gt;本文章主要介绍 Sqoop 和 在centos环境下如何安装 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="大数据" scheme="https://lightalight.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="sqoop" scheme="https://lightalight.github.io/tags/sqoop/"/>
    
  </entry>
  
  <entry>
    <title>大数据（十二）Flume</title>
    <link href="https://lightalight.github.io/2020/03/15/%E5%A4%A7%E6%95%B0%E6%8D%AE12/"/>
    <id>https://lightalight.github.io/2020/03/15/大数据12/</id>
    <published>2020-03-15T11:23:32.000Z</published>
    <updated>2020-09-20T09:51:24.159Z</updated>
    
    <content type="html"><![CDATA[<p>Flume是一个分布式、可靠、高可用的海量日志聚合系统，支持在系统中定制各类数据发送方，用于收集数据；同时Flume提供对数据的简单处理，并写到各种数据接收方的能力。</p><p>本文章主要介绍 Flume 和 在centos环境下如何安装 。</p><a id="more"></a><h2 id="Quick-Guide"><a href="#Quick-Guide" class="headerlink" title="Quick Guide"></a>Quick Guide</h2><h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>Hadoop业务的整体开发流程：</p><p><img src="/image/大数据12/大数据12_001.png" alt=""></p><p>　　从Hadoop的业务开发流程图中可以看出，在大数据的业务处理过程中，对于数据的采集是十分重要的一步，也是不可避免的一步.<br>　　许多公司的平台每天会产生大量的日志（一般为流式数据，如搜索引擎的pv和查询等），处理这些日志需要特定的日志系统，一般而言，这些系统需要具有以下特征：</p><ol><li>构建应用系统和分析系统的桥梁，并将它们之间的关联解耦；</li><li>支持近实时的在线分析系统和类似于Hadoop之类的离线分析系统；</li><li>具有高可扩展性。即：当数据量增加时，可以通过增加节点进行水平扩展。</li></ol><p>开源的日志系统，包括facebook的scribe，apache的chukwa，linkedin的kafka和cloudera的flume等。</p><h3 id="二、Flume的简介"><a href="#二、Flume的简介" class="headerlink" title="二、Flume的简介"></a>二、Flume的简介</h3><p>　　flume 作为 cloudera 开发的实时日志收集系统，受到了业界的认可与广泛应用。Flume 初始的发行版本目前被统称为 Flume OG（original generation），属于 cloudera。<br>　　但随着 FLume 功能的扩展，Flume OG 代码工程臃肿、核心组件设计不合理、核心配置不标准等缺点暴露出来，尤其是在 Flume OG 的最后一个发行版本 0.9.4. 中，日志传输不稳定的现象尤为严重，为了解决这些问题，2011 年 10 月 22 号，cloudera 完成了 Flume-728，对 Flume 进行了里程碑式的改动：重构核心组件、核心配置以及代码架构，重构后的版本统称为 Flume NG（next generation）；改动的另一原因是将 Flume 纳入 apache 旗下，cloudera Flume 改名为 Apache Flume。<br>　　Flume 在0.9.x and 1.x之间有较大的架构调整，1.x版本之后的改称Flume NG，0.9.x的称为Flume OG。<br>　　Flume目前只有Linux系统的启动脚本，没有Windows环境的启动脚本。　　</p><h3 id="三、Flume-NG的介绍"><a href="#三、Flume-NG的介绍" class="headerlink" title="三、Flume NG的介绍"></a>三、Flume NG的介绍</h3><h4 id="3-1-flume特点"><a href="#3-1-flume特点" class="headerlink" title="3.1 flume特点"></a>3.1 flume特点</h4><p>　　flume的数据流由事件(Event)贯穿始终。事件是Flume的基本数据单位，它携带日志数据(字节数组形式)并且携带有头信息，这些Event由Agent外部的Source生成，当Source捕获事件后会进行特定的格式化，然后Source会把事件推入(单个或多个)Channel中。你可以把Channel看作是一个缓冲区，它将保存事件直到Sink处理完该事件。Sink负责持久化日志或者把事件推向另一个Source。</p><p>　（1）flume的可靠性<br>　　当节点出现故障时，日志能够被传送到其他节点上而不会丢失。Flume提供了三种级别的可靠性保障，从强到弱依次分别为：end-to-end（收到数据agent首先将event写到磁盘上，当数据传送成功后，再删除；如果数据发送失败，可以重新发送。），Store on failure（这也是scribe采用的策略，当数据接收方crash时，将数据写到本地，待恢复后，继续发送），Besteffort（数据发送到接收方后，不会进行确认）。</p><p>　（2）flume的可恢复性<br>　　依靠Channel，推荐使用FileChannel，事件持久化在本地文件系统里(性能较差)。</p><h4 id="3-2-Flume的核心概念"><a href="#3-2-Flume的核心概念" class="headerlink" title="3.2 Flume的核心概念"></a>3.2 Flume的核心概念</h4><ul><li>Client：Client生产数据，运行在一个独立的线程。</li><li>Event： 一个数据单元，消息头和消息体组成。（Events可以是日志记录、 avro 对象等。）</li><li>Flow： Event从源点到达目的点的迁移的抽象。</li><li>Agent： 一个独立的Flume进程，包含组件Source、 Channel、 Sink。（Agent使用JVM 运行Flume。每台机器运行一个agent，但是可以在一个agent中包含多个sources和sinks。）</li><li>Source(源端数据采集)： 数据收集组件。（source从Client收集数据，传递给Channel）</li><li>Channel(临时存储聚合数据)：中转Event的一个临时存储，保存由Source组件传递过来的Event。（Channel连接 sources 和 sinks ，这个有点像一个队列。）</li><li>Sink（移动数据到目标端）： 从Channel中读取并移除Event， 将Event传递到FlowPipeline中的下一个Agent（如果有的话）（Sink从Channel收集数据，运行在一个独立线程。）</li></ul><h4 id="3-3-Flume-NG的体系结构"><a href="#3-3-Flume-NG的体系结构" class="headerlink" title="3.3 Flume NG的体系结构"></a>3.3 Flume NG的体系结构</h4><p>Flume 运行的核心是 Agent。Flume以agent为最小的独立运行单位。一个agent就是一个JVM。它是一个完整的数据收集工具，含有三个核心组件，分别是source、 channel、 sink。通过这些组件， Event 可以从一个地方流向另一个地方，如下图所示。<br>　<br><img src="/image/大数据12/大数据12_002.png" alt=""></p><h4 id="3-4-Source"><a href="#3-4-Source" class="headerlink" title="3.4 Source"></a>3.4 Source</h4><p>　　Source是数据的收集端，负责将数据捕获后进行特殊的格式化，将数据封装到事件（event） 里，然后将事件推入Channel中。<br>　　Flume提供了各种source的实现，包括Avro Source、Exce Source、Spooling Directory Source、NetCat Source、Syslog Source、Syslog TCP Source、Syslog UDP Source、HTTP Source、HDFS Source，etc。如果内置的Source无法满足需要， Flume还支持自定义Source。<br>　　<br><img src="/image/大数据12/大数据12_003.png" alt=""></p><h4 id="3-5-Channel"><a href="#3-5-Channel" class="headerlink" title="3.5 Channel"></a>3.5 Channel</h4><p>　　Channel是连接Source和Sink的组件，大家可以将它看做一个数据的缓冲区（数据队列），它可以将事件暂存到内存中也可以持久化到本地磁盘上， 直到Sink处理完该事件。<br>　　Flume对于Channel，则提供了Memory Channel、JDBC Chanel、File Channel，etc。<br>　　MemoryChannel可以实现高速的吞吐，但是无法保证数据的完整性。<br>　　MemoryRecoverChannel在官方文档的建议上已经建义使用FileChannel来替换。<br>　　FileChannel保证数据的完整性与一致性。在具体配置不现的FileChannel时，建议FileChannel设置的目录和程序日志文件保存的目录设成不同的磁盘，以便提高效率。　　</p><h4 id="3-6-Sink"><a href="#3-6-Sink" class="headerlink" title="3.6 Sink"></a>3.6 Sink</h4><p>　　Flume Sink取出Channel中的数据，进行相应的存储文件系统，数据库，或者提交到远程服务器。<br>　　Flume也提供了各种sink的实现，包括HDFS sink、Logger sink、Avro sink、File Roll sink、Null sink、HBase sink，etc。<br>　　Flume Sink在设置存储数据时，可以向文件系统中，数据库中，hadoop中储数据，在日志数据较少时，可以将数据存储在文件系中，并且设定一定的时间间隔保存数据。在日志数据较多时，可以将相应的日志数据存储到Hadoop中，便于日后进行相应的数据分析。<br>　　<br><img src="/image/大数据12/大数据12_004.png" alt=""></p><h3 id="四、Flume的部署类型"><a href="#四、Flume的部署类型" class="headerlink" title="四、Flume的部署类型"></a>四、Flume的部署类型</h3><p>单一流程：</p><p><img src="/image/大数据12/大数据12_005.png" alt=""></p><p>多代理流程（多个agent顺序连接）：</p><p><img src="/image/大数据12/大数据12_006.png" alt=""></p><p>流的合并（多个Agent的数据汇聚到同一个Agent ）：</p><p><img src="/image/大数据12/大数据12_007.png" alt=""></p><p>多路复用流（多级流）：</p><p><img src="/image/大数据12/大数据12_008.png" alt=""></p><p>load balance功能:</p><p><img src="/image/大数据12/大数据12_009.png" alt=""></p><h3 id="五、Flume的安装"><a href="#五、Flume的安装" class="headerlink" title="五、Flume的安装"></a>五、Flume的安装</h3><ul><li>0 .从<a href="http://flume.apache.org/download.html" target="_blank" rel="noopener">官网</a>下载或者使用下面的命令下载</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /hadoop/software</span><br><span class="line">wget http://mirrors.hust.edu.cn/apache/flume/1.8.0/apache-flume-1.8.0-bin.tar.gz</span><br></pre></td></tr></table></figure><ul><li>1.解压并重命名</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf apache-flume-1.8.0-bin.tar.gz -C /hadoop/install/</span><br><span class="line"><span class="built_in">cd</span> /hadoop/install</span><br><span class="line">mv apache-flume-1.8.0-bin apache-flume-1.8.0</span><br></pre></td></tr></table></figure><ul><li>2.配置环境变量</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br></pre></td></tr></table></figure><p>添加内容:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> FLUME_HOME=/hadoop/install/apache-flume-1.8.0</span><br><span class="line"><span class="built_in">export</span> FLUME_CONF_DIR=<span class="variable">$FLUME_HOME</span>/conf</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$HADOOP_HOME</span>/bin:<span class="variable">$HIVE_HOME</span>/bin:<span class="variable">$ZK_HOME</span>/bin:<span class="variable">$HBASE_HOME</span>/bin:<span class="variable">$FLUME_HOME</span>/bin</span><br></pre></td></tr></table></figure></p><ul><li><p>3.修改配置文件</p><ul><li><p>3.1.修改flume-env.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /hadoop/install/apache-flume-1.8.0/conf</span><br><span class="line"><span class="comment"># 拷贝出模板</span></span><br><span class="line">cp flume-env.sh.template flume-env.sh</span><br><span class="line"><span class="comment"># 修改配置文件</span></span><br><span class="line">vi flume-env.sh</span><br></pre></td></tr></table></figure></li><li><p>3.2.修改flume-conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp flume-conf.properties.template flume-conf.properties</span><br><span class="line">vi flume-conf.properties</span><br></pre></td></tr></table></figure><p>添加agent、source、channel和sink的相关信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The configuration file needs to define the sources, the channels and the sinks.</span></span><br><span class="line"><span class="comment"># Sources, channels and sinks are defined per agent, in this case called 'a1'</span></span><br><span class="line">a1.sources=r1</span><br><span class="line">a1.channels=c1</span><br><span class="line">a1.sinks=k1</span><br><span class="line"> </span><br><span class="line"><span class="comment">#Describe/configure the source</span></span><br><span class="line">a1.sources.r1.type=netcat</span><br><span class="line">a1.sources.r1.bind=192.168.52.110</span><br><span class="line">a1.sources.r1.port=44444</span><br><span class="line">a1.sources.r1.channels=c1</span><br><span class="line"></span><br><span class="line"><span class="comment">#Describe the sink</span></span><br><span class="line">a1.sinks.k1.type=logger</span><br><span class="line">a1.sinks.k1.channel=c1</span><br><span class="line"> </span><br><span class="line"><span class="comment">#Describe the channel</span></span><br><span class="line">a1.channels.c1.type=memory</span><br><span class="line">a1.channels.c1.capacity=1000</span><br><span class="line">a1.channels.c1.transcationCapacity=100</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>配置文件说明：| 配置项名称                 | 作用                                                         | 举例                                                      || ---------------- | ------------------------ | ------------------ || agent1                     | flume节点名称，启动时通过参数命令-name指定                   |                                                           || agent1.sources             | 监听的源,可以有多个，空格隔开即可，用于收集数据并发送到channel | agent1.sources=s1 s2                                      || agent1.channels            | 临时通道，可以有多个，空格隔开，存放source收集的数据，sink从这里读取数据 | agent1.channels=c1                                        || agent1.sinks               | 接收器，可以有多个，空格隔开，从channel读取数据，并发送给目标 （比如kafka 或者hdfs或者另一个flume） | agent1.sinks=k1                                           || agent.sources.s1.type      | 源的类型，s1是源名称，可以是目录、日志文件、或者监听端口等。 常用的source的类型包括avro、exec、netcat、spooldir和syslog等. 具体请参考官网[http://flume.apache.org/Flume...](http://flume.apache.org/FlumeUserGuide.html#flume-sources) | agent.sources.s1.type=spooldir agent.sources.s2.type=avro || agent1.sources.s1.channels | 监听数据要写入的channel名称                                  | agent1.sources.s1.channels=c1                             || agent1.channels.c1.type    | 通道的类型，c1为通道名称，此处memory表示为常用的memory-channel， 同时也有其他类型的channel，如JDBC、file-channel、custom-channel等， 具体请参考官网[http://flume.apache.org/Flume...](http://flume.apache.org/FlumeUserGuide.html#flume-channels) | agent1.channels.c1.type=memory                            || agent1.sinks.k1.type       | 接收器类型，k1为接收器名称，此处logger表示直接写入日志， 常用的包括avro、logger、HDFS、Hbase以及file-roll等， 具体参考官网[http://flume.apache.org/Flume...](http://flume.apache.org/FlumeUserGuide.html#flume-sinks) | agent1.sinks.k1.type=logger                               |</code></pre><ul><li><p>4.启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/flume-ng agent --conf &lt;conf路径&gt; --conf-file &lt;flume-conf.properties路径&gt; --name &lt;agent名称&gt; -Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure><p>启动命令参数说明：</p></li></ul><table><thead><tr><th>参数</th><th>作用</th><th>举例</th></tr></thead><tbody><tr><td>–conf 或 -c</td><td>指定配置文件夹，包含flume-env.sh和log4j的配置文件</td><td>–conf conf</td></tr><tr><td>–conf-file 或 -f</td><td>配置文件地址</td><td>–conf-file conf/flume.conf</td></tr><tr><td>–name 或 -n</td><td>agent(flume节点)名称</td><td>–name agent1</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /hadoop/install/apache-flume-1.8.0</span><br><span class="line"><span class="comment"># 启动命令:</span></span><br><span class="line">./bin/flume-ng agent --conf ./conf --conf-file ./conf/flume-conf.properties --name a1 -Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure><ul><li>5.测试是否运行成功：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 192.168.52.110 44444</span><br></pre></td></tr></table></figure><h3 id="六、测试收集日志到HDFS"><a href="#六、测试收集日志到HDFS" class="headerlink" title="六、测试收集日志到HDFS"></a>六、测试收集日志到HDFS</h3><ul><li>1.新建配置2</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /hadoop/install/apache-flume-1.8.0/conf</span><br><span class="line">cp flume-conf.properties.template flume-conf2.properties</span><br><span class="line">vi flume-conf2.properties</span><br></pre></td></tr></table></figure><ul><li><p>2.配置2内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1</span><br><span class="line">a1.channels = c1</span><br><span class="line">a1.sources.r1.type = exec</span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sources.r1.command = tail -F /hadoop/install/hadoop/logs/hadoop-namenode-b393a04554e1.log</span><br><span class="line">a1.sinks.k1.type = hdfs</span><br><span class="line">a1.sinks.k1.channel = c1</span><br><span class="line">a1.sinks.k1.hdfs.path = hdfs://master:54310/class12/out_flume</span><br><span class="line">a1.sinks.k1.hdfs.filePrefix = events-</span><br><span class="line">a1.sinks.k1.hdfs.round = true</span><br><span class="line">a1.sinks.k1.hdfs.roundValue = 10</span><br><span class="line">a1.sinks.k1.hdfs.roundUnit = minute</span><br><span class="line">a1.sinks.k1.hdfs.rollSize = 4000000</span><br><span class="line">a1.sinks.k1.hdfs.rollCount = 0</span><br><span class="line">a1.sinks.k1.hdfs.writeFormat = Text</span><br><span class="line">a1.sinks.k1.hdfs.fileType = DataStream</span><br><span class="line">a1.sinks.k1.hdfs.batchSize = 10</span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line">a1.channels.c1.capacity = 1000</span><br><span class="line">a1.channels.c1.transactionCapacity = 100</span><br></pre></td></tr></table></figure></li><li><p>3.使用配置2启动</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /hadoop/install/apache-flume-1.8.0</span><br><span class="line"></span><br><span class="line">./bin/flume-ng agent --conf ./conf/ --conf-file ./conf/flume-conf2.properties --name a1 -Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flume是一个分布式、可靠、高可用的海量日志聚合系统，支持在系统中定制各类数据发送方，用于收集数据；同时Flume提供对数据的简单处理，并写到各种数据接收方的能力。&lt;/p&gt;
&lt;p&gt;本文章主要介绍 Flume 和 在centos环境下如何安装 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="大数据" scheme="https://lightalight.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="flume" scheme="https://lightalight.github.io/tags/flume/"/>
    
  </entry>
  
</feed>
