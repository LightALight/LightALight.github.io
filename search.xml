<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[安全性测试（一）安全性测试的基本概念]]></title>
    <url>%2F2021%2F10%2F15%2F%E5%AE%89%E5%85%A8%E6%80%A7%E6%B5%8B%E8%AF%9501%2F</url>
    <content type="text"><![CDATA[软件因为漏洞，导致产品的数据泄露、功能受到影响和系统被入侵等危害。安全测试就是为了发现这些问题，并给予一定的安全评估。本文章主要介绍如何进行软件的安全性测试。 Quick Guide安全方面 应用程序层的安全 应用程序本身的安全性 应用程序的数据安全 操作系统的安全 网络的安全 安全测试的要求 熟悉常见漏洞、逻辑漏洞的原理和检测方式 较强编程能力，能使用脚本或者安全工具检测漏洞 做好安全评估 漏洞外部攻击方式 种类 类型 简单描述 通用漏洞 暴力破解 利用密码字典循环去破解密码 通用漏洞 SQL注入 注入攻击漏洞,这些攻击发生在当不可信的SQL语句作为命令或者查询语句的一部分,被发送给解释器的时候。攻击者发送的恶意数据可以欺骗解释器,以执行计划外的命令或者在未被恰当授权时访问数据。 通用漏洞 XPath注入 XPath注入攻击是指利用XPath 解析器的松散输入和容错特性，能够在URL、表单或其它信息上附带恶意的XPath 查询代码，以获得权限信息的访问权并更改这些信息。XPath注入攻击是针对Web服务应用新的攻击方法，它允许攻击者在事先不知道XPath查询相关知识的情况下，通过XPath查询得到一个XML文档的完整内容。 通用漏洞 不安全的加密存储 未对需要保护的数据进行加密或者加密算法太弱都是不安全的加密存储 通用漏洞 敏感信息泄露 许多Web应用程序没有正确保护敏感数据,如信用卡、税务ID和身份验证凭据。攻击者可能会窃取或篡改这些弱保护的数据以进行信用卡诈骗、身份窃取或其他犯罪。敏感数据值需额外的保护,比如在存放或在传输过程中的加密,以及在与浏览器交换时进行特殊的预防措施。 通用漏洞 XSS跨站脚本攻击 恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意用户的特殊目的。 通用漏洞 CSRF跨站请求伪造 攻击者通过调用第三方网站的恶意脚本来伪造请求，在用户不知情的情况下，攻击者强行递交构造的具有“操作行为”的数据包。（测试对象：网页中可进行输入的表单） 逻辑漏洞 篡改输入 利用一些命令或者工具等篡改一些字段的值，从而达到恶意的效果。例如，篡改商品的单价和数量等。 逻辑漏洞 不安全的直接对象引用 在具有导出/下载功能的页面参数中修改内容，WEB服务器便会导出/下载程序源代码或者指定文件（测试对象：URL中有用户参数的地址，可以进行下载操作的地址）或者当开发人员暴露一个对内部实现对象的引用时,例如,一个文件、目录或者数据库密匙, 就会产生一个不安全的直接对象引用。在没有访问控制检测或其他保护时,攻击者会操控这些引用去访问未授权数据 逻辑漏洞 功能级访问控制缺失 大多数Web应用程序的功能在UI页面显示之前,会验证功能级别的访问权限。但是,应用程序需要在每个功能被访问时在服务器端执行相同的访问控制检查。如果请求没有被验证,攻击者能够伪造请求从而在未经适当授权时访问功能。 逻辑漏洞 缓冲区溢出 当计算机向缓冲区内填充数据位数时超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上。 逻辑漏洞 失效的身份验证机制 只对首次传递的Cookie加以验证，程序没有持续对Cookie中内含信息验证比对，攻击者可以修改Cookie中的重要信息以提升权限进行网站数据存取或是冒用他人账号取得个人私密资料（测试对象：可以进行传参的URL，提交请求页面，登录后的Cookie） 逻辑漏洞 会话管理劫持 检测Web应用程序会话机制是否存在安全隐患，能否被非法利用（会话劫持，伪装成合法用户）而影响Web应用程序的安全。 逻辑漏洞 没有限制URL访问 系统已经对URL的访问做了限制，但这种限制却实际并没有生效。攻击者能够很容易的就伪造请求直接访问未被授权的页面（测试对象：需要身份验证的页面） 逻辑漏洞 传输层保护不足 在身份验证过程中没有使用SSL/TLS，因此暴露传输数据和会话ID，被攻击者截听。它们有时还会使用过期或者配置不正确的证书。（测试对象：登录模块） 逻辑漏洞 未验证的重定向（redirectUrl）和转发 攻击者可以引导用户访问他们所要用户访问的站点。而最终造成的后果，重定向会使得用户访问钓鱼网站或是恶意网站。 配置漏洞 安全配置错误 Config中的链接字符串以及用户信息，邮件，数据存储信息等都需要加以保护，如果没有进行保护，那么就是安全配置出现了问题。 APP漏洞 逆向反编译 通过提供的安装包或者客户端，反编译出原代码获取信息 系统漏洞 LDAP注入 利用LDAP注入技术的关键在于控制用于目录搜索服务的过滤器。使用这些技术，攻击者可能直接访问LDAP目录树下的数据库，及重要的公司信息。情况还可能比这更严重，因为许多应用的安全性依赖于基于LDAP目录的单点登录环境。 系统漏洞 使用含有已知漏洞的组件 组件,比如:库文件、框架和其他软件模块,几乎总是以全部的权限运行。如果使用含有已知漏洞的组件,这种攻击可以造成更为严重的数据丢失或服务器接管。应用程序使用带有已知漏洞的组件会破坏应用程序防御系统,并使一系列可能的攻击和影响成为可能。危害比较严重 系统漏洞 操作系统漏洞 利用操作系统的漏洞，引发系统故障或者窃取信息 网络 DDoS 流量攻击，一种针对网络带宽的攻击，即大量攻击包导致网络带宽被阻塞，合法网络包被虚假的攻击包淹没而无法到达主机；一种是为资源耗尽攻击，主要是针对服务器主机的攻击，即通过大量攻击包导致主机的内存被耗尽或CPU被内核及应用程序占完而造成无法提供网络服务 内部攻击方式社会工程学：通过对人的习惯、心里和数据分析，伪装或者欺骗内部人员获取信息。 检测使用专业的具有特定功能的安全扫描软件来寻找潜在的漏洞，将已经发生的缺陷纳入缺陷库，然后通过自动化测试方法来使用自动化缺陷库进行轰炸测试。 安全测试工具 Kali Linux：基于Debian的Linux发行版， 设计用于数字取证操作系统。Kali Linux预装了许多渗透测试软件，包括nmap 、Wireshark 、msfvenom、John the Ripper，以及Aircrack-ng，超过300个渗透测试工具，永久免费，开源. Nmap:一个网络连接端扫描软件，用来扫描网上电脑开放的网络连接端。确定哪些服务运行在哪些连接端，并且推断计算机运行哪个操作系统（这是亦称 fingerprinting）。 参考 msfvenom:msfpayload,msfencode的结合体，可利用msfvenom生成木马程序,并在目标机上执行,在本地监听上线。 参考 AppScan:一款安全漏洞扫描工具，支持Web和移动，现在安全测试做漏洞扫描非常适用，它相当于是”探索”和”测试”的过程，最终生成很直观的测试报告，有助于研发人员分析和修复通常安全测试工具用这个，扫描一些安全漏洞，用起来比较方便，网上资料比较多，适合很多测试同学用，资料广阔，大家可以尝试下。 参考 Burp Suite:一款信息安全从业人员必备的集 成型的渗透测试工具，它采用自动测试和半自动测试的方式，包含了 Proxy,Spider,Scanner,Intruder,Repeater,Sequencer,Decoder,Comparer等工具模块；Proxy功能可以拦截HTTP/S的代理服务器（手机和web）；Spide功能-智能感应的网络爬虫；Intruder功能可以对web应用程序进行自动化攻击等，非常适合做安全测试。通 过拦截HTTP/HTTPS的web数据包，充当浏览器和相关应用程序的中间人，进行拦截、修改、重放数据包进行测试，是web安全人员的一把必备的瑞士军刀。 参考 Acunetix:一款网络漏洞扫描软件，它可以检测网络的安全漏洞。 sqlmap:一个开源的渗透测试工具，可以用来进行自动化检测，利用SQL注入漏洞，获取数据库服务器的权限。它具有功能强大的检测引擎,针对各种不同类型数据库的渗透测试的功能选项，包括获取数据库中存储的数据，访问操作系统文件甚至可以通过外带数据连接的方式执行操作系统命令。 下载地址 演示视频 教程 参考 OpenVAS:一个开放式漏洞评估系统，也可以说它是一个包含着相关工具的网络扫描器。其核心部件是一个服务器，包括一套网络漏洞测试程序，可以检测远程系统和应用程序中的安全问题。OpenVas服务端只允许安装在Linux系统上，接下来我们来介绍一下使用二进制搭建OpenVas的方法以及基础的使用。 参考 fortify:静态代码检查工具 参考 nessus:一款号称是世界上最流行的漏洞扫描程序，全世界有超过75000个组织在使用它。该工具提供完整的电脑漏洞扫描服务，并随时更新其漏洞数据库。Nessus不同于传统的漏洞扫描软件，Nessus可同时在本机或远端上遥控，进行系统的漏洞分析扫描。 参考 zap:OWASP Zed攻击代理（ZAP）是世界上最受欢迎的免费安全审计工具之一，由数百名国际志愿者*积极维护。它可以帮助您在开发和测试应用程序时自动查找Web应用程序中的安全漏洞。 Acunetix Web Vulnerability Scanner（简称AWVS）:是一款知名的网络漏洞扫描工具，它通过网络爬虫测试你的网站安全，检测流行安全漏洞 测试场景设计 正向安全测试 反向安全测试 正向测试过程是以测试空间为依据寻找缺陷和漏洞，反向测试过程则是以已知的缺陷空间为依据去寻找软件中是否会发生同样的缺陷和漏洞，两者各有其优缺点。反向测试过程主要的一个优点是成本较低，只要验证已知的可能发生的缺陷即可，但缺点是测试不完善，无法将测试空间覆盖完整，无法发现未知的攻击手段。正向测试过程的优点是测试比较充分，但工作量相对来说较大。因此，对安全性要求较低的软件，一般按反向测试过程来测试即可，对于安全性要求较高的软件，应以正向测试过程为主，反向测试过程为辅。 正向安全测试为了规避反向设计原则所带来的测试不完备性，需要一种正向的测试方法来对软件进行比较完备的测试，使测试过的软件能够预防未知的攻击手段和方法。 先标识测试空间。对测试空间的所有的可变数据进行标识，由于进行安全性测试的代价高昂，其中要重点对外部输入层进行标识。例如，需求分析、概要设计、详细设计、编码这几个阶段都要对测试空间进行标识，并建立测试空间跟踪矩阵。 精确定义设计空间。重点审查需求中对设计空间是否有明确定义，和需求牵涉到的数据是否都标识出了它的合法取值范围。在这个步骤中，最需要注意的是精确二字，要严格按照安全性原则来对设计空间做精确的定义。 标识安全隐患。根据找出的测试空间和设计空间以及它们之间的转换规则，标识出哪些测试空间和哪些转换规则可能存在安全隐患。例如,测试空间愈复杂，即测试空间划分越复杂或可变数据组合关系越多也越不安全。还有转换规则愈复杂，则出问题的可能性也愈大，这些都属于安全隐患。 建立和验证入侵矩阵。安全隐患标识完成后，就可以根据标识出来的安全隐患建立入侵矩阵。列出潜在安全隐患，标识出存在潜在安全隐患的可变数据，和标识出安全隐患的等级。其中对于那些安全隐患等级高的可变数据，必须进行详尽的测试用例设计。 反向安全测试大部分软件的安全测试都是依据缺陷空间反向设计原则来进行的，即事先检查哪些地方可能存在安全隐患，然后针对这些可能的隐患进行测试。因此，反向测试过程是从缺陷空间出发，建立缺陷威胁模型，通过威胁模型来寻找入侵点，对入侵点进行已知漏洞的扫描测试。好处是可以对已知的缺陷进行分析，避免软件里存在已知类型的缺陷，但是对未知的攻击手段和方法通常会无能为力。 建立缺陷威胁模型。建立缺陷威胁模型主要是从已知的安全漏洞入手，检查软件中是否存在已知的漏洞。建立威胁模型时，需要先确定软件牵涉到哪些专业领域，再根据各个专业领域所遇到的攻击手段来进行建模。 寻找和扫描入侵点。检查威胁模型里的哪些缺陷可能在本软件中发生，再将可能发生的威胁纳入入侵点矩阵进行管理。如果有成熟的漏洞扫描工具，那么直接使用漏洞扫描工具进行扫描，然后将发现的可疑问题纳入入侵点矩阵进行管理。 入侵矩阵的验证测试。创建好入侵矩阵后，就可以针对入侵矩阵的具体条目设计对应的测试用例，然后进行测试验证。 测试方法 静态的代码安全测试：主要通过对源代码进行安全扫描，根据程序中数据流、控制流、语义等信息与其特有软件安全规则库进行匹对，从中找出代码中潜在的安全漏洞。静态的源代码安全测试是非常有用的方法，它可以在编码阶段找出所有可能存在安全风险的代码，这样开发人员可以在早期解决潜在的安全问题。而正因为如此，静态代码测试比较适用于早期的代码开发阶段，而不是测试阶段。 动态的渗透测试：渗透测试也是常用的安全测试方法。是使用自动化工具或者人工的方法模拟黑客的输入，对应用系统进行攻击性测试，从中找出运行时刻所存在的安全漏洞。这种测试的特点就是真实有效，一般找出来的问题都是正确的，也是较为严重的。但渗透测试一个致命的缺点是模拟的测试数据只能到达有限的测试点，覆盖率很低。 程序数据扫描。一个有高安全性需求的软件，在运行过程中数据是不能遭到破坏的，否则就会导致缓冲区溢出类型的攻击。数据扫描的手段通常是进行内存测试，内存测试可以发现许多诸如缓冲区溢出之类的漏洞，而这类漏洞使用除此之外的测试手段都难以发现。例如，对软件运行时的内存信息进行扫描，看是否存在一些导致隐患的信息，当然这需要专门的工具来进行验证，手工做是比较困难的。 如何练习 [搭建一个靶机])(https://www.freebuf.com/sectool/102661.html) 进行攻击练习 修复漏洞，再次测试攻击，查看结果是否有效 安全性评估当做完安全性测试后，软件是否能够达到预期的安全程度呢?这是安全性测试人员最关心的问题，因此需要建立对测试后的安全性评估机制。一般从以下两个方面进行评估。 安全性缺陷数据评估。如果发现软件的安全性缺陷和漏洞越多，可能遗留的缺陷也越多。进行这类评估时，必须建立基线数据作为参照，否则评估起来没有依据就无法得到正确的结论。 采用漏洞植入法来进行评估。漏洞植入法和可靠性测试里的故障插入测试是同一道理，只不过这里是在软件里插入一些有安全隐患的问题。采用漏洞植入法时，先让不参加安全测试的特定人员在软件中预先植入一定数量的漏洞，最后测试完后看有多少植入的漏洞被发现，以此来评估软件的安全性测试做得是否充分。 安全建议层面 管理层 技术：建立高效统一的安全管理和权限划分，如集中授权、认证、用户和日志管理等 非技术：流程化、制度化去加强安全意识和规范 应用层 业务安全：防止恶意攻击 应用设计安全：认证、口令策略、访问控制和授权、加密、会话管理、日志、数据包含和运行安全等 应用编码安全：输入校验、输出编码、文件上传下载、异常处理、安全API等 系统层：操作系统、数据库系统、中间间系统等 安全加固：最小化安装、最小化服务、最强口令策略、内核参数优化等 恶意软件防护：防病毒、主机防火墙等 网络层：网络设备保护、网络拓朴安全设计、网络边界保护（如防火墙）、网络数据加密（如VPN）、网络安全检测（如IDS\IPS）等 原则 最小授权：只授予每个用户/程序在执行操作时所必须的最小特权。这样可以限制事故、错误、攻击带来的危害，减小特权程序之间潜在的相互影响。 发生故障优先保证安全：当系统发生故障时，对任何请求默认应加以拒绝。 深入防御原则：采用多层安全机制，这个概念范围比较大。比如在表单中的字段校验不光要在页面校验，还要在后台有相应的校验机制；比如在信任区、飞信任区之间二次部署防火墙。 权限分离：比如禁止root用户远程登录、多重身份校验登陆等； 系统架构设计和代码尽可能简洁，越复杂的系统，bug越多 共享事务的数量和使用尽可能少，毕竟单独控制一个操作比并行控制两个过程更容易一些； 安全保护机制不能依赖于攻击者对系统实现过程的无知、而只依赖于像口令/密钥这样较容易改变的东西。 不信任原则：要严格限制用户、外部部件的信任度，要假设他们都是不安全的。 对受保护的对象的每一个访问都要经过检查。 心理接受程度：不能通过限制、甚至组织用户访问系统资源来阻止攻击，但可以考虑引入少量可接受的使用障碍。 不要等开发人员编码完成才开始进行安全测试，可以负责任的将，65%以上的安全漏洞都是发生在架构设计阶段，因此要积极参与到架构设计评审活动中，将一些低中级别的隐患扼杀在摇篮中。]]></content>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App测试(四) Android Studio 连接手机进行调试]]></title>
    <url>%2F2021%2F09%2F15%2FApp%E6%B5%8B%E8%AF%9504%2F</url>
    <content type="text"><![CDATA[Android Studio 是谷歌推出的一个Android集成开发工具，基于IntelliJ IDEA. 类似 Eclipse ADT，Android Studio 提供了集成的 Android 开发工具用于开发和调试。文章介绍Android Studio的基本使用。 Quick Guide配置创建第一个项目 进入AndroidStudio官网 点击Download进行下载 创建第一个项目如果用kotlin 开发就选择【Empty Compose Activity】 【tools】-&gt;【SDK Manager】-&gt;【SDK Tools】 下载Android Emulator 和Android SDK Platform-Tools 可以先试试AS自带的模拟器 点击create device 选择一种型号的设备下载 然后运行项目就可以看到效果啦 连接手机进行调试ADB环境配置 查看自己Android Studio配置的sdk路径【tools】-&gt;【SDK Manager】比如我的路径是C:\Users\Admin\AppData\Local\Android\Sdk 配置环境变量：右键【我的电脑】-&gt;【高级系统设置】-&gt;【环境变量】，新建变量【Android_Home】 然后在Path变量中，新增加一项%Android_Home%(即为相对路径)： 打开cmd窗口，输入adb, 出现如下图就说明安装好啦 配置USB Driver 下载Google USB Driver【tools】-&gt;【SDK Manager】-&gt;【SDK Tools】 将手机用USB线连接到电脑，打开设备管理器，找到你的手机 右键点击你的手机名称，选择【更新驱动设备】 然后再选择【浏览我的电脑以查找驱动程序】 找到usb_driver的安装路径(默认情况在SDK文件路径下的extras\google\usb_driver),最后点击下一页完成更新就好啦 打开手机的开发者模式（不同手机不一样，自行百度，这里附上华为nova系列） 安卓系统的参考这篇文章：https://www.iefans.net/info/v944581.html 鸿蒙系统:【设置】-&gt; 【系统和更新】-&gt;【开发人员选项】-&gt;【USB调试】,选择允许USB调试 连接手机调试（USB线）,显示手机设备 然后选择手机，点击运行，就可以在手机上调试 功能查看性能需要app开启debug模式 根据以下操作步骤选择对应链接的手机，并且手机上启动APP 此时进行app操作即可查看以下信息 在页面内点击任意一个位置 进入到具体信息页面 查看日志需要app开启debug模式 截图 设置无线连接 手机和电脑连入同一个无线网络 手机连接电脑，在命令行输入adb tcpip 5555 断开连接线，命令行输入adb connect 10.3.6.59(手机的IP地址) 提示连接成功后，可以进行无线调试了 问题Failed to find Build Tools revision 30.0.3取消然后再选中Show package detail，然后下载30.0.3]]></content>
      <tags>
        <tag>app</tag>
        <tag>AndroidStudio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App测试(三) Monkey的基本使用]]></title>
    <url>%2F2021%2F08%2F15%2FApp%E6%B5%8B%E8%AF%9503%2F</url>
    <content type="text"><![CDATA[Monkey 测试是通过向系统发送伪随机的用户事件流（如按键输入、触摸屏输入、手势输入等），实现对应用程序客户端的稳定性测试；通俗来说，Monkey 测试即“猴子测试”，是指像猴子一样，不知道程序的任何用户交互方面的知识，就对界面进行无目的、乱点乱按的操作；Monkey 测试是一种为了测试软件的稳定性、健壮性的快速有效的方法；Monkey 程序是 Android 系统自带的，由 Java 语言写成，在 Android 文件系统中的存放路径是： /system/framework/monkey.jar；Monkey 程序需要通过 adb 来运行。文章介绍Monkey的基本使用。 Quick Guide一、monkey启动步骤 连接设备 adb shell cd /system/bin 输入monkey 二、关闭monkey adb shell ps 查看进程 查出 com.android.commands.monkey 进程ID adb shell kill pid 杀死monkey进程 三、monkey 命令1adb shell monkey [options] &lt;event-count&gt; -options 指monkey传入的参数，不指定则为无反馈启动，把事件任意发送到目标环境的全部包中 -\ 指随机发送时间数。如输入100就执行100个随机事件。 四、操作事件1.触摸事件按下抬起的操作，可通过–pct–touch 配置事件百分比（是由一组ACTION_DOWN和ACTION_UP）组成 2.手势事件指按下、移动、抬起、直线滑动的操作。通过–pct–motion配置百分比（由ACTION_DOWN和ACTION_MOVE和ACTION_UP组成） 3.二指缩放事件通过–pct–pinchzoom配置， 4.轨迹事件由一个或多个随机移动组成，通过–pct-tracball 5.旋转屏幕通过–pct-rotation配置百分比 6.基本导航事件现在基本没有 7.主要导航事件主要是中间键、back、菜单按键。通过–pct-majornav配置 8.系统按键事件如home、back、音量调节等，通过–pct-syskeys配置 9.启动activity事件手机开启一个activity。随机执行一个startactivity（）方法 10.键盘事件通过–pct-flip配置 五、monkey 参数1.常规参数123# 帮助类参数monkey -h adb shell monkey -v &lt;event-count&gt; -v打印出日志。每个-v增加反馈信息级别，-v越多越详细，最多三个 2.事件类参数1234567adb shell monkey -f /mnt/sdcard/test1 执行脚本文件adb shell monkey -s 666 100 ; -s可以重复执行之前的随机操作。每次随机事件默认生成一个seedadb shell monkey --throttle 3000 5; --throttle 每个指令之间增加间隔时间adb shell monkey -v -v --pct-touch 100 200; 调整触摸事件百分比等 六、约束类参数1.包约束 (只访问包里的activity)1adb shell monkey -p com.tal.kaoyan 500 2.activity约束1adb shell monkey -c Intent.CATEGORY_LAUNCHER 1000 七、调试类参数1.程序崩溃侯继续发送事件1adb shell monkey --ignore-crashes &lt;event-count&gt; 2.超时错误继续发送事件1adb shell monkey --ignore-timeouts 3.应用程序权限错误发生后继续发送事件1adb shell monkey --ignore-security-exceptions 八、案例 测试是指定应用，因此需要使用-p指定被测app包名：com.tal.kaoyan 这个测试的目的是希望模拟用户操作，因此需要让Monkey执行的事件尽可能地接近用户的常规操作，这样才可以最大限度地发现用户使用过程中可能出现的问题。因此需要对Monkey执行的事件百分比做一些调整: 触摸事件和手势事件是用户最常见的操作，所以通过–pct-touch和–pct-motion将这两个事件的占比调整到40%与25%；目标应用包含了多个Activity，为了能覆盖大部分的Activity，所以通过–pct-appswitch将Activity切换的事件占比调整到10%；被测应用在测试中出现过不少横竖屏之间切换的问题，这个场景也必须关注，因此通过–pct-rotation把横竖屏切换事件调整到10%。 使用-s参数来指定命令执行的seed值 Monkey会根据seed值来生成对应事件流，同一个seed生成的事件流是完全相同的。这里指定了seed值，是为了测试发现问题时，便于进行问题复现。 使用–throttle参数来控制Monkey每个操作之间的时间间隔 指定操作之间的时间间隔，一方面是希望能更接近用户的操作场景，正常用户操作都会有一定的时间间隔；另一方面也是不希望因为过于频繁的操作而导致系统崩溃，尤其是在比较低端的手机上执行测试时。因此通过–throttle设置Monkey每个操作固定延迟0.4秒。 使用–ignore-crashs和–ignore-timeouts参数使Monkey遇到意外时能继续执行 在执行Monkey测试时，会因为应用的崩溃或没有响应而意外终止，所以需要在命令中增加限制参数–ignore-crash和–ignore-timeouts，让Monkey在遇到崩溃或没有响应的时候，能在日志中记录相关信息，并继续执行后续的测试。 使用-v指定log的详细级别 Monkey的日志输出有3个级别：日志的级别越高，其详细程度也越高。为了方便问题的定位，这里将日志设为 -v -v. 1adb shell monkey -p com.tal.kaoyan –pct-touch 40 –pct-motion 25 –pct-appswitch 10 –pct-rotation 5 -s 1666 –throttle 400 –ignore-crashes –ignore-timeouts -v -v 200 九、monkey脚本稳定性测试按照规范写好脚本，放在手机里，通过monkey -f调用脚本 1.脚本api123456789101112131415161718192021LaunchActivity(pkg_name, cl_name)：启动应用的Activity。参数：包名和启动的Activity。Tap(x, y, tapDuration)： 模拟一次手指单击事件。参数：x,y为控件坐标，tapDuration为点击的持续时间，此参数可省略。UserWait(sleepTime)： 休眠一段时间DispatchPress(keyName)： 按键。参数： keycode。 RotateScreen(rotationDegree, persist)： 旋转屏幕。 参数：rotationDegree为旋转角度， e.g. 1代表90度；persist表示旋转之后是否固定，0表示旋转后恢复，非0则表示固定不变。DispatchString(input)： 输入字符串。DispatchFlip(true/false)： 打开或者关闭软键盘。PressAndHold(x, y, pressDuration)： 模拟长按事件。Drag(xStart, yStart, xEnd, yEnd, stepCount)： 用于模拟一个拖拽操作。PinchZoom(x1Start, y1Start, x1End, y1End, x2Start, y2Start, x2End, y2End, stepCount)： 模拟缩放手势。LongPress()： 长按2秒。DeviceWakeUp()： 唤醒屏幕。PowerLog(power_log_type, test_case_status)： 模拟电池电量信息。WriteLog()： 将电池信息写入sd卡。RunCmd(cmd)： 运行shell命令。DispatchPointer(downtime,eventTime,action,x,yxpressure,size,metastate,xPrecision,yPrecision,device,edgeFlags)： 向指定位置，发送单个手势。DispatchPointer(downtime,eventTime,action,x,yxpressure,size,metastate,xPrecision,yPrecision,device,edgeFilags)： 发送按键消息。LaunchInstrumentation(test_name,runner_name)： 运行一个instrumentation测试用例。DispatchTrackball： 模拟发送轨迹球事件。ProfileWait： 等待5秒。StartCaptureFramerate()： 获取帧率。EndCaptureFramerate(input)： 结束获取帧率。 2.脚本格式1234567# Monkey脚本主要包含两部分，一部分是头文件信息，一部分是具体的monkey命令。type = raw eventscount = 1speed = 1.0# 下面为monkey命令start data &gt;&gt;# 具体的monkey脚本内容 3.编写脚本1234567891011121314151617181920212223242526272829#头文件信息type = raw eventscount = 1speed = 1.0#启动测试start data &gt;&gt;LaunchActivity(com.tal.kaoyan,com.tal.kaoyan.ui.activity.SplashActivity)UserWait(2000)Tap(624,900,1000) #点击取消升级UserWait(2000)Tap(806,64,1000) #点击跳过UserWait(2000)Tap(217,378,1000) #点击用户名输入框DispatchString(zxw1234)UserWait(2000)Tap(197,461,1000) #点击密码输入框DispatchString(zxw123456)UserWait(2000)Tap(343,637,1000) #点击登录按钮 4.执行脚本123adb push C:\Users\Shuqing\Desktop\kyb1.txt /sdcardadb shell monkey -f /sdcard/kyb1.txt -v 1 5.注意事项头文件代码书写注意“=”两边预留空格，否则会出现如下报错。 十、日志管理1.日志保存方式 保存pc中 1adb shell monkey -v -v 100 &gt;d:\monkeylog.txt 保存在手机上 12adb shellmonkey -v 100 &gt;/sdcard/monkeylog.log 正常日志和error日志分开保存 1adb shell monkey -v 100 1&gt;d:\monkey.log 2&gt;d:\error.log]]></content>
      <tags>
        <tag>app</tag>
        <tag>monkey</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App测试(二) adb工具的基本使用]]></title>
    <url>%2F2021%2F07%2F15%2FApp%E6%B5%8B%E8%AF%9502%2F</url>
    <content type="text"><![CDATA[adb全称Android Debug Bridge，是Android SDK中的一个工具, 使用adb可以直接操作管理Android模拟器或者真实的Andriod设备，就是起到调试桥的作用。文章介绍adb的基本使用。 Quick Guideadb的安装adb工具包一般只是一个压缩文件，不需要安装，只需要解压即可。解压后有三个必须文件，adb.exe动态链接库文件、adbWinApi.dll和adbWinUsbApi.dll，解压后即可直接使用。如图： adb的基本使用进入到adb目录，cmd打开命令窗口 连接上设备 1adb connect ip 注意：第一次链接失败，再连一次就成功了！ 查看当前连接的所有设备 1adb devices 推送文件到设备 1adb push 电脑文件的路径 /sdcard 在设备上的文件管理器找到相关.apk文件 断开连接 1adb disconnect 常用命令 获取设备列表和设备状态 1adb devices 安装/卸载app 1234567adb install 包信息adb install -r 包信息 //覆盖安装adb install -d 包信息 //安装的版本比手机上的版本低adb uninstall pkname //卸载 将PC机上的文件push到手机上 1adb push 文件 /sdcard/ 将手机上的文件pull到PC机上 1adb pull /sdcard/50.zip（文件） D:\back（路径） 查看adb后台进程 1adb shell ps | findstr adbd 获取当前界面的包名信息 1adb shell dumpsys window | findstr mCurrentFocus app禁用命令、启用命令 123adb shell pm disable-user 包名 # 禁用命令adb shell pm enable 包名 # 启用命令 内存快速填充命令 12# 快速填充1G内存adb shell dd if=/dev/zero of=/sdcard/file bs=1024000 count=1024 获取手机品牌 1adb shell getprop ro.product.brand 截屏 1adb shell screencap -p /sdcard/screenshot.png 重启手机 1adb reboot 一般问题log的抓抓取adb LOG 123456789101112131415161718192021222324# //一般问题log的抓取adb shell -v time &gt; D:\log.txt# 显示问题log的抓取adb shell dumpsys SurfaceFlinger &gt; D:\SF.txt# adb 查看所有进程信息adb shell ps# adb 查看指定关键字的进程信息 *** 为关键字 可以为包名adb shell “ps | grep ***”# adb 查看所有进程的 log信息adb logcat -v process# adb 查看指定PID的log信息adb logcat -v process | grep ****# 查看所有的log日志adb logcat# 过滤查看指定关键字的log ***为关键字adb logcat | grep *** 抓包安装正常 安装chrome 插件 Android Debug Bridge 手机开启调试模式，且手机的包需要时 开发包（dev），然后usb连接手机 浏览器输入 chrome://inspect ，手机进入对应h5页面，然后在浏览器就可以看到并inspect 技巧 Chrome DevTools 调试技巧 最新 Chrome DevTools(v57) 使用详解 问题 1.不能访问404 网络问题：看能不能访问 https://chrome-devtools-frontend.appspot.com/ 浏览器版本：被调试端版本过低（调试端 的浏览器版本 是否低于 被调试）；]]></content>
      <tags>
        <tag>app</tag>
        <tag>adb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App测试(一) App测试的基本概念]]></title>
    <url>%2F2021%2F06%2F15%2FApp%E6%B5%8B%E8%AF%9501%2F</url>
    <content type="text"><![CDATA[文章介绍App测试的基本概念。 Quick Guide测试流程 功能测试 冒烟测试（不符合打回） 特性测试 ui 功能 兼容性测试 合版测试 特性功能 全量功能 渠道包测试 上线测试 版本问题跟踪 测试周期测试周期可按项目的开发周期来确定测试时间，一般测试时间为1~2周（即15个工作日），根据项目情况以及版本质量可适当缩短或延长测试时间。 测试资源测试任务开始前，检查各项测试资源。 产品功能需求文档； 产品原型图； 产品效果图； 行为统计分析定义文档； 测试设备（ios3.1.3-ios5.0.1；Android1.6-Android4.0；Winphone7.1及以上；Symbian v3/v5/Nokia Belle等）； 其他 日报及产品上线报告 测试人员每天需对所测项目发送测试日报。 测试日报所包含的内容为： 对当前测试版本质量进行分级； 对较严重的问题进行例举，提示开发人员优先修改； 对版本的整体情况进行评估。 产品上线前，测试人员发送产品上线报告。 上线报告所包含的内容为： 对当前版本质量进行分级和历史问题记录对比； 附上测试报告（功能测试报告、兼容性测试报告、性能测试报告以及app可用性能标准结果）； 总结上线版本的基本情况。若有遗留问题必须列出并记录解决方案。 版本反馈收集 应用市场 App内反馈系统 埋点技术 测试点非功能测试针对 APP 应用的非功能性需求, 在 APP 应用开发初期, 可能需要对 APP 应用内容本身, 在线下展开针对性的实用性调研测试或者参考友商, 特性测试UI测试 确保原型图和效果图为当前最新版本，符合产品经理及用户需求；测试过程中一切以效果图为准，若有用户体验方面的建议，可以先与产品经理确认，确认通过后，可以正式向开发提出用户体验方面的问题。 在不同环境或者版本下测试出的数据差异需保留 功能测试 按照用户的需求(需求说明书、原型等]去检验开发的代码实现是否满足用户的功能性需求。 测试对象: 功能点(单独模块) —-》流程测试（多模块） 测试方法: 等价类与边界值组合 回归测试验证完特性后，把所有特性功能合成一个版本，对App的所有基本功能（核心功能）进行全面回归 专项测试 兼容性测试 硬件 设备型号 屏幕尺寸 屏幕分辨率 网络类型 软件 系统版本 App版本 不同系统 与主流App是否兼容 安装/卸载/升级测试* 安装类型 Andriod ：.apk ios：.lpa 不同的安装渠道 Andriod 手机的应用商店 第三方软件：豌豆荚 -官网 iOS: 官网 APP Store 不同的系统版本 各种的安装方式 正常情况 正常安装测试,检查是否安装成功 APP版本覆盖测试 回退版本测试 在不同型号、系统、屏幕大小、分辨率上的手机进行安装· 安装完成后:能否正常启动应用程序 安装完成后,重启于机能否正常启动应用程序 异常情况 安装时内存不足 安装过程中的意外情况（强行断电、断网、来电话了、查看信息)等等 能否取消安装 各种卸载方式 正常情况 直接删除安装文件夹卸载是否有提示信息。 用自己的卸载程序进行卸载,检查是否卸载干净 用第三方工具,检查是否卸载干净 不同系统、硬件环境、网络环境下进行卸载 卸载后再次安装，是否正常使用 异常情况 卸载中出现异常情况能否恢复(比如手机关机，内存、没电等)，程序是否还能运行 卸载后是否有残留，是否能够再次进行安装 是否可以取消卸载软件恢复使用 各种升级方式 更新版本需要提示用户 考虑是否进行强制升级 否：可取消升级，但是有提示 是 软件存在严重缺陷 软件不能够向前兼容 是否能够跨版本升级 断点续传 交叉事件测试APP 应用的交叉事件测试又称: 冲突测试或干扰测试。 一般多用于考察应用在运行过程中, 对于外界干扰的处理能力。 测试点: 运行时接收来电/短信/消息推送/收取邮件 运行时出现系统弹窗, 运行时切换外部设备等。 插拔耳机 网络切换 系流自带应用(摄像头、计算器） 多个App同时运行是否影响正常功能 App运行时前/后台切换是否影响正常功能 App运行时切换网络（2G、3G、wifi）/浏览网络/使用蓝牙传送/接收数据 推送消息测试消息推送测试主要目的就是为了唤醒或提醒用户 对象 全部推送 部分推送 精确推送 消息形式 弹窗 消息通知栏 短信 邮件 测试关注点 push消息应该按设定规则发送特定用户 APP在后台运行时，应能正常收到push消息 设备在锁屏状态下，应能正常收到APP的Push消息 设备网络断开重连后，应能收到push消息 系统设置不接受APP通知消息时，用户应该不在收到push消息 在非免打扰时间段，用户能正常收到push。 用户体验度测试APP 应用用户体验度测试主要是从用户使用角度出发, 主观的感知产品或服务的可用, 易用及友好程度的测试形式. 测试点: 界面设计：美观性 功能易用性：保持登录(APP) 页面层级关系在4层左右 横竖屏切换, 系统功能响应等. 是否有空数据界面设计，引导用户去执行操作。 是否滥用用户引导。 是否有不可点击的效果，如：你的按钮此时处于不可用状态，那么一定要灰掉，或者拿掉按钮，否则会给用户误导 菜单层次是否太深 交互流程分支是否太多 相关的选项是否离得很远 一次是否载入太多的数据 界面中按钮可点击范围是否适中 标签页是否跟内容没有从属关系，当切换标签的时候，内容跟着切换 操作应该有主次从属关系 是否定义Back的逻辑。涉及软硬件交互时，Back键应具体定义 是否有横屏模式的设计，应用一般需要支持横屏模式，即自适应设计 稳定性测试APP 应用稳定测试测试一般是通过测试工具实现在一定时间范围内的无序操作, 来检测应用的稳定运行能力, 测试点： 闪退 系统崩溃 没响应 常见的测试工具如下: Monkey UICrawler Maxim 客户端性能测试一款 APP 应用是否优秀不仅仅体现在功能可用性上, 同时也需要关注 APP 应用在不同类型设备上的性能表现, 如果性能表现不够稳定, 则会在一定程度上影响某一部分用户的使用体验. 极限测试：在各种边界压力情况下，如电池、存储、网速等，验证App是否能正确响应。 内存满时安装App 运行App时手机断电 运行App时断掉网络 内存不足 电量不足 响应能力测试：测试App中的各类操作是否满足用户响应时间要求 。（安装包放到云测上可以测试） App安装、卸载的响应时间 App各类功能性操作的影响时间 压力测试：反复/长期操作下、系统资源是否占用异常。（itestin） App反复进行安装卸载，查看系统资源是否正常 其他功能反复进行操作，查看系统资源是否正常 性能评估：评估典型用户应用场景下，系统资源的使用情况。（Jmeter） APP的启动时间是否过长; AFP使用时对CPU、内存的占用情况; APP使用时，电量流星的消耗情况; 反复长期的操作情况下,系统资源的使用情况。 性能测试指标 内存 CPU 流量 电量 启动速度 界面切换速度 内存溢出和内存泄漏 内存溢出oul of mermory，是指程序在申清内存时，没有足够的内存空问供其使用，出现out of memory; 内存泄漏 memory leak，是指程序在申请内存后，无法释放已申请的内存空问，一次内存泄露危害可以忽略,但内存泄露堆积后果很严重,无论多少内存,迟早会被占光;memory leak会最终会导致out of memory 冷启动与热启动 app被后台杀死后，在这个状态打开app，这种启动方式叫做冷启动; 热启动;指app没有被后台杀死，仍然左后台运行，通常我们再次去打T开这个app，这种启动方式叫热启动。 服务端性能测试测试点: 单机容量测试:可以检测到单机服务器在90%的响应时间和成功率都达标的前提下，能够承载多少用户量。 24小时稳定性测试:使用特定游戏模型压测24小时，服务无重启，内存无泄漏，并且各事务成功率达标。 指标 响应时间 吞吐量 并发数 事物通过率等 测试工具: LoadRunner JMeter 安全测试测试点: 反编译性 数据安全 键盘安全 通信保密性及安全策略等方面的验证. 其他测试注册 同表单编辑页面 用户名密码长度 注册后的提示页面 前台注册页面和后台的管理页面数据是否一致 注册后，在后台管理中页面提示 注销 注销原模块，新的模块系统能否正确处理。 终止注销能否返回原模块，原用户。 注销原用户，新用户系统能否正确处理。 使用错误的账号、口令、无权限的被禁用的账号进行注销 登录测试 登录 登录方式 快速登录 免登录 密码修改 多端登录是否限制 密码修改 离线（游客模式） 页面权限控制 跳转登录 导航测试 按钮、对话框、列表和窗口等；或在不同的连接页面之间需要导航 是否易于导航，导航是否直观 是否需要搜索引擎 导航帮助是否准确直观 导航与页面结构、菜单、连接页面的风格是否一致 图形测试 横向比较。各控件操作方式统一 自适应界面设计，内容根据窗口大小自适应 页面标签风格是否统一 页面是否美观 页面的图片应有其实际意义而要求整体有序美观 图片质量要高且图片尺寸在设计符合要求的情况下应尽量小 界面整体使用的颜色不宜过多 内容测试 输入框说明文字的内容与系统功能是否一致 文字长度是否加以限制 文字内容是否表意不明 是否有错别字 信息是否为中文显示 是否有敏感性词汇、关键词 是否有敏感性图片，如：涉及版权、专利、隐私等图片 弱网测试 各个功能正常 可以浏览本地数据 退出app再开启app时能正常浏览 切换到后台再切回前台可以正常浏览 锁屏后再解屏回到应用前台可以正常浏览 在对服务端的数据有更新时会给予离线的相应提示 丢包会重试 最小原则：不能闪退 协议测试直接协议访问，服务端要做校验 定位、照相机服务 App有用到相机，定位服务时，需要注意系统版本差异 有用到定位服务、照相机服务的地方，需要进行前后台的切换测试，检查应用是否正常。 当定位服务没有开启时，使用定位服务，会友好性弹出是否允许设置定位提示。当确定允许开启定位时，能自动跳转到定位设置中开启定位服务。 测试定位、照相机服务时，需要采用真机进行测试。 时间测试 客户端可以自行设置手机的时区、时间，因此需要校验该设置对app的影响。 中国为东8区，所以当手机设置的时间非东8区时，查看需要显示时间的地方，时间是否展示正确，应用功能是否正常。时间一般需要根据服务器时间再转换成客户端对应的时区来展示，这样的用户体验比较好。比如发表一篇微博在服务端记录的是10：00，此时，华盛顿时间为22：00，客户端去浏览时，如果设置的是华盛顿时间,则显示的发表时间即为22:00,当时间设回东8区时间时，再查看则显示为10：00。 测试工具自动化工具 Appium Airtest uiautomator2 稳定性测试工具 Monkey MonkeyRunner Maxim UICrawler 性能测试工具 GT Perfdog SoloPi 弱网测试&amp;抓包工具 QNET Fiddler Charles Whistle 兼容性测试工具 TestIn 腾讯优测 百度MTC 阿里MQC 安全测试工具 OWASP ZAP Drozer MobSF QARK]]></content>
      <tags>
        <tag>app</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang（四）Golang的包管理]]></title>
    <url>%2F2021%2F05%2F15%2FGolang04%2F</url>
    <content type="text"><![CDATA[包是管理整个工程的工具。把同类型的文件放在一个目录，称之为 “包”，多个包构成 一个工程。 本文章主要介绍 Golang 的包管理。 Quick Guide一、包的规则 包名一般是小写的，使用一个简短且有意义的名称。 包名一般要和所在的目录同名，也可以不同，包名中不能包含等特殊符号。 包一般使用域名作为目录名称，这样能保证包名的唯一性，比如 GitHub 项目的包一般会放到GOPATH/src/github.com/userName/projectName目录下。 包名为 main 的包为应用程序的入口包，编译不包含 main 包的源码文件时不会得到可执行文件。 一个文件夹下的所有源码文件只能属于同一个包。 二、自定义包 1.在 GOPATH 的 src 目录下创建一个文件（后缀必须是 .go） 2.文件开头都声明”package &lt;包名,一般是目录名&gt;“ 3,定义包里面的函数,就完成了一个简单的包 三、包的导入要在代码中引用其他包的内容，需要使用 import 关键字导入使用的包。具体语法如下： 1import "包的路径" import 导入语句通常放在源码文件开头包声明语句的下面； 导入的包名需要使用双引号包裹起来； 包名是从GOPATH/src/ 后开始计算的，使用/ 进行路径分隔。 123456789101112131415// 当行导入import "包 1 的路径"import "包 2 的路径"// 多行导入import ( "包 1 的路径" "包 2 的路径")// 绝对路径导入:以GOROOT/src/或GOPATH/src/的路径为起始点,计算被引用包的路径import "database/sql"// 相对路径导入:以引用的文件为起始点,计算被引用包的路径import "../sql" 123456789package main // 声明 main 包import ( "fmt" // 导入 fmt 包，打印字符串是需要用到 myfmt "mylib/fmt" // 命名为 myfmt)func main() &#123; // 声明 main 主函数 fmt.Println("Hello World!") // 打印 Hello World! myfmt.Println("Hello World again!")&#125; 四、包的引用格式包的引用有四种格式，下面以 fmt 包为例来分别演示一下这四种格式。 标准引用格式 1234567package mainimport "fmt"func main() &#123; fmt.Println("标准引用")&#125; 自定义别名引用格式 1234567package mainimport F "fmt"func main() &#123; F.Println("自定义别名引用")&#125; 省略引用格式 12345678package mainimport . "fmt"func main() &#123; //不需要加前缀 fmt. Println("省略引用")&#125; 匿名引用格式：只执行包初始化的 init 函数，而不使用包内部的数据 12345678910package mainimport ( _ "database/sql" "fmt")func main() &#123; fmt.Println("匿名引用")&#125; 五、包的加载当使用main启动这个程序的时候，包就会加载起来，过程如下图： 六、常用的包接下来给大家列一下常用的内置包，可以方便大家使用，省的还需要自己去定义。 1.fmt：格式化的标准输入输出 Printf() ：输出后换行 Println() ：格式化输出 2.io：提供了原始的 I/O 操作界面 3.bufio：各个组件内部都维护了一个缓冲区，数据读写操作都直接通过缓存区进行 bufio 包通过对 io 包的封装，提供了数据缓冲功能，能够一定程度减少大块数据读写带来的开销。 4.sort：提供了用于对切片和用户定义的集合进行排序的功能。 5.strconv：提供了将字符串转换成基本数据类型，或者从基本数据类型转换为字符串的功能。 6.os：提供了不依赖平台的操作系统函数接口 Hostname():返回内核提供的主机名 Environ():返回所有的环境变量，返回值格式为“key=value”的字符串的切片拷贝。 Getenv():会检索并返回名为 key 的环境变量的值。如果不存在该环境变量则会返回空字符串。 Setenv():设置名为 key 的环境变量，如果出错会返回该错误。 Exit():当前程序以给出的状态码 code 退出。 Getwd():回一个对应当前工作目录的根路径。 Mkdir():可以使用指定的权限和名称创建一个目录。 MkdirAll():可以使用指定的权限和名称创建一个目录，包括任何必要的上级目录，并返回 nil，否则返回错误。 Remove():会删除 name 指定的文件或目录。 RemoveAll ():会递归的删除所有子目录和文件。 7.os/exec：提供了执行自定义 linux 命令的相关实现。 8.sync：多线程中锁机制以及其他同步互斥机制 Mutex:互斥锁 RWMutex：读写锁 9.flag：提供命令行参数的规则定义和传入参数解析的功能 10.encoding/json：JSON的序列号和反序列化 11.html/template：web 开发中生成 html 的 template 的一些函数 12.net/http：提供 HTTP 相关服务，主要包括 http 请求、响应和 URL 的解析，以及基本的 http 客户端和扩展的 http 服务。 13.reflect：提供运行时反射，允许程序通过抽象类型操作对象。 14.strings和bytes：提供处理字符串的一些函数集合，包括合并、查找、分割、比较、后缀检查、索引、大小写处理等等。 15.log：用于在程序中输出日志 Print(): 普通输出； Fatal(): 在执行完 Print 后，执行 os.Exit(1)； Panic():在执行完 Print 后调用 panic() 方法。 16.math/big：实现了大数字的多精度计算 Int:有符号整数 Rat:有理数 Float:浮点数 17.regexp:正则表达式 1234567891011121314151617package mainimport ( "fmt" "regexp")func main() &#123; buf := "abc azc a7c aac 888 a9c tac" //解析正则表达式，如果成功返回解释器 reg1 := regexp.MustCompile(`a.c`) if reg1 == nil &#123; fmt.Println("regexp err") return &#125; //根据规则提取关键信息 result1 := reg1.FindAllStringSubmatch(buf, -1) fmt.Println("result1 = ", result1)&#125; 18.time：时间显示和测量等所用的函数 Now()：当前时间 Add() :增加时间 Sub():时间相减 ParseInLocation():字符串转为本地时间 Pta 19.flag：给命令行参数增加描述 七、第三方包的管理go module 是Go语言默认的依赖管理工具。除此之外,还有godep、glide和govendor，这边就不过多描述。 常用命令如下: 1.准备工作，先设置代理 1234// Windows 下设置 GOPROXY 的命令为go env -w GOPROXY=https://goproxy.cn,direct// MacOS 或 Linux 下设置 GOPROXY 的命令为：export GOPROXY=https://goproxy.cn 2.在 GOPATH 目录之外新建一个工程目录，并使用go mod init初始化生成 go.mod 文件。 1go mod init hello go.mod文件内容： 123module go_modgo 1.15 3.创建一个go文件，然后增加依赖引用，并运行它。它就会去自动下载需要的第三方包，放到 GOPATH目录下pkg/mod,并且会更新 go.mod文件。 1234567891011package mainimport ( "github.com/labstack/echo" "net/http")func main() &#123; e := echo.New() e.GET("/", func(c echo.Context) error &#123; return c.String(http.StatusOK, "Hello World!") &#125;)&#125; go.mod文件内容： 123456789module go_modgo 1.15require ( github.com/labstack/echo v3.3.10+incompatible github.com/labstack/gommon v0.3.0 // indirect golang.org/x/crypto v0.0.0-20200820211705-5c72a883971a // indirect) go.mod 提供了 module、require、replace 和 exclude 四个命令： module 语句指定包的名字（路径）； require 语句指定的依赖项模块； replace 语句可以替换依赖项模块； exclude 语句可以忽略依赖项模块。 More info: Golang]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang（三）Go语言的基本语法(下)]]></title>
    <url>%2F2021%2F04%2F15%2FGolang03%2F</url>
    <content type="text"><![CDATA[本文章主要介绍 Golang 的基本语法。 Quick Guide一、容器复杂类型的变量,具有各种形式的存储和处理数据的功能,主要用于编写复杂算法、结构和逻辑。 数组数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。 声明语法如下： 1var 数组变量名 [元素数量]Type 数组变量名：数组声明及使用时的变量名。 元素数量：数组的元素数量，可以是一个表达式，但最终通过编译期计算的结果必须是整型数值，元素数量不能含有到运行时才能确认大小的数值。 Type：可以是任意基本类型，包括数组本身，类型为数组本身时，可以实现多维数组。 12345678910111213141516171819202122package mainimport ( "fmt")func main() &#123; var a [3]int // 定义三个整数的数组 // 访问数组的每个元素可以通过索引下标，索引下标的范围是从 0 开始到数组长度减 1 的位置，内置函数 len() 可以返回数组中元素的个数。 fmt.Println(a[0]) // 打印第一个元素 fmt.Println(a[len(a)-1]) // 打印最后一个元素 // 遍历数组——访问每一个数组元素，打印索引和元素 for i, v := range a &#123; fmt.Printf("%d %d\n", i, v) &#125; // 如果在数组长度的位置出现“...”省略号，则表示数组的长度是根据初始化值的个数来计算 q := [...]int&#123;1, 2, 3&#125; fmt.Printf("%T\n", q) // "[3]int"&#125; 默认情况下，数组的每个元素都会被初始化为元素类型对应的零值。 数组之间的对比可以直接通过较运算符 ==和!= 1234567891011121314package mainimport ( "fmt")func main() &#123; a := [2]int&#123;1, 2&#125; b := [...]int&#123;1, 2&#125; c := [2]int&#123;1, 3&#125; fmt.Println(a == b, a == c, b == c) // "true false false" d := [3]int&#123;1, 2&#125; fmt.Println(a == d) // 编译错误：无法比较 [2]int == [3]int&#125; 多维数组声明语法如下： 1var array_name [size1][size2]...[sizen] array_type array_name 为数组的名字 array_type 为数组的类型 size1、size2 等等为数组每一维度的长度。 1234567891011121314package mainimport ( "fmt")func main() &#123; // 声明一个二维整型数组，两个维度的长度分别是 4 和 2 var array [4][2]int // 使用数组字面量来声明并初始化一个二维整型数组 array = [4][2]int&#123;&#123;10, 11&#125;, &#123;20, 21&#125;, &#123;30, 31&#125;, &#123;40, 41&#125;&#125; // 声明并初始化数组中索引为 1 和 3 的元素 array = [4][2]int&#123;1: &#123;20, 21&#125;, 3: &#123;40, 41&#125;&#125;&#125; 切片切片（slice）是对数组的一个连续片段的引用,就像切糕一样,把数组切出几块,取出其中一块. 语法如下： 1slice [开始位置 : 结束位置] slice：表示目标切片对象； 开始位置：对应目标切片对象的索引； 结束位置：对应目标切片的结束索引。 12345678910package mainimport ( "fmt")func main() &#123; var a = [3]int&#123;1, 2, 3&#125; fmt.Println(a, a[1:2]) // 结果:[1 2 3] [2]&#125; 切片规则 取出的元素数量为：结束位置 - 开始位置； 取出元素不包含结束位置对应的索引，切片最后一个元素使用 slice[len(slice)] 获取； 当缺省开始位置时，表示从连续区域开头到结束位置； 当缺省结束位置时，表示从开始位置到整个连续区域末尾； 两者同时缺省时，与切片本身等效； 两者同时为 0 时，等效于空切片，一般用于切片复位。 123456789101112131415161718package mainimport ( "fmt")func main() &#123; var highRiseBuilding [30]int for i := 0; i &lt; 30; i++ &#123; highRiseBuilding[i] = i + 1 &#125; // 区间 fmt.Println(highRiseBuilding[10:15]) // 中间到尾部的所有元素 fmt.Println(highRiseBuilding[20:]) // 开头到中间指定位置的所有元素 fmt.Println(highRiseBuilding[:2])&#125; 声明切片声明语法如下： 1234567891011121314151617181920212223242526272829var name []Typemake( []Type, size, cap )// make函数用于初始化slice、chan和map// 如果只用var声明，不用make初始化，变量对应的值为nil。// size 元素的个数// cap 从它的第一个元素开始数，到其底层数组元素末尾的个数// 例子package mainimport ( "fmt")func main() &#123; // 声明字符串切片 var strList []string // 声明整型切片 var numList []int // 声明一个空切片 var numListEmpty = []int&#123;&#125; // 输出3个切片 fmt.Println(strList, numList, numListEmpty) a := make([]int, 2) b := make([]int, 2, 10) fmt.Println(a, b) fmt.Println(len(a), len(b)&#125; 切片扩容12345678910111213141516package mainimport ( "fmt")func main() &#123; // 扩展元素,cap不足,低于1000一下是翻倍扩展,大于等于1.25倍增加 var a []int a = append(a, 1) // 追加1个元素 fmt.Println(a) a = append(a, 1, 2, 3) // 追加多个元素, 手写解包方式 fmt.Println(a) a = append(a, []int&#123;1,2,3&#125;...) // 追加一个切片, 切片需要解包 fmt.Println(a)&#125; 切片删除元素123456789101112package mainimport ( "fmt")func main() &#123; a = []int&#123;1, 2, 3&#125; a = a[1:] // 删除开头1个元素 a = append(a[:2], a[2+1:]...) // 删除中间1个元素 a = a[:3-1] // 删除尾部1个元素&#125; 切片复制语法如下： 123456789101112131415copy( destSlice, srcSlice []T) int// 例子package mainimport ( "fmt")func main() &#123; slice1 := []int&#123;1, 2, 3, 4, 5&#125; slice2 := []int&#123;5, 4, 3&#125; copy(slice2, slice1) // 只会复制slice1的前3个元素到slice2中 copy(slice1, slice2) // 只会复制slice2的3个元素到slice1的前3个位置&#125; 多维切片语法如下： 1var sliceName [][]...[]sliceType 映射map是一种元素对（pair）的无序集合，pair 对应一个 key（索引）和一个 value（值），所以这个结构也称为关联数组或字典。 声明语法如下： 12var mapname map[keytype]valuetypemake(map[keytype]valuetype, cap) mapname 为 map 的变量名。 keytype 为键类型。 valuetype 是键对应的值类型。 cap 预设的容量。 123456789101112131415package mainimport "fmt"func main() &#123; mapLit := map[string]int&#123;"one": 1, "two": 2&#125; mapCreated := make(map[string]float32) mapCreated["key1"] = 4.5 mapCreated["key2"] = 3.14159 mapLit["two"] = 3 fmt.Printf("Map literal at \"one\" is: %d\n", mapLit["one"]) fmt.Printf("Map created at \"key2\" is: %f\n", mapCreated["key2"]) fmt.Printf("Map assigned at \"two\" is: %d\n", mapLit["two"]) fmt.Printf("Map literal at \"ten\" is: %d\n", mapLit["ten"])&#125; map的高级用法1234567891011121314151617181920package mainimport "fmt"func main() &#123; // 声明 scene := make(map[string]int) // 初始化 scene["route"] = 66 scene["brazil"] = 4 scene["china"] = 960 // 遍历 for k, v := range scene &#123; fmt.Println(k, v) &#125; // 删除指定key delete(scene, "brazil") fmt.Println(scene)&#125; 列表list是一种非连续的存储容器，由多个节点组成，节点通过变量记录彼此之间的关系，列表有多种实现方法，如单链表、双链表等。 列表的原理可以这样理解：假设 A、B、C 三个人都有电话号码，如果 A 把号码告诉给 B，B 把号码告诉给 C，这个过程就建立了一个单链表结构，如下图所示。 如果在这个基础上，再从 C 开始将自己的号码告诉给自己所知道号码的主人，这样就形成了双链表结构，如下图所示。 那么如果需要获得所有人的号码，只需要从 A 或者 C 开始，要求他们将自己的号码发出来，然后再通知下一个人如此循环，这样就构成了一个列表遍历的过程。 如果 B 换号码了，他需要通知 A 和 C，将自己的号码移除，这个过程就是列表元素的删除操作，如下图所示。 列表的初始化 1.通过 container/list 包的 New() 函数初始化 list 1变量名 := list.New() 2.通过 var 关键字声明初始化 list 1var 变量名 list.List 遍历列表遍历双链表需要配合 Front() 函数获取头元素，遍历时只要元素不为空就可以继续进行，每一次遍历都会调用元素的 Next() 函数 12345678910111213141516171819package mainimport ( "container/list" "fmt")func main() &#123; // 创建一个 list l := list.New() //把4元素放在最后 e4 := l.PushBack(4) //把1元素放在最前 e1 := l.PushFront(1) // 遍历所有元素并打印其内容 for e := l.Front(); e != nil; e = e.Next() &#123; fmt.Println(e.Value) &#125;&#125; 在列表中插入元素 方 法 功 能 InsertAfter(v interface {}, mark Element) Element 在 mark 点之后插入元素，mark 点由其他插入函数提供 InsertBefore(v interface {}, mark Element) Element 在 mark 点之前插入元素，mark 点由其他插入函数提供 PushBackList(other *List) 添加 other 列表元素到尾部 PushFrontList(other *List) 添加 other 列表元素到头部 1234567891011121314151617181920212223package mainimport ( "container/list" "fmt")func main() &#123; // 创建一个 list l := list.New() //把4元素放在最后 e4 := l.PushBack(4) //把1元素放在最前 e1 := l.PushFront(1) //在e4元素前面插入3 l.InsertBefore(3, e4) //在e1后面插入2 l.InsertAfter(2, e1) // 遍历所有元素并打印其内容 for e := l.Front(); e != nil; e = e.Next() &#123; fmt.Println(e.Value) &#125;&#125; 从列表中删除元素列表插入函数的返回值会提供一个 *list.Element 结构，这个结构记录着列表元素的值以及与其他节点之间的关系等信息，从列表中删除元素时，需要用到这个结构进行快速删除。 直接看例子: 12345678910111213141516171819202122232425262728293031package mainimport ( "container/list" "fmt")func main() &#123; l := list.New() // 尾部添加 l.PushBack("canon") // 头部添加 l.PushFront(67) // 尾部添加后保存元素句柄 element := l.PushBack("fist") // 在fist之后添加high l.InsertAfter("high", element) // 在fist之前添加noon l.InsertBefore("noon", element) // 遍历所有元素并打印其内容 for e := l.Front(); e != nil; e = e.Next() &#123; fmt.Println(e.Value) &#125; // 使用 l.Remove(element) fmt.Println("删除后") // 遍历所有元素并打印其内容 for e := l.Front(); e != nil; e = e.Next() &#123; fmt.Println(e.Value) &#125;&#125; 二、结构体结构体是一种复合类型，由零个或多个任意类型的值聚合成的实体，每个值都可以称为结构体的成员。 定义如下： 12345type 类型名 struct &#123; 字段1 字段1类型 字段2 字段2类型 …&#125; 类型名：标识自定义结构体的名称，在同一个包内不能重复。 struct{}：表示结构体类型 字段1、字段2……：表示结构体字段名，结构体中的字段名必须唯一。 字段1类型、字段2类型……：表示结构体各个字段的类型,可以是结构体。 实例化12345678910111213141516171819package mainimport "fmt"func main() &#123; // 定义只是一种内存布局的描述，只有当实例化时，才会真正地分配内存 type Point struct &#123; X int Y int &#125; // 实例化 var p Point // 用.访问 p.X = 10 p.Y = 20 fmt.Println(p.X) fmt.Println(p.Y)&#125; 还可以通过以下两种方式实例化： 12ins := new(T)ins := &amp;T&#123;&#125; T 表示结构体类型 ins：T 类型被实例化后保存到 ins 变量中，ins 的类型为 *T，属于指针。 初始化1234567891011ins := 结构体类型名&#123; 字段1: 字段1的值, 字段2: 字段2的值, …&#125;ins := 结构体类型名&#123; 字段1的值, 字段2的值, …&#125; 12345678910111213141516171819import "fmt"func main()&#123; type People struct &#123; name string &#125; relation := &amp;People&#123; name: "爷爷", &#125;type Address struct &#123; Province string &#125; addr := Address&#123; "四川", &#125; fmt.Println(relation.name) fmt.Println(addr.Province)&#125; 匿名结构体1234567891011ins := struct &#123; // 匿名结构体字段定义 字段1 字段类型1 字段2 字段类型2 …&#125;&#123; // 字段值初始化 初始化字段1: 字段1的值, 初始化字段2: 字段2的值, …&#125; 123456789101112131415161718package mainimport ("fmt")func main() &#123; // 实例化一个匿名结构体 msg := &amp;struct &#123; // 定义部分 id int data string &#125;&#123; // 值初始化部分 1024, "hello", &#125; fmt.Println(msg.id) fmt.Println(msg.data)&#125; 三、接口接口是一组方法的集合，可以理解为抽象的类型。它提供了一种非侵入式的接口。任何类型只要实现了该接口中方法集，那么就属于这个类型。 接口声明的格式: 12345type 接口类型名 interface&#123; 方法名1( 参数列表1 ) 返回值列表1 方法名2( 参数列表2 ) 返回值列表2 …&#125; 接口类型名：使用 type 将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加 er，如有写操作的接口叫 Writer 方法名：当方法名首字母是大写时，且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。（小写屏蔽隐藏机制） 参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以被忽略 12345678910111213141516171819202122232425262728293031323334353637package mainimport "fmt"// 定义一个鸭子接口type Duck interface &#123; Quack() // 鸭子叫 DuckGo() // 鸭子走&#125;// 现在有只鸡类型type Chicken struct &#123;&#125;func (c Chicken) IsChicken() &#123; fmt.Println("我是小鸡")&#125;// 这只鸡会鸭子叫和鸭子走func (c Chicken) Quack() &#123; fmt.Println("嘎嘎")&#125;func (c Chicken) DuckGo() &#123; fmt.Println("大摇大摆的走")&#125;// 定义一个函数，负责执行鸭子能做的事情func DoDuck(d Duck) &#123; d.Quack() d.DuckGo()&#125;func main() &#123; c := Chicken&#123;&#125; DoDuck(c)&#125; 接口的方法 与 实现接口的类型方法格式一致 接口中所有方法均被实现 类型断言如果想判断 一个使用在接口值上的操作，用于检查接口类型变量所持有的值是否实现了期望的接口或者具体的类型。 1value, ok := x.(T) x 表示一个接口的类型 T 表示一个具体的类型（也可为接口类型） 12345678910111213141516171819202122232425262728293031323334353637package mainimport ( "fmt")func main() &#123; // 可以接受任何类型的数据 var x interface&#123;&#125; x = 10 value1, ok1 := x.(int) fmt.Print(value1, ",", ok1, "\n") x = nil value2, ok2 := x.(int) fmt.Print(value2, ",", ok2, "\n")&#125;func getType(a interface&#123;&#125;) &#123; switch a.(type) &#123; case int: fmt.Println("the type of a is int") case string: fmt.Println("the type of a is string") case float64: fmt.Println("the type of a is float") default: fmt.Println("unknown type") &#125;&#125;func main() &#123; var a int a = 10 getType(a)&#125; 接口排序其实可以用来排序。内置接口 sort.Interface,它需要知道三个东西：序列的长度，表示两个元素比较的结果，一种交换两个元素的方式,它就会给你排序 12345678910111213141516171819202122232425262728293031323334353637383940package mainimport ( "fmt" "sort")// 将[]string定义为MyStringList类型type MyStringList []string// 实现sort.Interface接口的获取元素数量方法func (m MyStringList) Len() int &#123; return len(m)&#125;// 实现sort.Interface接口的比较元素方法func (m MyStringList) Less(i, j int) bool &#123; return m[i] &lt; m[j]&#125;// 实现sort.Interface接口的交换元素方法func (m MyStringList) Swap(i, j int) &#123; m[i], m[j] = m[j], m[i]&#125;func main() &#123; // 准备一个内容被打乱顺序的字符串切片 names := MyStringList&#123; "3. Triple Kill", "5. Penta Kill", "2. Double Kill", "4. Quadra Kill", "1. First Blood", &#125; // 使用sort包进行排序 sort.Sort(names) // 遍历打印结果 for _, v := range names &#123; fmt.Printf("%s\n", v) &#125;&#125; 四、进程进程：是程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位。 线程：是进程的一个执行实体，是 CPU 调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。 一个进程可以创建和撤销多个线程，同一个进程中的多个线程之间可以并发执行。 协程：协程是一种用户态的轻量级线程，由用户控制协程的调度。线程进程都是同步机制，而协程则是异步，只不过协程能保留上一次调用时的状态，每次切换回来时，就相当于进入上一次调用的状态。 并发： 多线程程序在单核心的 cpu 上运行，取得多个任务，利用时序切换不同任务执行.请看下图： 并行： 多线程程序在多核心的 cpu 上运行.取得多个任务，并同时去执行所取得的这些任务。相当于将长长的一条队列，划分成了多条短队列，所以并行缩短了任务队列的长度。请看下图： goroutinego 并发是 让某个函数独立运行的能力，这个核心就是goroutine。goroutine有点类似协程，一个goroutine就是一个独立的工作单元，运行时通过算法调度这些goroutine来运行，在单个进程里执行成千上万的并发任务。 语法如下： 1go 函数名( 参数列表 ) 函数名：要调用的函数名。 参数列表：调用函数需要传入的参数。 1234567891011121314151617181920212223package mainimport ( "fmt" "time")func running() &#123; var times int // 构建一个无限循环 for &#123; times++ fmt.Println("tick", times) // 延时1秒 time.Sleep(time.Second) &#125;&#125;func main() &#123; // 并发执行程序 go running() // 接受命令行输入, 不做任何事情 var input string fmt.Scanln(&amp;input)&#125; 使用匿名函数创建goroutine语法如下： 123go func( 参数列表 )&#123; 函数体&#125;( 调用参数列表 ) 参数列表：函数体内的参数变量列表。 函数体：匿名函数的代码。 调用参数列表：启动 goroutine 时，需要向匿名函数传递的调用参数。 1234567891011121314151617package mainimport ( "fmt" "time")func main() &#123; go func() &#123; var times int for &#123; times++ fmt.Println("tick", times) time.Sleep(time.Second) &#125; &#125;() var input string fmt.Scanln(&amp;input)&#125; 1.一个是主进程执行过快，导致其他协程没有执行； 2.多个协程之间用到相同的数据； 等待组 方法名 功能 (wg * WaitGroup) Add(delta int) 等待组的计数器 +1 (wg * WaitGroup) Done() 等待组的计数器 -1 (wg * WaitGroup) Wait() 当等待组计数器不等于 0 时阻塞直到变 0。 使用步骤： 1.利用wg.Add(delta)先增加计数器的个数 2.再利用wg.Done()减少计数器的个数，最后让计数器等于0 3.当等待组计数器等于0，才会执行wg.Wait()后面的代码，不然就一直阻塞 123456789101112131415161718192021222324252627282930313233package mainimport ( "fmt" "net/http" "sync")func main() &#123; // 声明一个等待组 var wg sync.WaitGroup // 准备一系列的网站地址 var urls = []string&#123; "https://www.baidu.com/", "https://www.sougou.com/", &#125; // 遍历这些地址 for _, url := range urls &#123; // 每一个任务开始时, 将等待组增加1 wg.Add(1) // 开启一个并发 go func(url string) &#123; // 使用defer, 表示函数完成时将等待组值减1 defer wg.Done() // 使用http访问提供的地址 _, err := http.Get(url) // 访问完成后, 打印地址和可能发生的错误 fmt.Println(url, err) // 通过参数传递url地址 &#125;(url) &#125; // 等待所有的任务完成 wg.Wait() fmt.Println("over")&#125; 资源竞争12345678910111213141516171819202122232425262728package mainimport ( "fmt" "runtime" "sync")var ( count int32 wg sync.WaitGroup)func main() &#123; wg.Add(2) go incCount() go incCount() wg.Wait() fmt.Println(count)&#125;func incCount() &#123; defer wg.Done() for i := 0; i &lt; 2; i++ &#123; fmt.Println("count:",count) value := count // 是让当前 goroutine 暂停的意思，退回执行队列，让其他等待的 goroutine 运行，目的是为了使资源竞争的结果更明显。 runtime.Gosched() value++ count = value &#125;&#125; 预期是4,实际结果 2/3/4之间随机出现. 因为 count 变量没有任何同步保护，所以两个 goroutine 都会对其进行读写，会导致对已经计算好的结果被覆盖，以至于产生错误结果。 锁住共享资源解决方案1:锁住共享资源 原子函数: 以很底层的加锁机制来同步访问整型变量和指针 atomic.AddInt64 : 安全地加一个整型值的方式 atomic.LoadInt64 : 安全地读一个整型值的方式 atomic.StoreInt64 : 安全地写一个整型值的方式 1234567891011121314151617181920212223242526package mainimport ( "fmt" "runtime" "sync" "sync/atomic")var ( counter int64 wg sync.WaitGroup)func main() &#123; wg.Add(2) go incCounter(1) go incCounter(2) wg.Wait() //等待goroutine结束 fmt.Println(counter)&#125;func incCounter(id int) &#123; defer wg.Done() for count := 0; count &lt; 2; count++ &#123; //安全的对counter加1 atomic.AddInt64(&amp;counter, 1) fmt.Println("counter:",counter) runtime.Gosched() &#125; 互斥锁方案2:使用互斥锁。 互斥锁:在代码上创建一个临界区，保证同一时间只有一个 goroutine 可以执行这个临界代码。 sync.Mutex：暴力锁， 当一个 goroutine 获得了 Mutex 后，其他 goroutine 就只能乖乖等到这个 goroutine 释放该 Mutex。 Lock() 加锁 Unlock() 解锁 sync.RWMutex： 基于sync.Mutex产生的单写多读模型，运行多个 goroutine 读，读的时候不允许写入，写的时候不允许读。 Lock()和Unlock()用于申请和释放写锁 RLock()和RUnlock()用于申请和释放读锁 1234567891011121314151617181920212223242526272829303132package mainimport ( "fmt" "runtime" "sync")var ( counter int64 wg sync.WaitGroup mutex sync.Mutex)func main() &#123; wg.Add(2) go incCounter(1) go incCounter(2) wg.Wait() fmt.Println(counter)&#125;func incCounter(id int) &#123; defer wg.Done() for count := 0; count &lt; 2; count++ &#123; //同一时刻只允许一个goroutine进入这个临界区 mutex.Lock() &#123; value := counter runtime.Gosched() value++ counter = value &#125; mutex.Unlock() //释放锁，允许其他正在等待的goroutine进入临界区 &#125;&#125; channel 通道（channel）是一种特殊的类型。在任何时候，同时只能有一个 goroutine 访问通道进行发送和获取数据。goroutine 间通过通道就可以通信。 通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。 声明语法如下： 1var 通道变量 chan 通道类型 通道类型：通道内的数据类型。 通道变量：保存通道的变量。 创建语法如下： 1通道实例 := make(chan类型 通道类型, 缓冲大小) chan类型： chan&lt;- 只能用来发送 &lt;-chan 只能用来接收 chan 用来发送和接收 通道类型：和无缓冲通道用法一致，影响通道发送和接收的数据类型。 缓冲大小：决定通道最多可以保存的元素数量。 无缓冲通道：不设置。进行发送 goroutine 需要被接收后才可以继续发送。接收的goroutine 也同理。 缓冲通道：设置大小，缓存大小为设置个数。进行发送goroutine 可以在发送元素达到缓存上限之前，继续发。接收的goroutine 需要通道元素不为零，就可以一直接收。 通道实例：被创建出的通道实例。 1234567891011package mainimport "fmt"func main() &#123; senderOnly := make(chan&lt;- int) // 只能用来发送（管道的入口，只进不出） receiverOnly := make(&lt;-chan int) // 只能用来接收（管道的出口，只出不进） unbuffer := make(chan int) // 无缓冲可收发 buffer := make(chan int, 2) // 无缓冲可收发 fmt.Println(senderOnly, receiverOnly, unbuffer, buffer)&#125; 使用通道收发数据: 12通道变量 &lt;- 值收到的值 := &lt;-通道变量 123456789101112131415161718192021222324252627282930313233343536373839404142434445package mainimport "fmt"func main() &#123; fmt.Println("start main") // 创建通道 ch := make(chan int) var result int go func() &#123; println("come into goroutine1") var r int for i := 1; i &lt;= 3; i++ &#123; r += i &#125; // 发送数据到通道 ch &lt;- r &#125;() go func() &#123; println("come into goroutine2") var r int = 1 for i := 1; i &lt;= 3; i++ &#123; r *= i &#125; // 发送数据到通道 ch &lt;- r &#125;() go func() &#123; println("come into goroutine3") // 发送数据到通道 ch &lt;- 11 &#125;() for i := 0; i &lt; 3; i++ &#123; // 接受数据并累加 result += &lt;-ch &#125; close(ch) fmt.Println("result is:", result) fmt.Println("end main")&#125; 1234567891011121314151617181920212223242526272829package mainimport ( "fmt")func main() &#123; fmt.Println("start main") // 创建一个3个元素缓冲大小的整型通道 ch := make(chan int, 3) // 查看当前通道的大小 fmt.Println("通道的大小:",len(ch)) // 开启一个并发匿名函数 // 开启一个并发匿名函数 ch &lt;- 1 ch &lt;- 2 ch &lt;- 3 fmt.Println("通道的大小:",len(ch)) // 遍历接收通道数据 for data := range ch &#123; // 打印通道数据 fmt.Println(data) // 当遇到数据0时, 退出接收循环 if data == 3 &#123; break &#125; &#125; fmt.Println("end main")&#125; 超时通道因为发送元素到通道,如果没有及时被接收,就会造成阻塞.所以我们可以结合select进行超时判断: 语法结构如下: 12345678select &#123; case &lt;-chan1: // 如果chan1成功读到数据，则进行该case处理语句 case chan2 &lt;- 1: // 如果成功向chan2写入数据，则进行该case处理语句 default: // 如果上面都没有成功，则进入default处理流程&#125; 1234567891011121314151617181920212223242526272829303132package mainimport ( "fmt" "time")func main() &#123; // 创建普通通道 ch := make(chan int) // 创建超时通道 quit := make(chan bool) //新开一个协程 go func() &#123; for &#123; select &#123; case num := &lt;-ch: fmt.Println("num = ", num) case &lt;-time.After(3 * time.Second): // 经过了3秒 fmt.Println("超时") quit &lt;- true &#125; &#125; &#125;() for i := 0; i &lt; 5; i++ &#123; ch &lt;- i // 等待1秒再读取 time.Sleep(time.Second) &#125; // 从超时通道获取到信息，退出进程 &lt;-quit fmt.Println("程序结束")&#125; 控制性能使用下面命令设置程序运行占用的cpu核数。（默认使用机器的最大核数） 1234// 程序运行占用的cpu核数runtime.GOMAXPROCS(逻辑CPU数量)// 查询机器的cpu核数runtime.NumCPU() 逻辑CPU的数量： &lt;1：不修改任何数值。 =1：单核心执行。 1：多核并发执行。 五、reflect程序在编译时变量被转换为内存地址，变量名不会被编译器写入到可执行部分，所以在运行程序时程序无法获取自身的信息。但是 反射 可以在程序运行期对程序本身进行访问和修改。 类型 作用 reflect.ValueOf() 获取输入参数接口中的数据的值，如果为空则返回0 &lt;- 注意是0 reflect.TypeOf() 动态获取输入参数接口中的值的类型，如果为空则返回nil &lt;- 注意是nil 12345678910111213141516171819202122232425package mainimport ( "fmt" "reflect")func main() &#123; // 定义一个Enum类型 type Enum float32 var name Enum = 3.1415926 // TypeOf会返回目标数据的类型，比如int/float/struct/指针等 reflectType := reflect.TypeOf(name) // valueOf返回目标数据的的值，比如上文的 3.1415926 reflectValue := reflect.ValueOf(name) fmt.Println("类型: ", reflectType) fmt.Println("类型的名称: ", reflectType.Name()) fmt.Println("类型的种类: ", reflectType.Kind()) fmt.Println("变量值: ", reflectValue) fmt.Println("变量值的种类: ", reflectValue.Kind())&#125; 变量类型是指针与指针指向的元素：需要使用Elem方法。 方法 说明 Field(i int) StructField 根据索引返回索引对应的结构体字段的信息，当值不是结构体或索引超界时发生宕机 NumField() int 返回结构体成员字段数量，当类型不是结构体或索引超界时发生宕机 FieldByName(name string) (StructField, bool) 根据给定字符串返回字符串对应的结构体字段的信息，没有找到时 bool 返回 false，当类型不是结构体或索引超界时发生宕机 FieldByIndex(index []int) StructField 多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息，没有找到时返回零值。当类型不是结构体或索引超界时发生宕机 FieldByNameFunc(match func(string) bool) (StructField,bool) 根据匹配函数匹配需要的字段，当值不是结构体或索引超界时发生宕机 1234567891011121314151617181920package mainimport ( "fmt" "reflect")func main() &#123; // 声明一个空结构体 type cat struct &#123; &#125; // 创建cat的实例 ins := &amp;cat&#123;&#125; // 获取结构体实例的反射类型对象 typeOfCat := reflect.TypeOf(ins) // 显示反射类型对象的名称和种类 fmt.Printf("name:'%v' kind:'%v'\n", typeOfCat.Name(), typeOfCat.Kind()) // 取类型的元素 typeOfCat = typeOfCat.Elem() // 显示反射类型对象的名称和种类 fmt.Printf("element name: '%v', element kind: '%v'\n", typeOfCat.Name(), typeOfCat.Kind())&#125; 使用 reflect.Type 的 Field() 方法会返回 StructField 结构，这个结构描述结构体的成员信息： 123456789type StructField struct &#123; Name string // 字段名 PkgPath string // 字段路径 Type Type // 字段反射类型对象 Tag StructTag // 字段的结构体标签 Offset uintptr // 字段在结构体中的相对偏移 Index []int // Type.FieldByIndex中的返回的索引值 Anonymous bool // 是否为匿名字段&#125; 1234567891011121314151617181920212223242526272829package mainimport ( "fmt" "reflect")func main() &#123; // 声明一个空结构体 type cat struct &#123; Name string // 带有结构体tag的字段。tag：类似添加的注解，格式 `key1:"value1" key2:"value2"` Type int `json:"type" id:"100"` &#125; // 创建cat的实例 ins := cat&#123;Name: "mimi", Type: 1&#125; // 获取结构体实例的反射类型对象 typeOfCat := reflect.TypeOf(ins) // 遍历结构体所有成员 for i := 0; i &lt; typeOfCat.NumField(); i++ &#123; // 获取每个成员的结构体字段类型 fieldType := typeOfCat.Field(i) // 输出成员名和tag fmt.Printf("name: %v tag: '%v'\n", fieldType.Name, fieldType.Tag) &#125; // 通过字段名, 找到字段类型信息 if catType, ok := typeOfCat.FieldByName("Type"); ok &#123; // 从tag中取出需要的tag fmt.Println(catType.Tag.Get("json"), catType.Tag.Get("id")) &#125;&#125; 反射三大定律 定律一：反射可以将“接口类型变量”转换为“反射类型对象” ：普通变量 -&gt; 接口变量 -&gt; 反射对象：• 12func TypeOf(i interface&#123;&#125;) Typefunc ValueOf(i interface&#123;&#125;) Value 1.反射可以将“接口类型变量”转换为“反射类型对象普通变量 -&gt; 接口变量 -&gt; 反射对象： 1.我们调用 reflect.TypeOf(name) 时，name被存储在一个空接口变量中,然后被传递过去； 2.接着reflect.TypeOf 或者 ValueOf 对空接口变量转换为 reflect.Type 或 reflect.Value。打个断点看看，如下图所示： 2.反射可以将“反射类型对象”转换为“接口类型变量”反射对象 -&gt; 接口变量：使用的是Value 的Interface函数，是把实际的值赋值给空接口变量，它的声明如下： 1func (v Value) Interface() (i interface&#123;&#125;) 1234567891011121314package mainimport ( "fmt" "reflect")func main() &#123; type MyInt int var x MyInt = 7 v := reflect.ValueOf(x) // 通过 Interface 方法恢复其接口类型，然后再通过 接口断言获取值 y := v.Interface().(MyInt) fmt.Printf("类型：%T\n", y) fmt.Println("值：", y)&#125; 3.要修改“反射类型对象”其值必须是“可写的” 通过 CanSet 方法判断 reflect.Value 类型变量的“可写性”,看一下下面的例子： 123456789101112package mainimport ( "fmt" "reflect")func main() &#123; // 声明整型变量a并赋初值 var a int = 1024 // 获取变量a的反射值对象 valueOfA := reflect.ValueOf(a) fmt.Println("可写性:", valueOfA.CanSet())&#125; 可写性，其实就是 可以被寻址 。 通过反射修改变量的值 1.获取元素的地址，获取其反射值对象 2.获取其反射值对象的元素，修改值 1234567891011121314151617package mainimport ( "fmt" "reflect")func main() &#123; // 声明整型变量a并赋初值 var a int = 1024 // 获取变量a的反射值对象(a的地址) valueOfA := reflect.ValueOf(&amp;a) // 取出a地址的元素(a的值) valueOfA = valueOfA.Elem() // 修改a的值为1 valueOfA.SetInt(1) // 打印a的值 fmt.Println(valueOfA.Int())&#125; 如果变量类型是结构体，需要考虑字段是否可以被导出。（首字符大写，小写会被隐蔽） 12345678910111213141516171819package mainimport ( "fmt" "reflect")func main() &#123; type dog struct &#123; LegCount int &#125; // 获取dog实例地址的反射值对象 valueOfDog := reflect.ValueOf(&amp;dog&#123;&#125;) // 取出dog实例地址的元素 valueOfDog = valueOfDog.Elem() // 获取LegCount字段的值 vLegCount := valueOfDog.FieldByName("LegCount") // 设置LegCount的值 vLegCount.SetInt(4) fmt.Println(vLegCount.Int())&#125; 方法 取元素、取地址及修改值的属性方法请参考下表： 方法名 备 注 Elem() Value 取值指向的元素值，类似于语言层*操作。当值类型不是指针或接口时发生宕 机，空指针时返回 nil 的 Value Addr() Value 对可寻址的值返回其地址，类似于语言层&amp;操作。当值不可寻址时发生宕机 CanAddr() bool 表示值是否可寻址 CanSet() bool 返回值能否被修改。要求值可寻址且是导出的字段 Set(x Value) 将值设置为传入的反射值对象的值 值修改相关方法如下表所示： Set(x Value) 将值设置为传入的反射值对象的值 Setlnt(x int64) 使用 int64 设置值。当值的类型不是 int、int8、int16、 int32、int64 时会发生宕机 SetUint(x uint64) 使用 uint64 设置值。当值的类型不是 uint、uint8、uint16、uint32、uint64 时会发生宕机 SetFloat(x float64) 使用 float64 设置值。当值的类型不是 float32、float64 时会发生宕机 SetBool(x bool) 使用 bool 设置值。当值的类型不是 bod 时会发生宕机 SetBytes(x []byte) 设置字节数组 []bytes值。当值的类型不是 []byte 时会发生宕机 SetString(x string) 设置字符串值。当值的类型不是 string 时会发生宕机 六、文件读写使用语法如下所示： 1func OpenFile(name string, flag int, perm FileMode) (file *File, err error) name :文件的文件名，如果不是在当前路径下需要加上具体路径 flag：文件的处理参数，表面上是int，实际上是枚举值。,如果要使用多个参数,需要用’|’连接 O_RDONLY：只读模式打开文件； O_WRONLY：只写模式打开文件； O_RDWR：读写模式打开文件； O_APPEND：写操作时将数据附加到文件尾部（追加）； O_CREATE：如果不存在将创建一个新文件； O_EXCL：和 O_CREATE 配合使用，文件必须不存在，否则返回一个错误； O_SYNC：当进行一系列写操作时，每次都要等待上次的 I/O 操作完成再进行； O_TRUNC：如果可能，在打开时清空文件。 perm：文件读/写/执行权限，同unix，有四位。 第一位： 4 ： set uid，设置使文件在执行阶段具有文件所有者的权限. 2 ： set gid，目录被设置该位后, 任何用户在此目录下创建的文件都具有和该目录所属的组相同的组. 1 ： sticky bit，防删除位. 第二位：文件的所有者拥有的权限，如果同时拥有多种权限，把数字累加 4：读 2：写 1：执行 第三位：文件属组成员拥有的权限，如果同时拥有多种权限，把数字累加 4：读 2：写 1：执行 第四位：其他用户拥有的权限，如果同时拥有多种权限，把数字累加 4：读 2：写 1：执行 12345678910111213141516171819202122232425package mainimport ( "bufio" "fmt" "os")func main() &#123; // 创建一个新文件， filePath := "golang.txt" // 设置创建和可写 file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, 0666) if err != nil &#123; fmt.Println("文件打开失败", err) &#125; //及时关闭file句柄 defer file.Close() //使用带缓存的 *Writer 写入文件，内容为 5 句 “Hello World” write := bufio.NewWriter(file) for i := 0; i &lt; 5; i++ &#123; write.WriteString("Hello World \n") &#125; //Flush将缓存的文件真正写入到文件中 write.Flush()&#125; 123456789101112131415161718192021222324252627282930313233package mainimport ( "bufio" "fmt" "io" "os")func main() &#123; filePath := "golang.txt" // 设置读写权限和追加模式 file, err := os.OpenFile(filePath, os.O_RDWR|os.O_APPEND, 0666) if err != nil &#123; fmt.Println("文件打开失败", err) &#125; //及时关闭file句柄 defer file.Close() //读原来文件的内容，并且显示在终端 reader := bufio.NewReader(file) for &#123; str, err := reader.ReadString('\n') if err == io.EOF &#123; break &#125; fmt.Print(str) &#125; //写入文件时，使用带缓存的 *Writer write := bufio.NewWriter(file) for i := 0; i &lt; 5; i++ &#123; write.WriteString("Hello Golang \n") &#125; //Flush将缓存的文件真正写入到文件中 write.Flush()&#125; 各种格式文件处理JSONJSON 文件内容一般是这样子： 1&#123;"key1":"value1","key2":"value2","key3":["value3","value4","value5"]&#125; 我们可以使用内置的 encoding/json 标准库去处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package mainimport ( "encoding/json" "fmt" "os")type Website struct &#123; Name string `xml:"name,attr"` Url string Course []string&#125;func main() &#123; // 1.写入文件 // 定义了写个文件内容 infoWrite := []Website&#123;&#123;"Golang", "https://golang.org/", []string&#123;"http://www.baidu.com/"&#125;&#125;, &#123;"Java", "https://www.java.com/zh_CN/", []string&#123;"http://www.google.com/java/"&#125;&#125;&#125; // 创建文件 filePtrWrite, err := os.Create("info.json") if err != nil &#123; fmt.Println("文件创建失败", err.Error()) return &#125; // 创建Json编码器 encoder := json.NewEncoder(filePtrWrite) err = encoder.Encode(infoWrite) if err != nil &#123; fmt.Println("编码错误", err.Error()) &#125; else &#123; fmt.Println("编码成功") &#125; filePtrWrite.Close() // 2.读取文件 filePtrRead, err := os.Open("./info.json") if err != nil &#123; fmt.Println("文件打开失败 [Err:%s]", err.Error()) return &#125; defer filePtrRead.Close() var infoRead []Website // 创建json解码器 decoder := json.NewDecoder(filePtrRead) err = decoder.Decode(&amp;infoRead) if err != nil &#123; fmt.Println("解码失败", err.Error()) &#125; else &#123; fmt.Println("解码成功") fmt.Println(infoRead) &#125;&#125; XML对于XML，我们可以使用 encoidng/xml 包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package mainimport ( "encoding/xml" "fmt" "os")type Website struct &#123; Name string `xml:"name,attr"` Url string Course []string&#125;func main() &#123; // 1.写入文件 // 定义写入信息 infoWrite := Website&#123;"Golang", "https://golang.org/", []string&#123;"http://www.baidu.com/"&#125;&#125; f1, err := os.Create("./info.xml") if err != nil &#123; fmt.Println("文件创建失败", err.Error()) return &#125; // 序列化到文件中 encoder := xml.NewEncoder(f1) err = encoder.Encode(infoWrite) if err != nil &#123; fmt.Println("编码错误：", err.Error()) return &#125; else &#123; fmt.Println("编码成功") &#125; f1.Close() // 2.读取文件 // 打开xml文件 f2, err := os.Open("./info.xml") if err != nil &#123; fmt.Printf("文件打开失败：%v", err) return &#125; defer f2.Close() infoRead := Website&#123;&#125; //创建 xml 解码器 decoder := xml.NewDecoder(f2) err = decoder.Decode(&amp;infoRead) if err != nil &#123; fmt.Printf("解码失败：%v", err) return &#125; else &#123; fmt.Println("解码成功") fmt.Println(infoRead) &#125;&#125; GobGob（即 Go binary 的缩写），Go语言自己以二进制形式序列化和反序列化程序数据的格式。 123456789101112131415161718192021222324252627package mainimport ( "encoding/gob" "fmt" "os")func main() &#123; // 1.写入文件 info := map[string]string&#123; "name": "Golang", "website": "https://golang.org/", &#125; name := "demo.gob" File1, _ := os.OpenFile(name, os.O_RDWR|os.O_CREATE, 0777) enc := gob.NewEncoder(File1) if err := enc.Encode(info); err != nil &#123; fmt.Println(err) &#125; File1.Close() // 2.读取文件 var M map[string]string File2, _ := os.Open("demo.gob") D := gob.NewDecoder(File2) D.Decode(&amp;M) fmt.Println(M)&#125; bin关于其他二进制文件，可以使用 encoding/binary处理。 语法如下： 12func Write(w io.Writer, order ByteOrder, data interface&#123;&#125;) errorfunc Read(r io.Reader, order ByteOrder, data interface&#123;&#125;) error w:可以读出字节流的数据源 r:可以写入字节流的数据源 order:指定写入/读取数据的字节序 binary.LittleEndian:小端模式,按照从低地址到高地址的顺序,存放据的低位字节到高位字节 binary.BigEndian:大端模式,按照从低地址到高地址的顺序,存放数据的高位字节到低位字节 data:必须是定长值、定长值的切片、定长值的指针 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package mainimport ( "bytes" "encoding/binary" "fmt" "os")type Website struct &#123; Url int32&#125;// 读取文件func readNextBytes(file *os.File, number int) []byte &#123; bytes := make([]byte, number) _, err := file.Read(bytes) if err != nil &#123; fmt.Println("解码失败", err) &#125; return bytes&#125;func main() &#123; // 1.写入文件 file1, err := os.Create("output.bin") for i := 1; i &lt;= 10; i++ &#123; info := Website&#123; int32(i), &#125; if err != nil &#123; fmt.Println("文件创建失败 ", err.Error()) return &#125; var binBuf bytes.Buffer binary.Write(&amp;binBuf, binary.LittleEndian, info) b := binBuf.Bytes() _, err = file1.Write(b) if err != nil &#123; fmt.Println("编码失败", err.Error()) return &#125; &#125; fmt.Println("编码成功") file1.Close() // 2.读取文件 // 打开文件 file2, err := os.Open("output.bin") defer file2.Close() if err != nil &#123; fmt.Println("文件打开失败", err.Error()) return &#125; m := Website&#123;&#125; for i := 1; i &lt;= 10; i++ &#123; data := readNextBytes(file2, 4) buffer := bytes.NewBuffer(data) err = binary.Read(buffer, binary.LittleEndian, &amp;m) if err != nil &#123; fmt.Println("二进制文件读取失败", err) return &#125; fmt.Println("第", i, "个值为：", m) &#125;&#125; zip12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package mainimport ( "archive/zip" "bytes" "fmt" "io" "os")func main() &#123; // 1.压缩文件 // 创建一个缓冲区用来保存压缩文件内容 buf := new(bytes.Buffer) // 创建一个压缩文档 w := zip.NewWriter(buf) // 将文件加入压缩文档 var files = []struct &#123; Name, Body string &#125;&#123; &#123;"Golang.txt", "https://golang.org/"&#125;, &#125; for _, file := range files &#123; f, err := w.Create(file.Name) if err != nil &#123; fmt.Println(err) &#125; _, err = f.Write([]byte(file.Body)) if err != nil &#123; fmt.Println(err) &#125; &#125; // 关闭压缩文档 err := w.Close() if err != nil &#123; fmt.Println(err) &#125; // 将压缩文档内容写入文件 f, err := os.OpenFile("file.zip", os.O_CREATE|os.O_WRONLY, 0666) if err != nil &#123; fmt.Println(err) &#125; buf.WriteTo(f) // 2.解压文件 // 打开一个zip格式文件 r, err := zip.OpenReader("file.zip") if err != nil &#123; fmt.Printf(err.Error()) &#125; defer r.Close() // 迭代压缩文件中的文件，打印出文件中的内容 for _, f := range r.File &#123; fmt.Printf("文件名: %s\n", f.Name) rc, err := f.Open() if err != nil &#123; fmt.Printf(err.Error()) &#125; // 创建文件 w, err := os.Create(f.Name) if err != nil &#123; fmt.Printf(err.Error()) &#125; // 写入文件 _, err = io.CopyN(w, rc, int64(f.UncompressedSize64)) if err != nil &#123; fmt.Printf(err.Error()) &#125; w.Close() rc.Close() &#125;&#125; tar 压缩的步骤如下： 1.创建一个文件 x.tar，然后向 x.tar 写入 tar 头部信息； 2.打开要被 tar 的文件，向 x.tar 写入头部信息，然后向 x.tar 写入文件信息； 3.当有多个文件需要被 tar 时，重复第二步直到所有文件都被写入到 x.tar 中； 4.关闭 x.tar，完成打包。 123456789101112131415161718192021222324252627282930313233343536373839package mainimport ( "archive/tar" "fmt" "io" "os")func main() &#123; f, err := os.Create("./output.tar") //创建一个 tar 文件 if err != nil &#123; fmt.Println(err) return &#125; defer f.Close() tw := tar.NewWriter(f) defer tw.Close() fileinfo, err := os.Stat("Golang.txt") //获取文件相关信息 if err != nil &#123; fmt.Println(err) &#125; hdr, err := tar.FileInfoHeader(fileinfo, "") if err != nil &#123; fmt.Println(err) &#125; err = tw.WriteHeader(hdr) //写入头文件信息 if err != nil &#123; fmt.Println(err) &#125; f1, err := os.Open("Golang.txt") if err != nil &#123; fmt.Println(err) return &#125; m, err := io.Copy(tw, f1) //将Golang.txt文件中的信息写入压缩包中 if err != nil &#123; fmt.Println(err) &#125; fmt.Println(m)&#125; 解压的步骤如下： 1.打开文件 x.tar，然后从这个 tar 头部中循环读取存储在这个归档文件内的文件头信息； 2.从这个文件头里读取文件名，以这个文件名创建文件，然后向这个文件里写入数据即可； 123456789101112131415161718192021222324252627282930313233package mainimport ( "archive/tar" "fmt" "io" "os")func main() &#123; f, err := os.Open("output.tar") if err != nil &#123; fmt.Println("文件打开失败", err) return &#125; defer f.Close() r := tar.NewReader(f) for hdr, err := r.Next(); err != io.EOF; hdr, err = r.Next() &#123; if err != nil &#123; fmt.Println(err) return &#125; fileinfo := hdr.FileInfo() fmt.Println(fileinfo.Name()) f, err := os.Create(fileinfo.Name()+"2") if err != nil &#123; fmt.Println(err) &#125; defer f.Close() _, err = io.Copy(f, r) if err != nil &#123; fmt.Println(err) &#125; &#125;&#125; 各种格式的速度以及大小对比 后缀 读取 写入 大小(KiB) 读/写LOC 格式 .gob 0.3 0.2 7948 21 + 11 =32 Go二进制 .gob.gz 0.5 1.5 2589 json 4.5 2.2 16283 32+17 = 49 JSON .json.gz 4.5 3.4 2678 .xml 6.7 1.2 18917 45 + 30 = 75 XML .xml.gz 6.9 2.7 2730 .txt 1.9 1.0 12375 86 + 53 = 139 纯文本（UTF-8） .txt.gz 2.2 2.2 2514 .bin 1.7 3.5 7250 128 + 87 = 215 自定义二进制 .bin.gz 1.6 2.6 2400 More info: Golang]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang（二）Go语言的基本语法(上)]]></title>
    <url>%2F2021%2F03%2F15%2FGolang02%2F</url>
    <content type="text"><![CDATA[本文章主要介绍 Golang 的基本语法。 Quick Guide一、变量类型 基本 布尔型 数值 整型 浮点 复数 字符串 派生 指针 数值 结构 管道 函数 切片 声明定义12345678910111213// 标准格式var 变量名(命名规则遵循骆驼命名法,例如:aBit) 变量类型// 批量格式var ( a int b string c []float32 d func() bool e struct &#123; x int &#125;) 样例12345// c++int* a,b; //a 是指针而 b 不是// govar a, b *int //a b 都是指针 简短格式 定义变量,同时显式初始化 不能提供数据类型 只能用在函数内部 1名字 := 表达式 12345678package main // 声明 main 包import ( "fmt" // 导入 fmt 包，打印字符串是需要用到)func main() &#123; // 声明 main 主函数 i, j := 0, 1 fmt.Println(i,j) // 打印 Hello World!&#125; 匿名变量匿名变量是一个下画线”_”(空白标识符),仅用于声明,不能存储值. 12345678910111213package main // 声明 main 包import ( "fmt" // 导入 fmt 包，打印字符串是需要用到)func GetData() (int, int) &#123; return 100, 200&#125;func main()&#123; a, _ := GetData() _, b := GetData() fmt.Println(a, b)&#125; 变量同时赋值1234567891011package main // 声明 main 包import ( "fmt" // 导入 fmt 包，打印字符串是需要用到)func main() &#123; // 声明 main 主函数 var a int = 100 var b int = 200 b, a = a, b fmt.Println(a, b)&#125; 变量的作用域 函数内定义的变量称为局部变量 函数外定义的变量称为全局变量 函数定义中的变量称为形式参数 123456789101112131415161718package mainimport ( "fmt")//全局变量 avar a int = 0func sum(a, b int) int &#123; num := a + b return num&#125;func main() &#123; //局部变量 a 和 b c,d := 3,4 f := sum(c, d) fmt.Printf("%d\n", f)&#125; 数据类型转换 Go语言不存在隐式类型转换,所以类型转换都必须显式声明 只有相同底层类型的变量之间才可以进行转换（例如 int16 转换成 int32）.不同将引起编译错误（例如 bool 转换为 int） 12// 类型 B 的值 = 类型 B(类型 A 的值)valueOfTypeB = typeB(valueOfTypeA) 1234567891011121314package mainimport ( "fmt")func main() &#123; // 初始化一个32位整型值 var a int32 = 1008600 // 输出变量的十六进制形式和十进制值 fmt.Printf("int32: 0x%x %d\n", a, a) // 将a变量数值转换为十六进制, 发生数值截断 b := int16(a) // 输出变量的十六进制形式和十进制值 fmt.Printf("int16: 0x%x %d\n", b, b)&#125; 字符串和数值类型的相互转换 Go中的 strconv 包( Atoi()、Itia()、parse 系列函数、format 系列函数、append 系列函数等)为我们提供了字符串和基本数据类型之间的转换功能. 123456789101112131415161718192021222324252627282930313233343536373839package mainimport ( "fmt" "strconv")func main() &#123; str1 := "10010" str2 := "t" // 字符串转换数字 num1, err := strconv.Atoi(str1) if err != nil &#123; fmt.Printf("%v 转换失败！", str1) &#125; else &#123; fmt.Printf("type:%T value:%#v\n", num1, num1) &#125; // 字符串转换数字 num2, err := strconv.Atoi(str2) if err != nil &#123; fmt.Printf("%v 转换失败！", str2) &#125; else &#123; fmt.Printf("type:%T value:%#v\n", num2, num2) &#125; // 字符串转换布尔型 boo1, err := strconv.ParseBool(str1) if err != nil &#123; fmt.Printf("str1: %v\n", err) &#125; else &#123; fmt.Println(boo1) &#125; // 字符串转换布尔型 boo2, err := strconv.ParseBool(str2) if err != nil &#123; fmt.Printf("str2: %v\n", err) &#125; else &#123; fmt.Println(boo2) &#125;&#125; 特殊的变量一个变量存储一个值的内存地址 声明指针变量 12var var_name var_type = var_valuevar ptr *var_type 为指针变量赋值变量的存储地址 1ptr := &amp;var_name 访问指针变量中指向地址的值 1*ptr 当一个指针被定义后没有分配到任何变量时,它的值为 nil 123456789101112131415161718package mainimport "fmt"func main() &#123; var a int= 10 /* 声明实际变量 */ var ak *int /* 1.声明指针变量 */ ak = &amp;a /* 2.为指针变量赋值变量的存储地址 */ fmt.Printf("a 变量的地址是: %x\n", &amp;a ) /* 指针变量的存储地址 */ fmt.Printf("ak 变量储存的指针地址: %x\n", ak ) /* 3.使用指针访问值 */ fmt.Printf("*ak 变量的值: %d\n", *ak )&#125; 常量Go语言中的常量使用关键字 const 定义，用于存储不会改变的数据，常量是在编译时被创建的，即使定义在函数内部也是如此，并且只能是布尔型、数字型（整数型、浮点型和复数）和字符串型。由于编译时的限制，定义常量的表达式必须为能被编译器求值的常量表达式。 1const pi = 3.14159 // 相当于 math.Pi 的近似值 iota 常量生成器12345678910type Weekday intconst ( Sunday Weekday = iota Monday Tuesday Wednesday Thursday Friday Saturday) 无类型常量 常量并没有一个明确的基础类型 编译器为这些没有明确的基础类型的数字常量提供比基础类型更高精度的算术运算 变量的生命周期变量的生命周期指的是在程序运行期间变量有效存在的时间间隔。 函数内定义的变量称为局部变量:从声明语句直到该变量不再被引用为止 函数外定义的变量称为全局变量:程序的运行周期一致 函数定义中的变量称为形式参数:函数被调用的时候创建 123456789101112package mainimport "fmt"var num int // 全局变量func main() &#123; num = 2 for t := 0; t &lt; num; t += 1 &#123; x := int(t) // t 形式参数 x 局部变量 fmt.Printf("x: %d\n", x) &#125;&#125; 类型别名123456789101112type TypeAlias = Type// 将NewInt定义为int类型type NewInt int// 将int取一个别名叫IntAliastype IntAlias = int// 定义商标结构type Brand struct &#123;&#125;// 为Brand定义一个别名FakeBrandtype FakeBrand = Brand TypeAlias 只是 Type 的别名，本质上 TypeAlias 与 Type 是同一个类型， 关键字与标识符关键字关键字即是被Go语言赋予了特殊含义的单词，也可以称为保留字。 break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 标识符标识符是指Go语言对各种变量、方法、函数等命名时使用的字符序列，标识符由若干个字母、下划线_、和数字组成，且第一个字符必须是字母。通俗的讲就是凡可以自己定义的名称都可以叫做标识符。 由 26 个英文字母、0~9、_组成； 不能以数字开头，例如 var 1num int 是错误的； Go语言中严格区分大小写； 标识符不能包含空格； 不能以系统保留关键字作为标识符，比如 break，if 等等。 二、注释注释的定义及使用 1234567//单行注释/*第一行注释第二行注释...*/ 三、语句条件语句if语法如下: 1234567891011121314151617if 布尔表达式 &#123; /* 在布尔表达式为 true 时执行 */&#125;if 布尔表达式 &#123; /* 在布尔表达式为 true 时执行 */&#125;else&#123; /* 在布尔表达式为 false 时执行 */&#125;if 布尔表达式1 &#123; /* 在布尔表达式1为 true 时执行 */&#125;else if 布尔表达式2&#123; /* 在布尔表达式2为 true 时执行 */&#125;else&#123; /* 在布尔表达式1 2都为 false 时执行 */&#125; 1234567891011121314151617181920212223package mainimport "fmt"func main() &#123; if true &#123; fmt.Printf("在布尔表达式为 true 时执行\n") &#125; if false &#123; fmt.Printf("在布尔表达式为 true 时执行\n") &#125; else &#123; fmt.Printf("在布尔表达式为 false 时执行\n") &#125; if false &#123; fmt.Printf("在布尔表达式1为 true 时执行\n") &#125; else if false &#123; fmt.Printf("在布尔表达式2为 true 时执行\n") &#125; else &#123; fmt.Printf("在布尔表达式1和2都为 false 时执行\n") &#125;&#125; 关键字if和左边的大括号{必须同一行,关键字else必须和右边的大括号}在同一行,这两条规则都是被编译器强制规定的。 switchswitch 用于基于不同条件执行不同动作，每一个 case 最后自带 break 语句,匹配成功后就不会执行其他 case,如果需要执行后面的 case,可以使用 fallthrough. 语法如下: 1234567891011121314151617181920212223switch var &#123; case val1: /* var 为 val1 时执行 */ case val2: /* var 为 val2 时执行 */ case val3,val4,val5: /* var 为 val3或val4或val5 时执行 */ /* 你可以定义任意数量的 case */ default://可选 /* var 都不满足上面的值执行 */&#125;switch &#123; case 布尔表达式1: /* 在布尔表达式1为 true 时执行 */ case 布尔表达式2: /* 在布尔表达式2为 true 时执行 */ case 布尔表达式3,布尔表达式4,布尔表达式5: /* 在布尔表达式3或者4或者5为 true 时执行 */ /* 你可以定义任意数量的 case */ default://可选 /* var 都不满足上面的条件执行 */&#125; 循环语句for1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253for 控制变量赋初值; 循环控制条件; 控制变量增量或减量 &#123; /* 循环控制条件为 true 时执行 */&#125;for &#123; /* 无限循环执行 */&#125;//类似whilefor 循环控制条件 &#123; /* 循环控制条件为 true 时执行 */&#125;for inedex,value:= range (字符串/数组/切片)&#123; /* 对字符串、数组、切片等进行迭代输出元素 */&#125;package mainimport "fmt"func main() &#123; sum := 0 for i := 0; i &lt;= 10; i++ &#123; sum += i &#125; fmt.Println(sum) for j := 10; j &lt;= 0; j-- &#123; sum += j &#125; fmt.Println(sum) for sum &lt;= 10 &#123; sum += sum &#125; fmt.Println(sum) for sum &lt;= 10 &#123; sum += sum &#125; fmt.Println(sum) // for &#123; // sum++ // 无限循环下去 // &#125; // fmt.Println(sum) // 无法输出 strings := []string&#123;"google", "alibaba"&#125; for i, s := range strings &#123; fmt.Println(i, s) &#125; numbers := [5]int&#123;5, 4, 3, 2, 1&#125; for i, x := range numbers &#123; fmt.Printf("第 %d 位的值 = %d\n", i, x) &#125;&#125; 控制语句可以控制语句的执行过程. break:用于中断当前 for 循环或跳出 switch 语句 continue:跳过当前循环剩余的语句,进行下一轮循环 goto:将跳转到被标记的语句 1234567891011121314151617181920212223242526272829303132333435package mainimport "fmt"func main() &#123; for i := 0; i &lt;= 10; i++ &#123; fmt.Println(i) if 1 == 1 &#123; fmt.Println("this is break.") break &#125; &#125; for i := 0; i &lt;= 10; i++ &#123; fmt.Println(i) if 1 == 1 &#123; continue fmt.Println("this is skip statement.") &#125; &#125; var i int = 0LOOP: for i &lt;= 10 &#123; fmt.Println(i) if i == 5 &#123; // 跳过迭代 i += 1 goto LOOP &#125; fmt.Printf("i的值为 : %d\n", i) i++ &#125;&#125; 四、函数普通函数 函数声明:包括函数名、形式参数列表、返回值列表（可省略）以及函数体,语法如下: 123func 函数名(形式参数列表)(返回值列表)&#123; 函数体&#125; - 形式参数列表:函数的参数名以及类型,这些参数作为局部变量,其值由参数调用者提供 - 返回值列表:函数返回值的变量名以及类型,如果函数返回一个无名变量或者没有返回值,则返回值列表的括号是可以省略的 调用函数 1返回值变量列表 = 函数名(参数列表) - 函数名：需要调用的函数名。 - 参数列表：参数变量以逗号分隔，尾部无须以分号结尾。 - 返回值变量列表：多个返回值使用逗号分隔。 1234567891011121314151617package mainimport ( "fmt")func add(x int, y int) int &#123; return x + y &#125;func sub(x, y int) (z int) &#123; z = x - y; return &#125;func zero(x int, y int) &#123; fmt.Printf("0") &#125;func zero(args ...int) &#123; fmt.Printf("0") &#125;func main() &#123; fmt.Printf("%v\n", add(2, 1)) // 不带有变量名的返回值 fmt.Printf("%v\n", sub(2, 1)) // 带有变量名的返回值 fmt.Printf("%T\n", zero) // 没有返回值&#125; 匿名函数 声明 语法如下: 1234func(参数列表)(返回参数列表)&#123; 函数体&#125;调用 - 在定义时调用匿名函数 - 作为回调函数:把函数作为值保存到变量中,然后调用函数变量 123456789101112131415161718package mainimport "fmt"func main() &#123; // 在定义时调用匿名函数,传递参数为 10086 func(phone int) &#123; fmt.Println("hello", phone) &#125;(10086) // 匿名将匿名函数体保存到f()中 f := func(phone int) &#123; fmt.Println("hello", phone) &#125; // 使用f()调用 f(10086)&#125; 引用了外部变量的匿名函数–闭包1234567891011121314151617181920package mainimport ( "fmt")func main() &#123; // 准备一个字符串 str := "hello world" // 创建一个匿名函数 foo := func() &#123; // 匿名函数中访问str str = "hello dude" &#125; // 调用匿名函数 foo() fmt.Printf(str)&#125; 方法一种作用 于特定类型变量 的函数 。这种特定类型变量叫做接收器（ Receiver ） 。如果将特定类型理解为结构体或“类”时，接收器的概念就类似于其他语言中的 this 或 者 self。在 Go 语言中，接收器的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 1234567891011121314151617181920212223242526func (variable_name variable_data_type) function_name() [return_type]&#123; /* 函数体*/&#125;package mainimport ( "fmt")/* 定义结构体 */type Circle struct &#123; radius float64&#125;//该 method 属于 Circle 类型对象中的方法func (c Circle) getArea() float64 &#123; //c.radius 即为 Circle 类型对象中的属性 return 3.14 * c.radius * c.radius&#125;func main() &#123; var c1 Circle c1.radius = 10.00 fmt.Println("圆的面积 = ", c1.getArea())&#125; 可变参数123456789101112131415161718func function_name(args ...variable_data_type) [return_type]&#123; /* 函数体*/&#125;package mainimport ( "fmt")func myArgs(args ...int) &#123; for _, arg := range args &#123; fmt.Println(arg) &#125;&#125;func main() &#123; myArgs(2, 3, 4)&#125; 延迟执行语句–defer将其后面跟随的语句进行延迟处理,在 defer 归属的函数即将返回时,将延迟处理的语句按 defer 的逆序执行 123456789101112131415package mainimport ( "fmt")func main() &#123; fmt.Println("defer begin") // 将defer放入延迟调用栈 defer fmt.Println(1) defer fmt.Println(2) // 最后一个放入, 位于栈顶, 最先调用 defer fmt.Println(3) fmt.Println("defer end")&#125; More info: Golang]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang（一）Golang的基本概念]]></title>
    <url>%2F2021%2F02%2F15%2FGolang01%2F</url>
    <content type="text"><![CDATA[Go语言（或 Golang）起源于 2007 年，并在 2009 年正式对外发布。Go 是 Google的 Robert Griesemer，Rob Pike 及 Ken Thompson 开发的一种静态强类型、编译型语言。它的主要目标是“兼具Python等动态语言的开发速度和 C/C++等编译型语言的性能与安全性”。 本文章主要介绍 Golang 的特点和部署使用。 Quick Guide一、特点 类C语言：相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等思想，还有编译后机器码的运行效率以及和现有操作系统的无缝适配。 不损失应用程序性能的情况下降低代码的复杂性，具有“部署简单、并发性好、语言设计良好、执行性能好”等优势 强大的网络编程和并发编程支持 没有类和继承的概念，通过接口（interface）的概念来实现多态性 二、优势 编程热度 开发和运行效率兼得:Go拥有接近C的运行效率和接近PHP的开发效率 简洁强大的并发: 学习难度低：类C的语法,如果熟悉C语言及其派生语言,一周就可以写出高性能的应用 三、安装部署windows例如window用户： 1.点击官网，选择对应系统包安装，点击下载 2.下载完一路点击安装就可以了。安装完成后，在安装目录下将生成一些目录和文件 3.设置环境变量 win+E,然后右键这台电脑→属性→高级系统设置→环境变量，如下图所示。 在弹出的菜单里点击新建三个变量并配置到Path上。 GOROOT:刚才go的安装路径 GOBIN:go的执行程序路径 GOPATH:准备使用go进行开发的工程路径, 四、开发工具 Goland:是由 JetBrains 公司专门为开发者提供的一个符合人体工程学的商业 IDE。 LiteIDE:一款专门针对 Go 开发的集成开发环境，在编辑、编译和运行 Go 程序和项目方面都有非常好的支持。 Sublime Text:是一个革命性的跨平台（Linux、Mac OS X、Windows）文本编辑器，它支持编写非常多的编程语言代码。对于 Go 而言，它有一个插件叫做 GoSublime 来支持代码补全和代码模版。 GoClipse: Eclipse 的插件，拥有非常多的特性以及通过 GoCode 来实现代码补全功能。 VS Code: 是一款由微软公司开发的，能运行在 Mac OS X、Windows 和 Linux 上的跨平台开源代码编辑器 使用 1.在自己建好的GOPATH下，新建三个目录 src 目录：放置项目和库的源文件； pkg 目录：放置编译后生成的包/库的归档文件； bin 目录：放置编译后生成的可执行文件 2.在src下面创建main目录,然后再目录下新建main.go,然后进行语言入门打卡操作 1234567package main // 声明 main 包import ( "fmt" // 导入 fmt 包，打印字符串是需要用到)func main() &#123; // 声明 main 主函数 fmt.Println("Hello World!") // 打印 Hello World!&#125; 3.编译和运行代码:如果是Goland使用ctrl+shift+F10,也可以使用下面命令: go build fileName :将代码编译成二进制的可执行文件，但是需要手动运行该二进制文件 go run fileName :在编译后直接运行程序，编译过程中会产生一个临时文件，但不会生成可执行文件 五、命令工具 go build：编译命令 -v: 编译时显示包名 -p n 开启并发编译，默认情况下该值为 CPU 逻辑核数 -a 强制重新构建 -n 打印编译时会用到的所有命令，但不真正执行 -x 打印编译时会用到的所有命令 -race 开启竞态检测 go clean：清除编译文件 i 清除关联的安装的包和可运行文件，也就是通过go install安装的文件； n 把需要执行的清除命令打印出来，但是不执行，这样就可以很容易的知道底层是如何运行的； r 循环的清除在 import 中引入的包； x 打印出来执行的详细命令，其实就是 -n 打印的执行版本； cache 删除所有go build命令的缓存 testcache 删除当前包所有的测试结果 go run：编译并运行 go install：编译并安装 go get：一键获取代码、编译并安装 -v 显示操作流程的日志及信息，方便检查错误 -u 下载丢失的包，但不会更新已经存在的包 -d 只下载，不安装 -insecure 允许使用不安全的 HTTP 方式进行下载操作 go generate：在编译前自动化生成某类代码 run 正则表达式匹配命令行，仅执行匹配的命令； v 输出被处理的包名和源文件名； n 显示不执行命令； x 显示并执行命令； go test：单元测试命令 go fmt：格式化代码文件 -l 仅把那些不符合格式化规范的、需要被命令程序改写的源码文件的绝对路径打印到标准输出。而不是把改写后的全部内容都打印到标准输出。 -w 把改写后的内容直接写入到文件中，而不是作为结果打印到标准输出。 -r 添加形如“a[b:len(a)] -&gt; a[b:]”的重写规则。如果我们需要自定义某些额外的格式化规则，就需要用到它。 -s 简化文件中的代码。 -d 只把改写前后内容的对比信息作为结果打印到标准输出。而不是把改写后的全部内容都打印到标准输出。 命令程序将使用 diff 命令对内容进行比对。在 Windows 操作系统下可能没有 diff 命令，需要另行 安装。 -e 打印所有的语法错误到标准输出。如果不使用此标记，则只会打印每行的第 1 个错误且只打印前 10 个错误。 -comments 是否保留源码文件中的注释。在默认情况下，此标记会被隐式的使用，并且值为 true。 -tabwidth 此标记用于设置代码中缩进所使用的空格数量，默认值为 8。要使此标记生效，需要使用“-tabs”标记并把值设置为 false。 -tabs 是否使用 tab（’\t’）来代替空格表示缩进。在默认情况下，此标记会被隐式的使用，并且值为 true。 -cpuprofile 是否开启 CPU 使用情况记录，并将记录内容保存在此标记值所指的文件中。 go pprof：性能分析工具** 六、外部工具godocgodoc 工具会从 Go 程序和包文件中提取顶级声明的首行注释以及每个对象的相关注释，并生成相关文档，也可以作为一个提供在线文档浏览的 web 服务器，Go语言官网（https://golang.google.cn/）就是通过这种形式实现的。 1go get golang.org/x/tools/cmd/godoc 安装由于防火墙的原因，国内的用户可能无法通过go get 命令来获取 godoc 工具，这时候就需要大家来手动操作了。 首先从 GitHub（https://github.com/golang/tools.git） 下载 golang.org/x/tools 包； 然后将下载得到的文件解压到 GOPATH 下的 src\golang.org\x\tools 目录中，没有的话可以手动创建； 打开 GOPATH 下的 src\golang.org\x\tools\cmd\godoc 目录，在该目录下打开命令行工具，并执行go build 命令，生成 godoc.exe 可执行文件； 最后，将生成的 godoc.exe 文件移动到 GOPATH 下的 bin 目录中。（需要把 GOPATH 下的 bin 目录添加到环境变量 Path 中） 使用完成上述操作后就可以使用 godoc 工具了，godoc 工具一般有以下几种用法： go doc package：获取包的文档注释，例如go doc fmt 会显示使用 godoc 生成的 fmt 包的文档注释； go doc package/subpackage：获取子包的文档注释，例如go doc container/list； go doc package function：获取某个函数在某个包中的文档注释，例如go doc fmt Printf 会显示有关 fmt.Printf() 的使用说明。 gofmt：go fmt的升级版golint：代码质量的检查More info: Golang]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部署Rap2]]></title>
    <url>%2F2021%2F01%2F15%2F%E9%83%A8%E7%BD%B2Rap2%2F</url>
    <content type="text"><![CDATA[Rap2是一个可视化接口管理工具,通过分析接口结构，动态生成模拟数据，校验真实接口正确性.本文章介绍如何在Centos7.5下面使用dokcer部署Rap2。 Quick Guide 直接使用如果想直接使用，可以点击taobao通过申请一个账号后，即可在里面进行接口的编写、测试。 安装前置 安装docker 安装docker-compose 后端部署rap2-delos: 后端数据API服务器，基于Koa + MySQL 1.部署 12345mkdir rap2cd rap2git clone https://github.com/thx/rap2-delos.gitcd rap2-delosdocker-compose up -d 2.初始化数据库 123docker exec -it rap2-delos sh node scripts/initexit 3.重新启动服务 12docker-compose downdocker-compose up -d 4.测试 1curl localhost:38080 前端部署rap2-dolores: 前端静态资源，基于React 1.拉取代码 123cd ..git clone https://github.com/thx/rap2-dolores.gitcd rap2-dolores 2.创建Dockerfile,复制下面内容到里面 1vi Dockerfile Dockerfile中的内容为： 123456789101112131415161718192021222324# 拉取10.1.0版本的node镜像FROM node:10.1.0# 维护人MAINTAINER ryn# 创建工作目录RUN mkdir -p /home/rap2-doloresWORKDIR /home/rap2-dolores# 将代码拷贝至工作目录COPY . /home/rap2-dolores# 全局安装http-server服务器RUN npm install -g http-server# 全局安装node-sass(一定要带--unsafe-perm，否则会报错)RUN npm install --unsafe-perm -g node-sass# 安装依赖RUN npm install# 打包RUN npm run build 3.创建docker-compose,把下面内容拷贝进去 1vi docker-compose.yml docker-compose.yml中的内容为： 123456789101112131415161718192021222324252627version: '2.2'services: delores: # 容器名称 container_name: rap2-dolores # 通过Dockerfile来构建本地镜像 build: . # 通过images来构建，这里的地址暂不适用，因为src/config中的配置需要根据自己的服务器来动态构建 # image rynxiao/rap2-dolores-nodejs # 指定工作目录 working_dir: /home/rap2-dolores # 指定生产环境 environment: - NODE_ENV=production # 启动http-server，并映射端口到容器内部8081上 command: /bin/sh -c 'http-server ./build -s -p 8081' privileged: true # expose port 38081 ports: - "38081:8081" 4.更改src/config/config.prod.js中的配置，将接口请求地址指向你的后端服务器 1vi src/config/config.prod.js 1234567module.exports = &#123; serve: 'http://&lt;后端服务器ip&gt;:38080', keys: ['some secret hurr'], session: &#123; key: 'koa:sess' &#125;&#125; 5.启动服务 1docker-compose up -d 6.使用浏览器访问访问http://{前端地址}:38081 基本操作 1.注册帐号 2.注册成功后，进去创建一个项目仓库 3.仓库建好以后，我们进入仓库，点击新建接口 4.选择新建接口编辑参数，参数语法参考mock.js语法规范文档 5.点击测试 More info: Github]]></content>
      <tags>
        <tag>环境部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口工具HttpRunner]]></title>
    <url>%2F2020%2F12%2F15%2F%E6%8E%A5%E5%8F%A3%E5%B7%A5%E5%85%B7HttpRunner%2F</url>
    <content type="text"><![CDATA[HttpRunner 是一款面向 HTTP(S) 协议的通用测试框架，只需编写维护一份 YAML/JSON 脚本，即可实现自动化测试、性能测试、线上监控、持续集成等多种测试需求。本文章介绍在Windows7如何安装和使用HttpRunner。 Quick Guide 安装 1.使用pip安装 1pip install httprunner 2.验证安装 1hrun -V 基本使用 1.新建测试项目 1hrun --startproject NewApiTest 2.目录结构说明 debugtalk.py：该文件所在目录将作为项目工程的根目录，api 文件夹都必须与其放置在相同目录 api 文件夹：存储接口定义描述 reports 文件夹：存储 HTML 测试报告 testcases 文件夹（非必须）：存储测试用例，文件夹也可以使用其它名称 testsuite 文件夹（非必须）：测试测试场景，文件夹也可以使用其它名称 3.文件类型说明 YAML/JSON（必须）：测试用例文件，存储接口测试相关信息 debugtalk.py（可选）：存储项目中逻辑运算辅助函数 该文件存在时，将作为项目根目录定位标记，其所在目录即被视为项目工程根目录 该文件不存在时，运行测试的所在路径（CWD）将被视为项目工程根目录 测试用例文件中的相对路径（例如.csv）均需基于项目工程根目录 运行测试后，测试报告文件夹（reports）会生成在项目工程根目录 .env（可选）：存储项目环境变量，通常用于存储项目敏感信息 .csv（可选）：项目数据文件，用于进行数据驱动 reports：默认生成测试报告的存储文件夹 4.测试用例结构 测试用例集（testsuite）：对应一个文件夹，包含单个或多个测试用例（YAML/JSON）文件 测试用例（testcase）：对应一个 YAML/JSON 文件，包含单个或多个测试步骤 测试步骤（teststep）：对应 YAML/JSON 文件中的一个 test，描述单次接口测试的全部内容，包括发起接口请求、解析响应结果、校验结果等 5.测试用例文件结构（YAML/JSON） config：作为整个测试用例的全局配置项 test：对应单个测试步骤（teststep），测试用例存在顺序关系，运行时将从前往后依次运行各个测试步骤。各个测试步骤（test）的变量空间相互独立，互不影响。需在多个测试步骤（test）中传递参数值，则需要使用 extract 关键字，并且只能从前往后传递。 若某变量在 config 中定义了，在某 test 中没有定义，则该 test 会继承该变量 若某变量在 config 和某 test 中都定义了，则该 test 中使用自己定义的变量值 1234567891011[ &#123; "config": &#123;...&#125; &#125;, &#123; "test": &#123;...&#125; &#125;, &#123; "test": &#123;...&#125; &#125;] config参数说明 1234567891011121314151617181920212223"config": &#123; "name": "testcase description", "parameters": [ &#123;"user_agent": ["iOS/10.1", "iOS/10.2", "iOS/10.3"]&#125;, &#123;"app_version": "$&#123;P(app_version.csv)&#125;"&#125;, &#123;"os_platform": "$&#123;get_os_platform()&#125;"&#125; ], "variables": [ &#123;"user_agent": "iOS/10.3"&#125;, &#123;"device_sn": "$&#123;gen_random_string(15)&#125;"&#125;, &#123;"os_platform": "ios"&#125; ], "request": &#123; "base_url": "http://127.0.0.1:5000", "headers": &#123; "Content-Type": "application/json", "device_sn": "$device_sn" &#125; &#125;, "output": [ "token" ]&#125; Key required format descrption name Yes string 测试用例的名称，在测试报告中将作为标题 variables No list of dict 定义的全局变量，作用域为整个用例 parameters No list of dict 全局参数，用于实现数据化驱动，作用域为整个用例 request No dict request 的公共参数，作用域为整个用例；常用参数包括 base_url 和 headers base_url No string 测试用例请求 URL 的公共 host，指定该参数后，test 中的 url 可以只描述 path 部分 headers No dict request 中 headers 的公共参数，作用域为整个用例 output No list 整个用例输出的参数列表，可输出的参数包括公共的 variable 和 extract 的参数; 在 log-level 为 debug 模式下，会在 terminal 中打印出参数内容 test参数说明 12345678910111213141516171819202122232425"test": &#123; "name": "get token with $user_agent, $os_platform, $app_version", "request": &#123; "url": "/api/get-token", "method": "POST", "headers": &#123; "app_version": "$app_version", "os_platform": "$os_platform", "user_agent": "$user_agent" &#125;, "json": &#123; "sign": "$&#123;get_sign($user_agent, $device_sn, $os_platform, $app_version)&#125;" &#125;, "extract": [ &#123;"token": "content.token"&#125; ], "validate": [ &#123;"eq": ["status_code", 200]&#125;, &#123;"eq": ["headers.Content-Type", "application/json"]&#125;, &#123;"eq": ["content.success", true]&#125; ], "setup_hooks": [], "teardown_hooks": [] &#125;&#125; Key required format descrption name Yes string 测试步骤的名称，在测试报告中将作为测试步骤的名称 request Yes dict HTTP 请求的详细内容；可用参数详见 python-requests 官方文档 variables No list of dict 测试步骤中定义的变量，作用域为当前测试步骤 extract No list 从当前 HTTP 请求的响应结果中提取参数，并保存到参数变量中（例如token），后续测试用例可通过$token的形式进行引用 validate No list 测试用例中定义的结果校验项，作用域为当前测试用例，用于实现对当前测试用例运行结果的校验 setup_hooks No list 在 HTTP 请求发送前执行 hook 函数，主要用于准备工作 teardown_hooks No list 在 HTTP 请求发送后执行 hook 函数，主要用户测试后的清理工作 6.创建测试用例文件 7.运行 1hrun test_demo.yaml 8.报告 HttpRunnerManagerHttpRunnerManager是基于HttpRunner的接口自动化测试平台,该工具是对 HttpRunner的包装和Web图形化, 另外还增加了一些新概念(项目/模块)用来组织用例 1.前置 安装mysql(推荐5.7+),并设置为utf-8编码，创建相应HttpRunner数据库，设置好相应用户名、密码，启动mysql 安装rabbitmq,需要先安装erlang 2.下载 1git clone https://github.com/HttpRunner/HttpRunnerManager.git 3.修改配置 打开HttpRunnerManager/HttpRunnerManager/settings.py配置对应mysql和rabbitmq信息 123456789101112131415161718192021222324252627282930313233343536373839404142# 修改DATABASES字典为创建的mysql数据库信息和邮件发送账号if DEBUG: DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'HttpRunnerManager', # 新建数据库名 'USER': 'root', # 数据库登录名 'PASSWORD': '', # 数据库登录密码 'HOST': '127.0.0.1', # 数据库所在服务器ip地址 'PORT': '3306', # 监听端口 默认3306即可 &#125; &#125; STATICFILES_DIRS = ( os.path.join(BASE_DIR, 'static'), # 静态文件额外目录 )else: DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'HttpRunnerManager', # 新建数据库名 'USER': 'root', # 数据库登录名 'PASSWORD': '', # 数据库登录密码 'HOST': '127.0.0.1', # 数据库所在服务器ip地址 'PORT': '3306', # 监听端口 默认3306即可 &#125; &#125; STATIC_ROOT = os.path.join(BASE_DIR, 'static')# 修改worker配置为搭建rabbitmq的信息djcelery.setup_loader()CELERY_ENABLE_UTC = TrueCELERY_TIMEZONE = 'Asia/Shanghai'BROKER_URL = 'amqp://guest:guest@127.0.0.1:5672//' # 127.0.0.1即为rabbitmq-server所在服务器ip地址CELERYBEAT_SCHEDULER = 'djcelery.schedulers.DatabaseScheduler'CELERY_RESULT_BACKEND = 'djcelery.backends.database:DatabaseBackend'CELERY_ACCEPT_CONTENT = ['application/json']CELERY_TASK_SERIALIZER = 'json'CELERY_RESULT_SERIALIZER = 'json'CELERY_TASK_RESULT_EXPIRES = 7200 # celery任务执行结果的超时时间，CELERYD_CONCURRENCY = 10 # celery worker的并发数 也是命令行-c指定的数目 根据服务器配置实际更改 默认10CELERYD_MAX_TASKS_PER_CHILD = 100 # 每个worker执行了多少任务就会死掉，我建议数量可以大一些，默认100 4.安装依赖 1pip install -r requirements.txt 5.生成表结构 切换到HttpRunnerManager目录 生成数据库迁移脚本,并生成表结构 12python manage.py makemigrations ApiManager #生成数据迁移脚本python manage.py migrate #应用到db生成数据表 6.创建用户 创建超级用户，用户后台管理数据库，并按提示输入相应用户名，密码，邮箱。 如不需用，可跳过此步骤 1python manage.py createsuperuser 7.启动服务 1python manage.py runserver 0.0.0.0:8000 8.访问 注册和登录:浏览器输入 http://127.0.0.1:8000/api/register/ ,平台的使用可以参考新手入门指导 运维:浏览器输入 http://127.0.0.1:8000/admin/ 输入之前创建的超级用户名、密码，登录后台运维管理系统，可后台管理数据 性能测试 httprunner可以复用python的开源测试框架locust,locust的安装与使用可以看 这里 ，使用locust对yaml/json用例文件中的接口进行压测 1locusts -f D://testcases//test_demo.yaml web监控器启动成功，我们点击转到locust的web页面,配置压测参数： 观察结果 More info: 中文文档]]></content>
      <tags>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部署OpenResty]]></title>
    <url>%2F2020%2F11%2F15%2F%E9%83%A8%E7%BD%B2OpenResty%2F</url>
    <content type="text"><![CDATA[OpenResty是一个基于Nginx的可伸缩的Web平台，默认集成了Lua开发环境。文章介绍如何在居于Centos7.5安装OpenResty。 Quick Deploy部署准备 1.检查依赖库(perl 5.6.1+, libreadline, libpcre, libssl, gcc, curl) 12ldconfig -v | grep -E 'readline|pcre|openssl'yum list installed | grep -E 'perl|gcc|curl' 2.安装依赖库(也可以不检查,直接使用下面命令安装) 1yum install readline-devel pcre-devel openssl-devel perl gcc curl 安装和配置 1.下载安装包 1wget https://openresty.org/download/openresty-1.13.6.2.tar.gz 2.解压安装包 1tar -xzvf openresty-1.13.6.2.tar.gz 3.编译(默认情况下程序会安装到 /usr/local/openresty 目录,你可以使用 ./configure –help 查看更多的配置选项) 1234cd openresty-1.13.6.2./configuremake make install 重要目录说明 nginx sbin nignx 启动程序 logs access.log 访问日志 error.log 错误日志 conf nginx.con 配置文件 简单实例 1.创建日志和配置目录 123mkdir /home/test/logs/conf/cd /home/test/mkdir logs/ conf/ 2.打开配置文件 1vi conf/nginx.conf 3.新增配置 123456789101112131415161718192021#启动一个进程worker_processes 1; #设置错误日志目录error_log logs/error.log;events &#123; worker_connections 1024;&#125;http &#123; server &#123; #设置端口 listen 9000; #设置访问路径 location / &#123; default_type text/html; #设置返回内容 content_by_lua ' ngx.say("&lt;p&gt;Hello, World!&lt;/p&gt;") '; &#125; &#125;&#125; 3.启动 OpenResty (如果没有任何输出，说明启动成功，-p 指定我们的项目目录，-c 指定配置文件) 1/usr/local/openresty/nginx/sbin/nginx -p /home/test/ -c /home/test/conf/nginx.conf 4.访问OpenResty(通过curl或者浏览器访问,返回 Hello World为启动成功) 1curl http://localhost:9000/ More info: 新手上路]]></content>
      <tags>
        <tag>环境部署</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ELK（三）Kibana]]></title>
    <url>%2F2020%2F10%2F15%2FELK03%2F</url>
    <content type="text"><![CDATA[Kibana 是一个针对Elasticsearch的开源分析及可视化平台，用来搜索、查看交互存储在Elasticsearch索引中的数据。使用 Kibana，可以通过各种图表进行高级数据分析及展示。 本文章主要介绍 Kibana 的入门知识。 Quick Guide Kibana架构为Elasticsearch定制，可以将任何结构化和非结构化数据加入Elasticsearch索引。Kibana还充分利用了Elasticsearch强大的搜索和分析功能。 一、优点 整合你的数据：Kibana能够更好地处理海量数据，并据此创建柱形图、折线图、散点图、直方图、饼图和地图。 复杂数据分析：Kibana提升了Elasticsearch分析能力，能够更加智能地分析数据，执行数学转换并且根据要求对数据切割分块。 让更多团队成员受益：强大的数据库可视化接口让各业务岗位都能够从数据集合受益。 接口灵活，分享更容易：使用Kibana可以更加方便地创建、保存、分享数据，并将可视化数据快速交流。 配置简单：Kibana的配置和启用非常简单，用户体验非常友好。Kibana 4自带Web服务器，可以快速启动运行。 可视化多数据源： Kibana可以非常方便地把来自Logstash、ES-Hadoop、Beats或第三方技术的数据整合到Elasticsearch，支持的第三方技术包括Apache Flume、Fluentd等。 简单数据导出： Kibana可以方便地导出感兴趣的数据，与其它数据集合并融合后快速建模分析，发现新结果。 二、安装部署 1.已经安装Elasticsearch 2.从官网下载解压(与ES相同的版本) 1234cd /hadoop/softwarewget https://artifacts.elastic.co/downloads/kibana/kibana-5.5.1-linux-x86_64.tar.gztar -zxvf kibana-5.5.1-linux-x86_64.tar.gz -C /hadoop/installmv kibana-5.5.1-linux-x86_64 kibana 3.安装 x-pack 1bin/kibana-plugin install x-pack 3.配置 1234567cd /hadoop/install/kibana/vi config/kibana.yml添加内容：server.host: "master"elasticsearch.url: "http://master:9200"kibana.index: ".kibana" 4.启动kibana 12# 先启动ES，必须是在root下运行，否则会报错，启动失败bin/kibana 5.访问：打开 http://localhost:5601 （默认的用户名：elastic，密码：changeme） 6.修改密码 123curl -XPUT -u elastic 'localhost:9200/_xpack/security/user/kibana/_password' -d '&#123; "password" : "123456"&#125; 7.单击侧面导航中的 Discover 进入 Kibana 的数据探索功能： 8.使用查询栏编写语句查询 三、加载自定义索引 1.单击 Management 选项 2.然后单击 Index Patterns 选项。 3.点击Create index pattern定义一个新的索引模式。 4.点击Next step 5.点击Create index pattern 6.出来如下界面，列出了所有index中的字段 7.接下来，我们再来使用一下kibana查看已经导入的索引数据 四、搜索数据 左上方是 填入条件过滤，右上方是数据的时间范围，左侧栏是 搜索结果的展示字段（具体参考官方文档） More info: Kibana]]></content>
      <tags>
        <tag>elk</tag>
        <tag>kibana</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ELK（二）Logstash]]></title>
    <url>%2F2020%2F09%2F15%2FELK02%2F</url>
    <content type="text"><![CDATA[Logstash 是一个开源数据收集引擎，具有实时管道功能。Logstash 可以动态地将来自不同数据源的数据统一起来，并将数据标准化到你所选择的目的地。 本文章主要介绍 Logstash 的入门知识。 Quick Guide Logstash是一个开源的服务器端数据处理管道，可以同时从多个数据源获取数据，并对其进行转换，然后将其发送到你最喜欢的“存储”。（Elasticsearch） 流程1.输入：采集各种样式、大小和来源的数据 数据往往以各种各样的形式，或分散或集中地存在于很多系统中。Logstash 支持各种输入选择 ，可以在同一时间从众多常用来源捕捉事件。能够以连续的流式传输方式，轻松地从您的日志、指标、Web 应用、数据存储以及各种 AWS 服务采集数据。 2.过滤器：实时解析和转换数据 数据从源传输到存储库的过程中，Logstash 过滤器能够解析各个事件，识别已命名的字段以构建结构，并将它们转换成通用格式，以便更轻松、更快速地分析和实现商业价值。Logstash 能够动态地转换和解析数据，不受格式或复杂度的影响： 利用 Grok 从非结构化数据中派生出结构 从 IP 地址破译出地理坐标 将 PII 数据匿名化，完全排除敏感字段 整体处理不受数据源、格式或架构的影响 3.输出：选择你的存储，导出你的数据 尽管 Elasticsearch 是我们的首选输出方向，能够为我们的搜索和分析带来无限可能，但它并非唯一选择。 Logstash 提供众多输出选择，您可以将数据发送到您要指定的地方，并且能够灵活地解锁众多下游用例。 安装1.前置安装 java 8 以上版本（包含） 2.官网下载解压123wget https://artifacts.elastic.co/downloads/logstash/logstash-5.6.1.tar.gz -o /hadoop/softwaretar -zxvf /hadoop/software/logstash-5.6.1.tar.gz -C /hadoop/installmv /hadoop/install/logstash-5.6.1 /hadoop/install/logstash 3.测试 1.简单输出到控制台 12cd /hadoop/install/logstashbin/logstash -e 'input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;' 2.新建配置文件： 1vi logstash.conf 配置内容： 1234567891011121314151617181920input &#123; file &#123; type =&gt; "server" codec =&gt;json #读取文件的位置，一定准确，否则elasticsearch读取不到 path =&gt;"/logs/finance/1.log &#125; &#125; filter &#123; grok &#123; match =&gt; &#123; "message" =&gt; "^%&#123;TIMESTAMP_ISO8601&#125;" &#125; &#125;&#125;output &#123; elasticsearch &#123; hosts =&gt; ["localhost:9200"] #写入到elasticsearch中的地址信息 index =&gt; "trace_test_log" #文档索引 &#125;&#125; 3.使用配置 1bin/logstash -f logstash.conf 4.访问http://localhost:9600/]]></content>
      <tags>
        <tag>elk</tag>
        <tag>logstash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ELK（一）Elasticsearch]]></title>
    <url>%2F2020%2F08%2F15%2FELK01%2F</url>
    <content type="text"><![CDATA[Elasticsearch（ 数据搜索引擎持久化 ）、Logstash （ 数据收集 ） 、 Kibana （ 数据分析工具 ）的分析和可视化平台一起开发的。这三个产品被设计成一个集成解决方案，称为“Elastic Stack”（以前称为“ELK stack”）。 本文章主要介绍 Elasticsearch 的入门知识。 Quick Guide Elasticsearch是一个开源的分布式. RESTful 风格的搜索和数据分析引擎，它的底层是开源库Apache Lucene。 Lucene 可以说是当下最先进. 高性能. 全功能的搜索引擎库——无论是开源还是私有，但它也仅仅只是一个库。为了充分发挥其功能，你需要使用 Java 把 Lucene 集成到应用程序中，使用比较复杂。 为了解决Lucene使用时的繁复性，于是Elasticsearch便应运而生。它使用 Java 对Lucene 做了一层封装，提供了一套简单一致的 RESTful API 来帮助我们实现存储和检索。 一、基本概念 Elasticsearch 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。 关系型数据库（MySQL） Elasticsearch 数据库database 索引 index 表 table 类型 type 数据行 row 文档 document 数据列 column 字段 field Elasticsearch 的文件存储是面向文档型数据库，一条数据在这里就是一个文档，用JSON作为文档序列化的格式，比如下面这条用户数据： 12345678&#123; "name" : "John", "sex" : "Male", "age" : 25, "birthDate": "1990/05/01", "about" : "I love to go rock climbing", "interests": [ "sports", "music" ]&#125; 用Mysql这样的数据库存储就会容易想到建立一张User表，有name、sex等字段，在 Elasticsearch 里这就是一个属于User的类型，各种各样的类型存在于一个索引当中。 一个 Elasticsearch 集群可以包含多个索引(数据库)，也就是说其中包含了很多类型(表)。这些类型中包含了很多的文档(行)，然后每个文档中又包含了很多的字段(列)。Elasticsearch的交互，可以使用Java API，也可以直接使用HTTP的Restful API方式。 123456789# 插入一条记录，可以简单发送一个HTTP的请求PUT /megacorp/employee/1 ( /&lt;索引名称&gt;/&lt;类型名称&gt;/&lt;指定id&gt; )&#123; "name" : "John", "sex" : "Male", "age" : 25, "about" : "I love to go rock climbing", "interests": [ "sports", "music" ]&#125; 更新、查询也是类似这样的操作，具体操作手册可以参考 Elasticsearch权威指南 二、Elasticsearch 模块结构 第一层：Gateway层：Elasticsearch 索引的持久化存储方式 。 ElasticSearch 默认先把索引存储在内存中，然后当内存满的时候，再持久化到Gateway里。当ES集群关闭或重启的时候，它就会从Gateway里去读取索引数据。比如LocalFileSystem和HDFS、AS3等。 第二层：Distributed lucene directory层： Lucene里的一些列索引文件组成的目录。它负责管理这些索引文件。包括数据的读取、写入，以及索引的添加和合并等。 第三层：Elasticsearch 对数据的加工处理方式，mapping：定义索引下面type字段的处理规则，比如：索引如何建立数据类型等等，相当于关系型数据里面的schema。River是一个运行在 Elasticsearch 集群内部的一个插件，主要是用来从外部获取异构数据，然后在 Elasticsearch 里创建索引，常见的插件有rabbitmq. twitter river。 第四层：是 Elasticsearch 自动发现节点的机制。Zen是用来实现节点自动发现，还有master节点选取用的，假如maste出现了故障，不能工作了，那么其它节点会自动选举，然后产生一个新的master。Elasticsearch 是基于P2P的系统，它首先头通过广播机制寻找存在的节点，然后再通过多播协议来进行节点间的通信，同时也支持点对点交互。 第五层：是 Elasticsearch 的脚本执行功能，有了这个功能很方便的对查询出来的数据进行加工处理，脚本类型：mvel. js. python等。 第六层：3rd plugins：意思是 Elasticsearch 支持安装很多第三方插件。 第七层：是 Elasticsearch 的交互方式，支持三种协议：thrift. memcached. http，其中 Elasticsearch 是默认用http协议传输的。 Restful Style API：是 Elasticsearch 的API支持模式，现在这个RESTFUL这样的API接口的标准是非常流行的 java(Netty)：Elasticsearch 采用了java语言，同时java语言也是对 Elasticsearch 支持度最好的语言，因为这个lucene是基于java开发的。 三、安装部署 0.安装 java 8 以上版本（包含） 1.下载安装 123wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.5.1.zipunzip elasticsearch-5.5.1.zipcd elasticsearch-5.5.1/ 2.启动 Elasticsearch 1./bin/elasticsearch 如果这时报错”max virtual memory areas vm.maxmapcount [65530] is too low”，要运行命令（ sudo sysctl -w vm.max_map_count=262144 ）。 3.验证 1curl localhost:9200 四、使用 Elasticsearch提供了多种交互使用方式，包括Java API和RESTful API 。现在主要介绍RESTful API ，所有其他语言可以使用RESTful API 通过端口 9200 和 Elasticsearch 进行通信，你可以用你最喜爱的 web 客户端访问 Elasticsearch ，也可以使用 curl 命令来和 Elasticsearch 交互。 一个Elasticsearch请求和任何 HTTP 请求一样，都由若干相同的部件组成： 1curl -X &lt;VERB&gt; '&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;' -d '&lt;BODY&gt;' 返回的数据格式为JSON，因为Elasticsearch中的文档以JSON格式储存。其中被 &lt; &gt; 标记的部件： 部件 说明 VERB 适当的 HTTP 方法 或 谓词 : GET、 POST、 PUT、 HEAD 或者 DELETE。 PROTOCOL http 或者 https（如果你在 Elasticsearch 前面有一个 https 代理） HOST Elasticsearch 集群中任意节点的主机名，或者用 localhost 代表本地机器上的节点。 PORT 运行 Elasticsearch HTTP 服务的端口号，默认是 9200 。 PATH API 的终端路径（例如 _count 将返回集群中文档数量）。Path 可能包含多个组件，例如：_cluster/stats 和 _nodes/stats/jvm 。 QUERY_STRING 任意可选的查询字符串参数 (例如 ?pretty 将格式化地输出 JSON 返回值，使其更容易阅读) BODY 一个 JSON 格式的请求体 (如果请求需要的话) 1.基本操作 1.插入数据 12345curl -X PUT 'localhost:9200/&lt;index_name&gt;/&lt;type_name&gt;/&lt;id&gt;' -d '&#123; "user": "xiaoming", "position": "engineer"&#125;' 2.删除数据 1curl -X DELETE 'localhost:9200/&lt;index_name&gt;/&lt;type_name&gt;/&lt;id&gt;' 3.修改数据（使用插入方式也可以修改数据） 12345curl -X POST 'localhost:9200/&lt;index_name&gt;/&lt;type_name&gt;/&lt;id&gt;/_update' -d '&#123; "user": "daming", "position": "engineer"&#125;' 4.查询数据 12# pretty 代表易读格式curl -X GET 'localhost:9200/&lt;index_name&gt;/&lt;type_name&gt;/&lt;id&gt;?pretty=true' 2.高级查询 1.返回所有记录 1curl -X GET 'localhost:9200/&lt;index_name&gt;/&lt;type_name&gt;/_search' 2.条件搜索 1234567# 查询user等于daming的记录，每次从位置1开始（默认是从位置0开始），只返回一条结果。curl 'localhost:9200/&lt;index_name&gt;/&lt;type_name&gt;/_search' -d '&#123; "query" : &#123; "match" : &#123; "user" : "daming" &#125;&#125;, "size": 1, "from": 1,&#125;' 12345# 查询user等于daming或者xiaoming的记录curl 'localhost:9200/&lt;index_name&gt;/&lt;type_name&gt;/_search' -d '&#123; "query" : &#123; "match" : &#123; "user" : "daming xiaoming" &#125;&#125;,&#125;' 123456789101112# 查询user等于daming且position等于engineer的记录curl 'localhost:9200/&lt;index_name&gt;/&lt;type_name&gt;/_search' -d '&#123; "query": &#123; "bool": &#123; "must": [ &#123; "match": &#123; "user": "daming" &#125; &#125;, &#123; "match": &#123; "position": "engineer" &#125; &#125; ] &#125; &#125;&#125;' More info: ElasticSearch 官方手册]]></content>
      <tags>
        <tag>elk</tag>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据（十六）Hue]]></title>
    <url>%2F2020%2F07%2F15%2F%E5%A4%A7%E6%95%B0%E6%8D%AE16%2F</url>
    <content type="text"><![CDATA[Hue （Hadoop User Experience Hadoop用户体验）是一个开源的 Apache Hadoop UI系统，由Cloudera Desktop演化而来，最后Cloudera公司将其贡献给Apache基金会的Hadoop社区，它是基于Python Web框架Django实现的。通过使用HUE我们可以在浏览器端的Web控制台上与Hadoop集群进行交互，来分析处理数据。 本文章主要介绍 Hue 和 在centos环境下如何安装 。 Quick Guide一、用途 访问HDFS和文件浏览 通过web调试和开发hive以及数据结果展示 查询solr和结果展示，报表生成 通过web调试和开发impala交互式SQL Query spark调试和开发 Pig开发和调试 oozie任务的开发，监控，和工作流协调调度 Hbase数据查询和修改，数据展示 Hive的元数据（metastore）查询 MapReduce任务进度查看，日志追踪 创建和提交MapReduce，Streaming，Java job任务 Sqoop2的开发和调试 Zookeeper的浏览和编辑 数据库（MySQL，PostGres，SQlite，Oracle）的查询和展示 二、架构从总体上来讲，Hue应用采用的是B/S架构，该web应用的后台采用python编程语言别写的。大体上可以分为三层，分别是前端view层、Web服务层和Backend服务层。Web服务层和Backend服务层之间使用RPC的方式调用。 三、安装1.前置 1.安装 python 和 maven 2.安装 hadoop 和 hive 3.创建应用类服务专有用户 1useradd -g hadoop hue 4.安装依赖包 1yum -y install ant asciidoc cyrus-sasl-devel cyrus-sasl-gssapi gcc gcc-c++ krb5-devel libtidy libxml2-devel libxslt-devel openldap-devel python-devel sqlite-devel openssl-devel mysql-devel gmp-devel 2.安装 2.1.下载安装包(官网或者github) 1234567yum install git -ycd /hadoop/installgit clone https://github.com/cloudera/hue.git branch-4.7# 重命名mv branch-4.7 hue 2.2.切换用户 hue 12chown -R hue:hadoop huesu hue 2.3.编译 12cd huemake apps 2.4.修改 /usr/local/hue/desktop/conf/pseudo-distributed.ini 123456789101112131415161718192021222324252627[desktop] # 安全秘钥，存储session的加密处理 secret_key=dfsahjfhflsajdhfljahl # Time zone name time_zone=Asia/Shanghai # Enable or disable debug mode. django_debug_mode=false # Enable or disable backtrace for server error http_500_debug_mode=false # This should be the hadoop cluster admin ## default_hdfs_superuser=hdfs default_hdfs_superuser=root # 不启用的模块 # app_blacklist=impala,security,rdbms,jobsub,pig,hbase,sqoop,zookeeper,metastore,indexer[[database]] # 数据库引擎类型 engine=mysql # 数据库主机地址 host=master # 数据库端口 port=3306 # 数据库用户名 user=root # 数据库密码 password=123456 # 数据库库名 name=hue 3.hue集成hadoop 3.1.修改配置文件，增加代理用户hue1vi $HADOOP_HOME/etc/hadoop/core-site.xml 新增内容：12345678&lt;property&gt;&lt;name&gt;hadoop.proxyuser.hue.hosts&lt;/name&gt;&lt;value&gt;*&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hadoop.proxyuser.hue.groups&lt;/name&gt; &lt;value&gt;*&lt;/value&gt;&lt;/property&gt; 3.2.配置hue:修改 desktop/conf/pseudo-distributed.ini文件 修改标签 [[hdfs_clusters]] 如下：123456789101112131415161718192021222324252627282930[hadoop] # Configuration for HDFS NameNode # ------------------------------------------------------------------------ [[hdfs_clusters]] # HA support by using HttpFs [[[default]]] # Enter the filesystem uri fs_defaultfs=hdfs://master:54310 # NameNode logical name. logical_name=master # Use WebHdfs/HttpFs as the communication mechanism. # Domain should be the NameNode or HttpFs host. # Default port is 14000 for HttpFs. ## webhdfs_url=http://localhost:50070/webhdfs/v1 webhdfs_url=http://master:9870/webhdfs/v1 # Change this if your HDFS cluster is Kerberos-secured ## security_enabled=false # In secure mode (HTTPS), if SSL certificates from YARN Rest APIs # have to be verified against certificate authority ## ssl_cert_ca_verify=True # Directory of the Hadoop configuration ## hadoop_conf_dir=$HADOOP_CONF_DIR when set or &apos;/etc/hadoop/conf&apos; hadoop_conf_dir=$HADOOP_CONF_DIR 修改标签 [[yarn_clusters]] 如下：12345678910111213141516171819202122232425262728293031323334353637383940414243# Configuration for YARN (MR2) # ------------------------------------------------------------------------ [[yarn_clusters]] [[[default]]] # Enter the host on which you are running the ResourceManager ## resourcemanager_host=localhost resourcemanager_host=master # The port where the ResourceManager IPC listens on ## resourcemanager_port=8032 # Whether to submit jobs to this cluster submit_to=True # Resource Manager logical name (required for HA) ## logical_name= # Change this if your YARN cluster is Kerberos-secured ## security_enabled=false # URL of the ResourceManager API ## resourcemanager_api_url=http://localhost:8088 resourcemanager_api_url=http://master:8088 # URL of the ProxyServer API ## proxy_api_url=http://localhost:8088 proxy_api_url=http://master:8088 # URL of the HistoryServer API ## history_server_api_url=http://localhost:19888 history_server_api_url=http://master:19888 # URL of the Spark History Server ## spark_history_server_url=http://localhost:18088 spark_history_server_url=http://master:18080 # Change this if your Spark History Server is Kerberos-secured ## spark_history_server_security_enabled=false # In secure mode (HTTPS), if SSL certificates from YARN Rest APIs # have to be verified against certificate authority ## ssl_cert_ca_verify=True 4.hue集成hive配置 4.1.拷贝配置 hive-site.xml 到目录 123mkdir -p /usr/local/hue/hive/confcp /hadoop/install/apache-hive-3.1.2/conf/hive-site.xml /usr/local/hue/hive/conf/ 4.2.修改desktop/conf/pseudo-distributed.ini的标签[beeswax] 1234567[beeswax] # hiveServer2 服务地址(填主机名，kerberos要用) hive_server_host=master # hiveServer2服务端口 hive_server_port=10000 # hiveServer2 hive-site.xml配置文件存放位置 hive_conf_dir=/usr/local/hue/hive/conf 5.hue集成spark配置 5.1.启动spark的thrift server 12cd /hadoop/install/spark/sbinstart-thriftserver.sh --master yarn --deploy-mode client 5.2.安装livy 12345cd /hadoop/softwarewget http://livy.incubator.apache.org/download/apache-livy-0.6.0-incubating-bin.zipunzip apache-livy-0.6.0-incubating-bin.zip -C mv apache-livy-0.6.0-incubating-bin /hadoop/install/livy-0.6.0 5.3.创建livy的 livy-env.sh 配置文件和log目录 123cd livy-0.6.0/conf/cp livy-env.sh.template livy-env.shmkdir -p /data/livy/logs 5.4.在 livy-env.sh 新建配置 1234export HADOOP_CONF_DIR=/hadoop/install/hadoop/etc/hadoopexport SPARK_HOME=/hadoop/install/sparkexport LIVY_LOG_DIR=/data/livy/logsexport LIVY_PID_DIR=/data/livy/pid 5.5.配置 livy.conf 1cp livy.conf.template livy.conf 5.6.在livy.conf文件中加入以下内容 123456# What port to start the server on.livy.server.port = 8998# What spark master Livy sessions should use.livy.spark.master = yarn# What spark deploy mode Livy sessions should use.livy.spark.deploy-mode = client 5.7.启动livy 1/hadoop/install/livy-0.6.0/bin/livy-server start 5.8.修改 desktop/conf/pseudo-distributed.ini 文件的标签[spark] 12345678910111213141516171819202122232425262728293031############################################################################ Settings to configure the Spark application.###########################################################################[spark] # The Livy Server URL. ## livy_server_url=http://localhost:8998 livy_server_url=http://master:8998 # Configure Livy to start in local &apos;process&apos; mode, or &apos;yarn&apos; workers. ## livy_server_session_kind=yarn livy_server_session_kind=yarn # Whether Livy requires client to perform Kerberos authentication. ## security_enabled=false # Whether Livy requires client to use csrf protection. ## csrf_enabled=false # Host of the Sql Server ## sql_server_host=localhost sql_server_host=master # Port of the Sql Server ## sql_server_port=10000 sql_server_port=10000 # Choose whether Hue should validate certificates received from the server. ## ssl_cert_ca_verify=true########################################################################### 6.MySql初始化 1.建一个名为hue的库 123456789# 登录mysql数据库mysql -u root -p# 创建数据库huecreate database hue;# 创建用户create user 'hue'@'%' identified by '123456';# 授权grant all privileges on hue.* to 'hue'@'%';flush privileges; 2.生成表 12build/env/bin/hue syncdbbuild/env/bin/hue migrate 7.启动hue 启动hue1build/env/bin/supervisor &amp; 2.验证:访问 http://master:8000]]></content>
      <tags>
        <tag>大数据</tag>
        <tag>hue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据（十五）Flink]]></title>
    <url>%2F2020%2F06%2F15%2F%E5%A4%A7%E6%95%B0%E6%8D%AE15%2F</url>
    <content type="text"><![CDATA[这几年大数据的飞速发展，出现了很多热门的开源社区，其中著名的有 Hadoop、Storm，以及后来的 Spark，他们都有着各自专注的应用场景。 Spark 掀开了内存计算的先河，也以内存为赌注，赢得了内存计算的飞速发展。Spark 的火热地掩盖了其他分布式计算的系统身影，例如 Flink在这个时候默默地发展着。在国外一些社区，有很多人将大数据的计算引擎分成了 4 代，当然也有很多人不会认同,我们先姑且这么认为和讨论。 首先第一代的计算引擎，无疑就是 Hadoop 承载的 MapReduce。这里大家应该都不会对 MapReduce 陌生，它将计算分为两个阶段，分别为 Map 和 Reduce。对于上层应用来说，就不得不想方设法去拆分算法，甚至于不得不在上层应用实现多个 Job 的串联，以完成一个完整的算法，例如迭代计算。由于这样的弊端，催生了支持 DAG 框架的产生,因此支持 DAG 的框架被划分为第二代计算引擎，如 Tez 以及更上层的 Oozie。这里我们不去细究各种 DAG 实现之间的区别，不过对于当时的 Tez 和 Oozie 来说，大多还是批处理的任务。 接下来就是以 Spark 为代表的第三代的计算引擎。第三代计算引擎的特点主要是 Job 内部的 DAG 支持（不跨越 Job），以及强调的实时计算。在这里，很多人也会认为第三代计算引擎也能够很好的运行批处理的 Job。随着第三代计算引擎的出现，促进了上层应用快速发展，例如各种迭代计算的性能以及对流计算和 SQL 等的支持。Flink 的诞生就被归在了第四代。这应该主要表现在 Flink 对流计算的支持，以及更一步的实时性上面。当然 Flink 也可以支持 Batch 的任务，以及 DAG 的运算。 本文章主要介绍 Flink 和 在centos环境下如何安装 。 Quick GuideFlink 介绍Apache Flink是一个框架和分布式处理引擎，用于对无界和有界数据流进行有状态计算。Flink设计为在所有常见的集群环境中运行，以内存速度和任何规模执行计算。 1. 批处理和流处理数据集分为有界数据集和无界数据集： 有界数据集：有界数据流就是指输入的数据有始有终。例如数据可能是一分钟或者一天的交易数据等等。处理这种有界数据流的方式也被称之为批处理； 无界数据集：有界数据流就是指有始无终的数据，数据一旦开始生成就会持续不断的产生新的数据，即数据没有时间边界源源不断（比如日志），处理这种有界数据流的方式也被称之为流处理。 我们一般所说的数据流是指数据集，而流数据则是指数据流中的数据。流处理更复杂，因为需要考虑到数据的顺序错乱和系统容错等。 二、架构的演变 1.传统单体数据架构传统单体数据架构中，数据集中存储，架构分成计算层和存储层。这种架构初期效率很高，但是随着 业务种类越来越多，系统越来越难以维护升级，此外 database 是唯一准确的数据源，每个 application 都需要访问 database 来获取对应的数据，一旦 database 发生改变或者出现问题，将会对整个业务系统产生影响。 2.微服务架构微服务架构的核心是：1个 application 由多个小的且相互独立的微型服务组成，各服务的开发和发布不存在依赖关系，这样整个系统相比于之前的传统单体数据架构就更加灵活。 3.大数据 lambada 架构lambada 架构分两种处理途径，Speed layer 负责批处理（比如 Hadoop MapReduce），Batch layer 则负责流处理（比如 Storm）。这种架构存在问题：框架较多会导致平台复杂度高、运维成本高。虽说后面 Spark 框架能够同时支持批计算和流计算，但是Spark Streaming 的流计算本质上依旧是微批处理并非实时流计算。 4.Flink 相比于 Spark Streaming的微批处理模式，Flink 通过 Google Dataflow 模型实现了实时流计算框架，将有界数据集转换成无界数据集统一进行流式处理。Flink 具有如下优势： 流处理特性 高吞吐、低延时、高性能； 支持事件时间（Event Time）概念：大多数框架中窗口计算采用系统时间（即Event 到达计算框架是 host 的当前时刻），而 Flink 则能够基于事件时间（即 Event 本身产生的时刻，当然也可以基于其他类型）语义进行窗口计算。基于事件驱动的优势在于即使 Event 到达的顺序乱了，框架也能够准确知道事件的时序性； 支持高度灵活的窗口计算操作：流处理中，数据就像stream 一样源源不断地进入到框架中进行处理。有时需要通过窗口的方式对 stream 进行一定范围内的聚合计算。比如统计某网页在过去1分钟内的点击数。这种情况下就需要定义一个窗口，收集最近1分钟内的数据，并对这些数据进行计算。Flink 的窗口计算包括Time、Count、Session、Data-driven 等类型的窗口操作，可以灵活使用触发条件定制化来达到复杂的计算需求； 基于轻量级分布式快照（Snapshot）实现容错机制：Flink 可以分布运行在多达上千个节点上，将一个大型计算任务流程分解成多个小的计算stage，再分布到节点上并行处理。任务执行过程中，分布式Snapshot（通过 Save points 实现） 的 Checkpoints能够将状态信息进行持久化到存储介质中（比如磁盘），一旦某些任务出现异常，就能够从Checkpoints 中恢复任务，从而确保数据处理过程中的一致性； 基于 JVM 实现独立的内存管理：大数据处理中内存管理是非常重要的部分，Flink 实现了自身管理内存的机制，且通过 序列化/反序列化方法将所有数据对象转换成二进制存储在内存中，降低数据存储 size 的同时，更高效地利用内存，降低 JVM GC 对框架性能的影响。 API支持 对Streaming数据类应用，提供DataStream API 对批处理类应用，提供DataSet API（支持Java/Scala） Libraries支持 支持机器学习（FlinkML） 支持图分析（Gelly） 支持关系数据处理（Table） 支持复杂事件处理（CEP） 整合支持 支持Flink on YARN 支持HDFS 支持来自Kafka的输入数据 支持Apache HBase 支持Hadoop程序 支持Tachyon 支持ElasticSearch 支持RabbitMQ 支持Apache Storm 支持S3 支持XtreemFS 生态圈 三、Flink应用场景 实时智能推荐； 复杂事件处理； 实时欺诈检测； 实时数仓与 ETL； 流数据分析； 实时报表分析。 四、Flink运行架构 1.术语 Client：用来提交任务给 JobManage JobManager（指挥者，JVM 进程）：JobManagers是在Flink主服务器中运行的组件之一。用于任务调度（分发任务给 TaskManager 去执行）、协调检查点和协调故障恢复； Task：基本的工作单元，由Flink的运行时执行任务。任务是封装运算符或运算符链的一个并行实例。 TaskManager（一个对应一个 JVM 进程）：worker节点执行任务的数据流，缓冲器以及交换数据流； TaskManager Slots ：用来分割资源，控制worker可以接受多少个任务。 Akka：所有组件之间的通信，包括任务状态、Checkpoint 触发等消息。 Netty：数据的传输 Parallelism： 并行度 2.任务提交和处理流程 Client 将 application（任务） 提交到 Flink cluster，并于 JobManager 创建 Akka 连接，然后将application 提交给 JobManager；提交方式包括： CLI（类似 Spark-submit）； Flink WebUI 提交； 应用程序中指定 JobManager 的 RPC 网络端口构建 Execution Environment 提交 Flink 应用； 根据 Flink 集群中 TaskManager 上 TaskSlot 的使用情况，为提交的 application `分配 TaskSlots 资源 并命令 TaskManager 启动 application； TaskManager 从 JobManager 接收计算任务，然后使用 Slot 资源启动 application，建立数据接入的网络连接、接收数据、处理数据；各 TaskManaer 之间的数据交互通过数据流进行； JobManager 和 TaskManager 之间通过 Actor System 进行通信，application 的执行进度会发送给 client 端；在执行 application 过程中，JobManager 会触发 Checkpoints 操作，每个 TaskManager 收到 Checkpoints 触发指令后，会完成 Checkpoint 操作； application 执行完成后，执行状态将会反馈给 client 端，并释放掉 TaskManager 中的资源供下一次提交任务使用。 五、Flink中的编程模型1.编程模型在Flink，编程模型的抽象层级主要分为以下4种，越往下抽象度越低，编程越复杂，灵活度越高。 这4层中，一般用于开发的是第二层，即DataStrem/DataSetAPI。用户可以使用DataStream API处理无界数据流，使用DataSet API处理有界数据流。同时这两个API都提供了各种各样的接口来处理数据。例如常见的map、filter、flatMap等等，而且支持python，scala，java等编程语言，后面的demo主要以scala为主。 Stateful Stream Processiing 位于最底层，是core API的底层实现 process Function 利用低阶，构建一些新组件（比如：利用其定时做一定情况下的匹配和缓存） 灵活度高，但看法比较复杂 Core APIS DataStream 流式处理 DataSet 批量处理 Table &amp; SQL SQL构建在Table之上，都需要构建Table环境。 不同类型的Table构建不同的Table环境。 Table可以与DataStream或者DataSet进行相互转换。 Streaming SQL不同存储的SQL， 最终会转化为流式执行计划 2.构建流程 构建计算环境（决定采用哪种计算执行方式） 创建Source（可以多个数据源） 对数据进行不同方式的转换（提供丰富的算子） 对结果的数据进行Sink（可以输出到多个地方） 六、安装 0.前置 安装java Hadoop scala 1.Flink的下载：：从官网选择对应Flink版本下载 12cd /hadoop/softwarewget http://mirrors.tuna.tsinghua.edu.cn/apache/flink/flink/flink-1.11.1/flink-1.11.1-bin-scala_2.11.tgz 2.解压安装： 123tar -zvxf flink-1.11.1-bin-scala_2.11.tgz -C /hadoop/installcd /hadoop/installmv flink-1.11.1-bin-scala_2.11 flink 3.配置环境变量： 12345vi /etc/profile# 追加内容：export FLINK_HOME=/hadoop/install/flinkexport PATH=$PATH:$FLINK_HOME/bin 4.使环境变量生效 1source /etc/profile 七、部署Flink 有三种部署模式，分别是 Local、Standalone Cluster（ 依赖于 Zookeeper 来实现 JobManager 的 HA ） 和 Yarn Cluster（ 依靠 Yarn 本身来对 JobManager 做 HA ）。 1.Local 模式对于 Local 模式来说，JobManager 和 TaskManager 会公用一个 JVM 来完成 Workload。如果要验证一个简单的应用，Local 模式是最方便的。 1start-local.sh 2.Standalone 模式参考入门教程 1.部署规划 | 节点名称 | master | worker | zookeeper | | ——– | —— | —— | ——— | | master | master | | zookeeper | | node1 | | worker | zookeeper | | node2 | | worker | zookeeper | | node3 | | worker | zookeeper | 2.修改配置文件 12345678910111213141516171819202122cd flink/conf# 1.修改mastersvi masters修改内容如下：master:8081# 2.修改slavesvi slaves修改内容如下：node1node2node3# 3.修改flink-conf.yaml vi flink-conf.yaml 修改内容如下：taskmanager.numberOfTaskSlots：2jobmanager.rpc.address: master 可选配置: 12345每个JobManager（jobmanager.heap.mb）的可用内存量每个TaskManager（taskmanager.heap.mb）的可用内存量每台机器的可用CPU数量（taskmanager.numberOfTaskSlots）集群中的CPU总数（parallelism.default）临时目录（taskmanager.tmp.dirs 3.拷贝安装包到各节点 123scp -r flink/ hadoop@node1:`pwd`scp -r flink/ hadoop@node2:`pwd`scp -r flink/ hadoop@node3:`pwd` 4.启动flink 1start-cluster.sh 5.WebUI查看:访问http://master:8081 注：这里只是集群模式而已，在实际场景中，我们一般需要配置为HA，防止Jobmanager突然挂掉，导致整个集群或者任务执行失败的情况发生。下面介绍一下Standalone HA模式的搭建安装 3.Standalone HA模式依赖于 Zookeeper 来实现 JobManager 的 HA。在 Zookeeper 的帮助下，一个 Standalone 的 Flink 集群会同时有多个活着的 JobManager，其中只有一个处于工作状态，其他处于 Standby 状态。当工作中的 JobManager 失去连接后（如宕机或 Crash），Zookeeper 会从 Standby 中选举新的 JobManager 来接管 Flink 集群。 1.更改conf/flink-conf.yaml配置文件 123456789#jobmanager.rpc.address: masterhigh-availability:zookeeper #指定高可用模式（必须）high-availability.zookeeper.quorum:master:2181,node1:2181,node2:2181,node3:2181 # ZooKeeper仲裁是ZooKeeper服务器的复制组，它提供分布式协调服务（必须）high-availability.storageDir:hdfs:///flink/ha/ #JobManager元数据保存在文件系统storageDir中，只有指向此状态的指针存储在ZooKeeper中（必须）high-availability.zookeeper.path.root:/flink #根ZooKeeper节点，在该节点下放置所有集群节点（推荐） high-availability.cluster-id:/flinkCluster ＃自定义集群（推荐）state.backend: filesystemstate.checkpoints.dir: hdfs:///flink/checkpointsstate.savepoints.dir: hdfs:///flink/checkpoints 2.修改conf/masters 12master:8081node1:8081 3.分发配置文件，将刚刚修改的配置文件 masters 和 flink-conf.yaml 分发至另外三个节点。 4.重启flink集群：start-cluster.sh 4.Yarn ClusterYarn Cluaster 模式来说，Flink 就要依靠 Yarn 本身来对 JobManager 做 HA 了。 在图中可以看出，Flink 与 Yarn 的关系与 MapReduce 和 Yarn 的关系是一样的。Flink 通过 Yarn 的接口实现了自己的 App Master。当在 Yarn 中部署了 Flink，Yarn 就会用自己的 Container 来启动 Flink 的 JobManager（也就是 App Master）和 TaskManager。 启动新的Flink YARN会话时，客户端首先检查所请求的资源（容器和内存）是否可用。之后，它将包含Flink和配置的jar上传到HDFS（步骤1）。 客户端的下一步是请求（步骤2）YARN容器以启动ApplicationMaster（步骤3）。由于客户端将配置和jar文件注册为容器的资源，因此在该特定机器上运行的YARN的NodeManager将负责准备容器（例如，下载文件）。完成后，将启动ApplicationMaster（AM）。 该JobManager和AM在同一容器中运行。一旦它们成功启动，AM就知道JobManager（它自己的主机）的地址。它正在为TaskManagers生成一个新的Flink配置文件（以便它们可以连接到JobManager）。该文件也上传到HDFS。此外，AM容器还提供Flink的Web界面。YARN代码分配的所有端口都是临时端口。这允许用户并行执行多个Flink YARN会话。 之后，AM开始为Flink的TaskManagers分配容器，这将从HDFS下载jar文件和修改后的配置。完成这些步骤后，即可建立Flink并准备接受作业。 1.修改环境变量 1export HADOOP_CONF_DIR=/hadoop/install/hadoop/etc/hadoop 2.部署启动 1yarn-session.sh -d -s 2 -tm 800 -n 2 1234-n : TaskManager的数量，相当于executor的数量-s : 每个JobManager的core的数量，executor-cores。建议将slot的数量设置每台机器的处理器数量-tm : 每个TaskManager的内存大小，executor-memory-jm : JobManager的内存大小，driver-memory 3.Yarn 模式的HA:修改 yarn-site.xml文件（$HADOOP_HOME/etc/hadoop/yarn-site.xml）的 应用最大尝试次数（max-attempts） 12345&lt;property&gt; &lt;name&gt;yarn.resourcemanager.am.max-attempts&lt;/name&gt; &lt;value&gt;4&lt;/value&gt; &lt;description&gt;The maximum number of application master execution attempts&lt;/description&gt;&lt;/property&gt; More info: flink]]></content>
      <tags>
        <tag>大数据</tag>
        <tag>flink</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据（十四）Spark]]></title>
    <url>%2F2020%2F05%2F15%2F%E5%A4%A7%E6%95%B0%E6%8D%AE14%2F</url>
    <content type="text"><![CDATA[Apache Spark 是专为大规模数据处理而设计的快速通用的计算引擎。 本文章主要介绍 Spark 和 在centos环境下如何安装 。 Quick Guide一、Hadoop 和 Spark 的关系 Hadoop有两个核心模块，分布式存储模块HDFS和分布式计算模块Mapreduce spark本身并没有提供分布式文件系统，因此spark的分析大多依赖于Hadoop的分布式文件系统HDFS Hadoop的Mapreduce与spark都可以进行数据计算，而相比于Mapreduce，spark的速度更快并且提供的功能更加丰富 二、 Spark 的特点Spark具有如下几个主要特点： 运行速度快：Spark使用先进的DAG（Directed Acyclic Graph，有向无环图）执行引擎，以支持循环数据流与内存计算，基于内存的执行速度可比Hadoop MapReduce快上百倍，基于磁盘的执行速度也能快十倍； 容易使用：Spark支持使用Scala、Java、Python和R语言进行编程，简洁的API设计有助于用户轻松构建并行程序，并且可以通过Spark Shell进行交互式编程； 通用性：Spark提供了完整而强大的技术栈，包括SQL查询、流式计算、机器学习和图算法组件，这些组件可以无缝整合在同一个应用中，足以应对复杂的计算； 运行模式多样：Spark可运行于独立的集群模式中，或者运行于Hadoop中，也可运行于Amazon EC2等云环境中，并且可以访问HDFS、Cassandra、HBase、Hive等多种数据源。 三、Spark 架构1.Spark生态系统 Spark Core：包含Spark的基本功能，尤其是定义RDD的API、操作以及这两者上的动作。其他Spark的库都是构建在RDD和Spark Core之上的 Spark SQL：提供通过Apache Hive的SQL变体Hive查询语言（HiveQL）与Spark进行交互的API。每个数据库表被当做一个RDD，Spark SQL查询被转换为Spark操作。 Spark Streaming：对实时数据流进行处理和控制。Spark Streaming允许程序能够像普通RDD一样处理实时数据 MLlib：一个常用机器学习算法库，算法被实现为对RDD的Spark操作。这个库包含可扩展的学习算法，比如分类、回归等需要对大量数据集进行迭代的操作。 GraphX：控制图、并行图操作和计算的一组算法和工具的集合。GraphX扩展了RDD API，包含控制图、创建子图、访问路径上所有顶点的操作 2.架构 3.基本概念 Term（术语） Meaning（含义） Cluster manager 一个外部的用于获取集群上资源的服务。（在standalone模式中即为Master主节点，控制整个集群，监控worker;在YARN模式中为资源管理器。 Driver program 该进程运行应用的 main() 方法并且创建了 SparkContext。 RDD 是弹性分布式数据集（Resilient Distributed Dataset）的简称，是分布式内存的一个抽象概念，提供了一种高度受限的共享内存模型 DAG 是Directed Acyclic Graph（有向无环图）的简称，反映RDD之间的依赖关系 Application 用户构建在 Spark 上的程序。由集群上的一个 driver 程序和多个 executor 组成。 Worker node 任何在集群中可以运行应用代码的节点。 Executor 一个为了在 worker 节点上的应用而启动的进程，它运行 task 并且将数据保持在内存中或者硬盘存储。每个应用有它自己的 Executor。 Task 一个将要被发送到 Executor 中的工作单元。 Job 一个由多个任务组成的并行计算，并且能从 Spark action 中获取响应（例如 save，collect）; 您将在 driver 的日志中看到这个术语。 Stage 每个 Job 被拆分成更小的被称作 stage（阶段）的 task（任务）组，stage 彼此之间是相互依赖的（与 MapReduce 中的 map 和 reduce stage 相似）。您将在 driver 的日志中看到这个术语。 在Spark中，一个应用（Application）由一个任务控制节点（Driver）和若干个作业（Job）构成，一个作业由多个阶段（Stage）构成，一个阶段由多个任务（Task）组成。当执行一个应用时，任务控制节点会向集群管理器（Cluster Manager）申请资源，启动Executor，并向Executor发送应用程序代码和文件，然后在Executor上执行任务，运行结束后，执行结果会返回给任务控制节点，或者写到HDFS或者其他数据库中。 4.运行流程 构建Spark Application的运行环境，启动SparkContext SparkContext向资源管理器（可以是Standalone，Mesos，Yarn）申请运行Executor资源，并启动StandaloneExecutorbackend， Executor向SparkContext申请Task SparkContext将应用程序分发给Executor SparkContext构建成DAG图，将DAG图分解成Stage、将Taskset发送给Task Scheduler，最后由Task Scheduler将Task发送给Executor运行 Task在Executor上运行，运行完释放所有资源 四、Spark的部署模式 1.standalone模式与MapReduce1.0框架类似，Spark框架本身也自带了完整的资源调度管理服务，可以独立部署到一个集群中，而不需要依赖其他系统来为其提供资源管理调度服务。在架构的设计上，Spark与MapReduce1.0完全一致，都是由一个Master和若干个Slave构成，并且以槽（slot）作为资源分配单位。不同的是，Spark中的槽不再像MapReduce1.0那样分为Map 槽和Reduce槽，而是只设计了统一的一种槽提供给各种任务来使用。 2.Spark on Mesos模式Mesos是一种资源调度管理框架，可以为运行在它上面的Spark提供服务。Spark on Mesos模式中，Spark程序所需要的各种资源，都由Mesos负责调度。由于Mesos和Spark存在一定的血缘关系，因此，Spark这个框架在进行设计开发的时候，就充分考虑到了对Mesos的充分支持，因此，相对而言，Spark运行在Mesos上，要比运行在YARN上更加灵活、自然。目前，Spark官方推荐采用这种模式，所以，许多公司在实际应用中也采用该模式。 3.Spark on YARN模式Spark可运行于YARN之上，与Hadoop进行统一部署，即“Spark on YARN”，资源管理和调度依赖YARN，分布式存储则依赖HDFS。 五、部署安装0.前置 安装java 安装hadoop 1.安装Scala 0.从官网下载安装包到 /hadoop/software 1.解压到指定文件 12cd /hadoop/softwaretar -zxvf scala-2.11.8.tgz -C /haddop/install 2.修改环境变量 12345vi /etc/profile# 在末尾追加内容export SCALA_HOME=/haddop/install/scala-2.11.8export PATH=$SCALA_HOME/bin:$PATH 3.使环境变量生效 1source /etc/profile 4.检查安装是否成功 1scala -version 2.安装Spark 0.从官网下载安装包到/hadoop/software 1.解压到指定文件 1234cd /hadoop/softwaretar -zxvf spark-2.3.3-bin-hadoop2.7.tgz -C /haddop/installcd /haddop/installmv spark-2.3.3-bin-hadoop2.7 spark 2.修改环境变量 12345vi /etc/profile# 在末尾追加内容export SPARK_HOME=/hadoop/install/sparkexport PATH=$SPARK_HOME/bin:$PATH 3.使环境变量生效 1source /etc/profile 3.设置部署模式 local模式 1spark-shell Standalone模式 1.配置文件slaves.template 123cd /haddop/install/spark/confcp slaves.template slavesvi slaves 添加以下内容 slavexx(看节点数量)： 1234MasterSlave1Slave2Slave3 2.配置spark-env.sh 12cp spark-env.sh.template spark-env.shvi spark-env.sh 添加以下内容 ： 12345678910111213141516171819202122232425262728293031323334353637# JAVA的路径export JAVA_HOME=$&#123;JAVA_HOMRE&#125;# SCALA的路径export SCALA_HOME=$&#123;SCALA_HOME&#125;# HADOOP的路径export HADOOP_CONF_DIR=$&#123;HADOOP_HOME&#125;# master的ip或hostexport SPARK_MASTER_IP=master# 提交任务的端口export SPARK_MASTER_PORT=7077# 浏览器访问master的端口export SPARK_MASTER_WEBUI_PORT=8080# 每个worker从节点能够支配的core的个数export SPARK_WORKER_CORES=2# 每个worker从节点能够支配的内存数export SPARK_WORKER_MEMORY=内存大小#每个workerexport SPARK_WORKER_PORT=7078export SPARK_WORKER_WEBUI_PORT=8081export SPARK_WORKER_INSTANCES=1# 每个worker的数据存放export SPARK_WORKER_DIR=$&#123;SPARK_HOME&#125;/data/tmp# 设定Spark executor的内存大小export SPARK_EXECUTOR_MEMORY=1G# 设定Spark executor 使用的cpu的核的数量export SPARK_EXECUTOR_CORES=1 3.配置修改Spark-defaults.conf 12cp spark-defaults.conf.template spark-defaults.confvi spark-defaults.conf 添加以下内容 ： 123456789101112131415161718# 设置事件日志为truespark.eventlog.enabled=true# 设置记录删除时间spark.history.fs.cleaner.interval=1dspark.history.fs.cleaner.maxAge=7d# 设定事件日志目录spark.eventlog.dir hdfs://nn/user/spark/history# 设定Driver的内存大小spark.driver.memory 1g# 设定历史操作日志操作保存路径spark.history.fs.logDirectory hdfs://nn/usr/spark/history# 设定仓库目录spark.sql.warehouse.dir /user/spark/warehouse Yarn模式:在standalone模式的基础上，在客户端的spark-env.sh文件中配置 1export HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop]]></content>
      <tags>
        <tag>大数据</tag>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据（十三）Sqoop]]></title>
    <url>%2F2020%2F04%2F15%2F%E5%A4%A7%E6%95%B0%E6%8D%AE13%2F</url>
    <content type="text"><![CDATA[传统的应用程序管理系统，即应用程序与使用RDBMS的关系数据库的交互，是产生大数据的来源之一。由RDBMS生成的这种大数据存储在关系数据库结构中的关系数据库服务器中。 当大数据存储和Hadoop生态系统的MapReduce，Hive，HBase，Cassandra，Pig等分析器出现时，他们需要一种工具来与关系数据库服务器进行交互，以导入和导出驻留在其中的大数据。在这里，Sqoop在Hadoop生态系统中占据一席之地，以便在关系数据库服务器和Hadoop的HDFS之间提供可行的交互。 Sqoop(“SQL到Hadoop和Hadoop到SQL):是一个用于在Hadoop和关系数据库服务器之间传输数据的工具。它用于从关系数据库（如MySQL，Oracle）导入数据到Hadoop HDFS，并从Hadoop文件系统导出到关系数据库。它由Apache软件基金会提供。 本文章主要介绍 Sqoop 和 在centos环境下如何安装 。 Quick Guide一、流程 Sqoop导入：导入工具从RDBMS向HDFS导入单独的表。表中的每一行都被视为HDFS中的记录。所有记录都以文本文件的形式存储在文本文件中或作为Avro和Sequence文件中的二进制数据存储。 Sqoop导出：导出工具将一组文件从HDFS导出回RDBMS。给Sqoop输入的文件包含记录，这些记录在表中被称为行。这些被读取并解析成一组记录并用用户指定的分隔符分隔。 二、工作机制将导入或导出命令翻译成 MapReduce 程序来实现 在翻译出的 MapReduce 中主要是对 InputFormat 和 OutputFormat 进行定制 三、Sqoop版本 1.sqoop的版本sqoop1和sqoop2是两个不同的版本，它们是完全不兼容的 2.版本划分方式: apache1.4.X之后的版本是1,1.99.0之上的版本是2 3.Sqoop2相比sqoop1的优势有： 1.它引入的sqoop Server，便于集中化的管理Connector或者其它的第三方插件； 2.多种访问方式：CLI、Web UI、REST API； 3.它引入了基于角色的安全机制，管理员可以在sqoop Server上配置不同的角色。 4.Sqoop2和sqoop1的功能性对比： 1.它引入的sqoop Server，便于集中化的管理Connector或者其它的第三方插件； 2.多种访问方式：CLI、Web UI、REST API； 它引入了基于角色的安全机制，管理员可以在sqoop Server上配置不同的角色。 5.Sqoop2和sqoop1的功能性对比： 6.Sqoop1和Sqoop2的架构区别： 1.Sqoop1的架构图： 12345版本号：1.4.X以后的Sqoop1在架构上：Sqoop1使用Sqoop客户端直接提交代码方式访问方式：CLI命令行控制台方式访问安全性：命令或者脚本指定用户数据库名和密码原理：Sqoop工具接收到客户端的shell命令或者Java api命令后，通过Sqoop中的任务翻译器(Task Translator)将命令转换为对应的MapReduce任务，而后将关系型数据库和Hadoop中的数据进行相互转移，进而完成数据的拷贝 2.Sqoop2架构图： 123版本号：1.99.X以上的版本Sqoop2 在架构上：Sqoop2引入了 Sqoop server,对对connector实现了集中的管理访问方式：REST API、 JAVA API、 WEB UI以及CLI控制台方式进行访问 CLI方式访问，会通过交互过程界面，输入的密码信息会被看到，同时Sqoop2引入基亍角色的安全机制，Sqoop2比Sqoop多了一个Server端。 3.Sqoop1和Sqoop2优缺点： 1234Sqoop1优点：架构部署简单Sqoop1缺点：命令行方式容易出错，格式紧耦合，无法支持所有数据类型，安全机制不够完善，例如密码暴漏，安装需要root权限，connector必须符合JDBC模型Sqoop2优点：多种交互方式，命令行，web UI，rest API，conncetor集中化管理，所有的链接安装在Sqoop server上，完善权限管理机制，connector规范化，仅仅负责数据的读写Sqoop2缺点：Sqoop2的缺点，架构稍复杂，配置部署更繁琐 四、Sqoop1的安装因为绝大部分企业所使用的sqoop的版本都是 Sqoop1，这边介绍 Sqoop1 的安装。 1.前提概述 1.sqoop就是一个工具,只需要在一个节点上进行安装即可。 2.需要跟那个组件打交道，就需要安装的节点上有对应组件。 2.下载 1.从官网下载,选择 sqoop-1.4.7 下载。 3.上传并解压 12cd /hadoop/softwaretar -zxvf sqoop-1.4.7.bin__hadoop-2.6.0.tar.gz -C /hadopp/install/ 4.配置环境变量 123456789cd /home/hadoop/.bashrcvi .bashrc# 将下面两行添加到末尾export SQOOP_HOME=/hadoop/install/sqoop-1.4.7export PATH=$PATH:$SQOOP_HOME/bin# 使环境变量生效. .bashrc 5.修改配置 123cd /hadoop/install/sqoop-1.4.7/conf/mv sqoop-env-template.sh sqoop-env.shvi sqoop-env.sh 修改配置内容12345678910111213export HADOOP_COMMON_HOME=/install/hadoop/hadoop#Set path to where hadoop-*-core.jar is availableexport HADOOP_MAPRED_HOME=/install/hadoop/hadoop#set the path to where bin/hbase is availableexport HBASE_HOME=/hadoop/install/hbase-2.0.5#Set the path to where bin/hive is availableexport HIVE_HOME=/hadoop/install/apache-hive-3.1.2#Set the path for where zookeper config dir isexport ZOOCFGDIR=/hadoop/install/zookeeper-3.4.12/conf 6.增加驱动 1.从mysql官网下载对于版本驱动 2.把驱动放入sqoop1.4.7/lib 目录下1cp /hadoop/software/mysql-connector-java-5.1.38-bin.jar /hadoop/install/sqoop1.4.7/lib/ 7.验证安装是否成功 1sqoop-version 五、Sqoop的基本命令 1.列出MySQL数据有哪些数据库 1sqoop list-databases --connect jdbc:mysql://master:3306/ --username root --password root 2.列出MySQL中的某个数据库有哪些数据表 1sqoop list-tables --connect jdbc:mysql://master:3306/ --username root --password root 3.创建一张跟mysql中的tbl_test表一样的hive表tbl_hive： 1sqoop create-hive-table --connect jdbc:mysql://master:3306/ --username root --password root --table tbl_test --hive-table tbl_hive 4.从RDBMS导入到HDFS中 1sqoop import (generic-args) (import-args) 常用参数1234567891011121314--connect &lt;jdbc-uri&gt; jdbc 连接地址--connection-manager &lt;class-name&gt; 连接管理者--connection-param-file &lt;filename&gt; 可选参数--column-family：列族--driver &lt;class-name&gt; 驱动类--hadoop-mapred-home &lt;dir&gt; $HADOOP_MAPRED_HOME--hbase-table：hbase中的table--hbase-row-key：指定rowkey--help help 信息--password &lt;password&gt; 密码-P 从命令行输入密码--table ：需要sqoop的表--username &lt;username&gt; 账号--verbose 打印流程信息 例子: 导入mysql库中的 tbl_test 的数据到HDFS上 1sqoop import --connect jdbc:mysql://master:3306/ --username root --password root --table tbl_test -m 1 5.把MySQL数据库中的表数据导入到Hive中 1sqoop import --connect jdbc:mysql://master:3306/ --username root --password root --table tbl_test --hive-import -m 1 导入过程: 123第一步：导入mysql.tbl_test的数据到hdfs的默认路径第二步：自动仿造mysql.help_keyword去创建一张hive表, 创建在默认的default库中第三步：把临时目录中的数据导入到hive表中 6.把MySQL数据库中的表数据导入到hbase 12# 需要先创建Hbase里面的表sqoop import --connect jdbc:mysql://master:3306/ --username root --password root --table tbl_test --hbase-table tbl_hbase --column-family person --hbase-row-key tbl_hbase_key]]></content>
      <tags>
        <tag>大数据</tag>
        <tag>sqoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据（十二）Flume]]></title>
    <url>%2F2020%2F03%2F15%2F%E5%A4%A7%E6%95%B0%E6%8D%AE12%2F</url>
    <content type="text"><![CDATA[Flume是一个分布式、可靠、高可用的海量日志聚合系统，支持在系统中定制各类数据发送方，用于收集数据；同时Flume提供对数据的简单处理，并写到各种数据接收方的能力。 本文章主要介绍 Flume 和 在centos环境下如何安装 。 Quick Guide一、背景Hadoop业务的整体开发流程： 从Hadoop的业务开发流程图中可以看出，在大数据的业务处理过程中，对于数据的采集是十分重要的一步，也是不可避免的一步. 许多公司的平台每天会产生大量的日志（一般为流式数据，如搜索引擎的pv和查询等），处理这些日志需要特定的日志系统，一般而言，这些系统需要具有以下特征： 构建应用系统和分析系统的桥梁，并将它们之间的关联解耦； 支持近实时的在线分析系统和类似于Hadoop之类的离线分析系统； 具有高可扩展性。即：当数据量增加时，可以通过增加节点进行水平扩展。 开源的日志系统，包括facebook的scribe，apache的chukwa，linkedin的kafka和cloudera的flume等。 二、Flume的简介 flume 作为 cloudera 开发的实时日志收集系统，受到了业界的认可与广泛应用。Flume 初始的发行版本目前被统称为 Flume OG（original generation），属于 cloudera。 但随着 FLume 功能的扩展，Flume OG 代码工程臃肿、核心组件设计不合理、核心配置不标准等缺点暴露出来，尤其是在 Flume OG 的最后一个发行版本 0.9.4. 中，日志传输不稳定的现象尤为严重，为了解决这些问题，2011 年 10 月 22 号，cloudera 完成了 Flume-728，对 Flume 进行了里程碑式的改动：重构核心组件、核心配置以及代码架构，重构后的版本统称为 Flume NG（next generation）；改动的另一原因是将 Flume 纳入 apache 旗下，cloudera Flume 改名为 Apache Flume。 Flume 在0.9.x and 1.x之间有较大的架构调整，1.x版本之后的改称Flume NG，0.9.x的称为Flume OG。 Flume目前只有Linux系统的启动脚本，没有Windows环境的启动脚本。 三、Flume NG的介绍3.1 flume特点 flume的数据流由事件(Event)贯穿始终。事件是Flume的基本数据单位，它携带日志数据(字节数组形式)并且携带有头信息，这些Event由Agent外部的Source生成，当Source捕获事件后会进行特定的格式化，然后Source会把事件推入(单个或多个)Channel中。你可以把Channel看作是一个缓冲区，它将保存事件直到Sink处理完该事件。Sink负责持久化日志或者把事件推向另一个Source。 （1）flume的可靠性 当节点出现故障时，日志能够被传送到其他节点上而不会丢失。Flume提供了三种级别的可靠性保障，从强到弱依次分别为：end-to-end（收到数据agent首先将event写到磁盘上，当数据传送成功后，再删除；如果数据发送失败，可以重新发送。），Store on failure（这也是scribe采用的策略，当数据接收方crash时，将数据写到本地，待恢复后，继续发送），Besteffort（数据发送到接收方后，不会进行确认）。 （2）flume的可恢复性 依靠Channel，推荐使用FileChannel，事件持久化在本地文件系统里(性能较差)。 3.2 Flume的核心概念 Client：Client生产数据，运行在一个独立的线程。 Event： 一个数据单元，消息头和消息体组成。（Events可以是日志记录、 avro 对象等。） Flow： Event从源点到达目的点的迁移的抽象。 Agent： 一个独立的Flume进程，包含组件Source、 Channel、 Sink。（Agent使用JVM 运行Flume。每台机器运行一个agent，但是可以在一个agent中包含多个sources和sinks。） Source(源端数据采集)： 数据收集组件。（source从Client收集数据，传递给Channel） Channel(临时存储聚合数据)：中转Event的一个临时存储，保存由Source组件传递过来的Event。（Channel连接 sources 和 sinks ，这个有点像一个队列。） Sink（移动数据到目标端）： 从Channel中读取并移除Event， 将Event传递到FlowPipeline中的下一个Agent（如果有的话）（Sink从Channel收集数据，运行在一个独立线程。） 3.3 Flume NG的体系结构Flume 运行的核心是 Agent。Flume以agent为最小的独立运行单位。一个agent就是一个JVM。它是一个完整的数据收集工具，含有三个核心组件，分别是source、 channel、 sink。通过这些组件， Event 可以从一个地方流向另一个地方，如下图所示。 3.4 Source Source是数据的收集端，负责将数据捕获后进行特殊的格式化，将数据封装到事件（event） 里，然后将事件推入Channel中。 Flume提供了各种source的实现，包括Avro Source、Exce Source、Spooling Directory Source、NetCat Source、Syslog Source、Syslog TCP Source、Syslog UDP Source、HTTP Source、HDFS Source，etc。如果内置的Source无法满足需要， Flume还支持自定义Source。 3.5 Channel Channel是连接Source和Sink的组件，大家可以将它看做一个数据的缓冲区（数据队列），它可以将事件暂存到内存中也可以持久化到本地磁盘上， 直到Sink处理完该事件。 Flume对于Channel，则提供了Memory Channel、JDBC Chanel、File Channel，etc。 MemoryChannel可以实现高速的吞吐，但是无法保证数据的完整性。 MemoryRecoverChannel在官方文档的建议上已经建义使用FileChannel来替换。 FileChannel保证数据的完整性与一致性。在具体配置不现的FileChannel时，建议FileChannel设置的目录和程序日志文件保存的目录设成不同的磁盘，以便提高效率。 3.6 Sink Flume Sink取出Channel中的数据，进行相应的存储文件系统，数据库，或者提交到远程服务器。 Flume也提供了各种sink的实现，包括HDFS sink、Logger sink、Avro sink、File Roll sink、Null sink、HBase sink，etc。 Flume Sink在设置存储数据时，可以向文件系统中，数据库中，hadoop中储数据，在日志数据较少时，可以将数据存储在文件系中，并且设定一定的时间间隔保存数据。在日志数据较多时，可以将相应的日志数据存储到Hadoop中，便于日后进行相应的数据分析。 四、Flume的部署类型单一流程： 多代理流程（多个agent顺序连接）： 流的合并（多个Agent的数据汇聚到同一个Agent ）： 多路复用流（多级流）： load balance功能: 五、Flume的安装 0 .从官网下载或者使用下面的命令下载 12cd /hadoop/softwarewget http://mirrors.hust.edu.cn/apache/flume/1.8.0/apache-flume-1.8.0-bin.tar.gz 1.解压并重命名 123tar -zxvf apache-flume-1.8.0-bin.tar.gz -C /hadoop/install/cd /hadoop/installmv apache-flume-1.8.0-bin apache-flume-1.8.0 2.配置环境变量 1vi /etc/profile 添加内容:123export FLUME_HOME=/hadoop/install/apache-flume-1.8.0export FLUME_CONF_DIR=$FLUME_HOME/confexport PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HIVE_HOME/bin:$ZK_HOME/bin:$HBASE_HOME/bin:$FLUME_HOME/bin 3.修改配置文件 3.1.修改flume-env.sh 12345cd /hadoop/install/apache-flume-1.8.0/conf# 拷贝出模板cp flume-env.sh.template flume-env.sh# 修改配置文件vi flume-env.sh 3.2.修改flume-conf 12cp flume-conf.properties.template flume-conf.propertiesvi flume-conf.properties 添加agent、source、channel和sink的相关信息 1234567891011121314151617181920# The configuration file needs to define the sources, the channels and the sinks.# Sources, channels and sinks are defined per agent, in this case called 'a1'a1.sources=r1a1.channels=c1a1.sinks=k1 #Describe/configure the sourcea1.sources.r1.type=netcata1.sources.r1.bind=192.168.52.110a1.sources.r1.port=44444a1.sources.r1.channels=c1#Describe the sinka1.sinks.k1.type=loggera1.sinks.k1.channel=c1 #Describe the channela1.channels.c1.type=memorya1.channels.c1.capacity=1000a1.channels.c1.transcationCapacity=100 配置文件说明： | 配置项名称 | 作用 | 举例 | | ---------------- | ------------------------ | ------------------ | | agent1 | flume节点名称，启动时通过参数命令-name指定 | | | agent1.sources | 监听的源,可以有多个，空格隔开即可，用于收集数据并发送到channel | agent1.sources=s1 s2 | | agent1.channels | 临时通道，可以有多个，空格隔开，存放source收集的数据，sink从这里读取数据 | agent1.channels=c1 | | agent1.sinks | 接收器，可以有多个，空格隔开，从channel读取数据，并发送给目标 （比如kafka 或者hdfs或者另一个flume） | agent1.sinks=k1 | | agent.sources.s1.type | 源的类型，s1是源名称，可以是目录、日志文件、或者监听端口等。 常用的source的类型包括avro、exec、netcat、spooldir和syslog等. 具体请参考官网[http://flume.apache.org/Flume...](http://flume.apache.org/FlumeUserGuide.html#flume-sources) | agent.sources.s1.type=spooldir agent.sources.s2.type=avro | | agent1.sources.s1.channels | 监听数据要写入的channel名称 | agent1.sources.s1.channels=c1 | | agent1.channels.c1.type | 通道的类型，c1为通道名称，此处memory表示为常用的memory-channel， 同时也有其他类型的channel，如JDBC、file-channel、custom-channel等， 具体请参考官网[http://flume.apache.org/Flume...](http://flume.apache.org/FlumeUserGuide.html#flume-channels) | agent1.channels.c1.type=memory | | agent1.sinks.k1.type | 接收器类型，k1为接收器名称，此处logger表示直接写入日志， 常用的包括avro、logger、HDFS、Hbase以及file-roll等， 具体参考官网[http://flume.apache.org/Flume...](http://flume.apache.org/FlumeUserGuide.html#flume-sinks) | agent1.sinks.k1.type=logger | 4.启动 1./bin/flume-ng agent --conf &lt;conf路径&gt; --conf-file &lt;flume-conf.properties路径&gt; --name &lt;agent名称&gt; -Dflume.root.logger=INFO,console 启动命令参数说明： 参数 作用 举例 –conf 或 -c 指定配置文件夹，包含flume-env.sh和log4j的配置文件 –conf conf –conf-file 或 -f 配置文件地址 –conf-file conf/flume.conf –name 或 -n agent(flume节点)名称 –name agent1 123cd /hadoop/install/apache-flume-1.8.0# 启动命令:./bin/flume-ng agent --conf ./conf --conf-file ./conf/flume-conf.properties --name a1 -Dflume.root.logger=INFO,console 5.测试是否运行成功： 1telnet 192.168.52.110 44444 六、测试收集日志到HDFS 1.新建配置2 123cd /hadoop/install/apache-flume-1.8.0/confcp flume-conf.properties.template flume-conf2.propertiesvi flume-conf2.properties 2.配置2内容 123456789101112131415161718192021a1.sources = r1a1.sinks = k1a1.channels = c1a1.sources.r1.type = execa1.sources.r1.channels = c1a1.sources.r1.command = tail -F /hadoop/install/hadoop/logs/hadoop-namenode-b393a04554e1.loga1.sinks.k1.type = hdfsa1.sinks.k1.channel = c1a1.sinks.k1.hdfs.path = hdfs://master:54310/class12/out_flumea1.sinks.k1.hdfs.filePrefix = events-a1.sinks.k1.hdfs.round = truea1.sinks.k1.hdfs.roundValue = 10a1.sinks.k1.hdfs.roundUnit = minutea1.sinks.k1.hdfs.rollSize = 4000000a1.sinks.k1.hdfs.rollCount = 0a1.sinks.k1.hdfs.writeFormat = Texta1.sinks.k1.hdfs.fileType = DataStreama1.sinks.k1.hdfs.batchSize = 10a1.channels.c1.type = memorya1.channels.c1.capacity = 1000a1.channels.c1.transactionCapacity = 100 3.使用配置2启动 123cd /hadoop/install/apache-flume-1.8.0./bin/flume-ng agent --conf ./conf/ --conf-file ./conf/flume-conf2.properties --name a1 -Dflume.root.logger=INFO,console]]></content>
      <tags>
        <tag>大数据</tag>
        <tag>flume</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据（十一）Hbase]]></title>
    <url>%2F2020%2F02%2F15%2F%E5%A4%A7%E6%95%B0%E6%8D%AE11%2F</url>
    <content type="text"><![CDATA[Hbase 是一个分布式的、面向列的开源数据库，该技术来源于 Fay Chang 所撰写的Google论文“Bigtable：一个结构化数据的分布式存储系统”。 就像Bigtable利用了Google文件系统（File System）所提供的分布式数据存储一样，HBase在Hadoop之上提供了类似于Bigtable的能力。 HBase是Apache的Hadoop项目的子项目。HBase不同于一般的关系数据库，它是一个适合于非结构化数据存储的数据库。另一个不同的是HBase基于列的而不是基于行的模式。 本文章主要介绍 Hbase 和 在centos环境下如何安装 。 Quick GuideHbase架构 Zookeeper，作为分布式的协调。RegionServer也会把自己的信息写到ZooKeeper中。 HDFS是Hbase运行的底层文件系统 RegionServer，理解为数据节点，存储数据的。 Master RegionServer要实时的向Master报告信息。Master知道全局的RegionServer运行情况，可以控制RegionServer的故障转移和Region的切分。 Hbase数据模型HBase 是一个稀疏的、分布式、持久、多维、排序的映射，它以行键（row key），列键（column key）和时间戳（timestamp）为索引。有以下特点： Table：Hbase的table由多个行组成 Row：一个行在Hbase中由一个或多个有值的列组成。Row按照字母进行排序，因此行健的设计非常重要。这种设计方式可以让有关系的行非常的近，通常行健的设计是网站的域名反转，比如(org.apache.www, org.apache.mail, org.apache.jira)，这样的话所有的Apache的域名就很接近。 Column：列由列簇加上列的标识组成，一般是“列簇：列标识”，创建表的时候不用指定列标识 Column Family：列簇在物理上包含了许多的列与列的值，每个列簇都有一些存储的属性可配置。例如是否使用缓存，压缩类型，存储版本数等。在表中，每一行都有相同的列簇，尽管有些列簇什么东西也没有存。 Column Qualifier：列簇的限定词，理解为列的唯一标识。但是列标识是可以改变的，因此每一行可能有不同的列标识 Cell：Cell是由row，column family,column qualifier包含时间戳与值组成的，一般表达某个值的版本 Timestamp：时间戳一般写在value的旁边，代表某个值的版本号，默认的时间戳是你写入数据的那一刻，但是你也可以在写入数据的时候指定不同的时间戳 Hbase与关系型数据库对比 属性 Hbase RDBMS 数据类型 只有字符串 丰富的数据类型 数据操作 增删改查，不支持join 各种各样的函数与表连接 存储模式 基于列式存储 基于表结构和行式存储 数据保护 更新后仍然保留旧版本 替换 可伸缩性 轻易增加节点 需要中间层，牺牲性能 Hbase安装部署 0.前置条件 java hadoop zookeeper 1.下载安装包 12cd /hadoop/softwarewget http://mirror.bit.edu.cn/apache/hbase/2.0.5/hbase-2.0.5-bin.tar.gz 2.解压 1tar -zxvf hbase-2.0.5-bin.tar.gz -C /hadoop/install 3.把hadoop的hdfs-site.xml和core-site.xml 放到hbase/conf下 123cd /hadoop/install/hadoop/etc/hadoopcp hdfs-site.xml /hadoop/install/hbase-2.0.5/conf/cp core-site.xml /hadoop/install/hbase-2.0.5/conf/ 4.修改hbase配置文件 1.修改hbase-env.sh 1234567cd /hadoop/install/hbase-2.0.5/conf/vi hbase-env.sh# 配置内容export JAVA_HOME=/hadoop/install/jdk1.8.0_141 export HBASE_MANAGES_ZK=false export HBASE_HEAPSIZE=8G 2.修改hbase-site.xml 12345678910111213141516171819202122232425262728293031323334353637&lt;configuration&gt; &lt;!-- 指定hbase在HDFS上存储的路径 --&gt; &lt;property&gt; &lt;name&gt;hbase.rootdir&lt;/name&gt; &lt;value&gt;hdfs://master:9000/hbase&lt;/value&gt; &lt;/property&gt; &lt;!-- 指定hbase是分布式的 --&gt; &lt;property&gt; &lt;name&gt;hbase.cluster.distributed&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;!-- 指定zk的地址，多个用“,”分割 --&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt; &lt;value&gt;master,node1,node2,node3&lt;/value&gt; &lt;/property&gt; &lt;!-- zookerper日志 --&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt; &lt;value&gt;/hadoop/install/hadoop/zookeeper-3.4.12&lt;/value&gt; &lt;/property&gt; &lt;!-- todo --&gt; &lt;property&gt; &lt;name&gt;hbase.master.port&lt;/name&gt; &lt;value&gt;16000&lt;/value&gt; &lt;/property&gt; &lt;!-- hbase master web界面绑定端口 --&gt; &lt;property&gt; &lt;name&gt;hbase.master.info.port&lt;/name&gt; &lt;value&gt;16010&lt;/value&gt; &lt;/property&gt; &lt;!-- regionserver 信息 web界面接口 --&gt; &lt;property&gt; &lt;name&gt;hbase.regionserver.info.port&lt;/name&gt; &lt;value&gt;16030&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 3.修改regionservers文件，从节点的主机名 1234masternode01node02node03 5.将配置好的HBase拷贝到cd 其他机器里 1234cd /hadoop/installscp -r hbase-2.0.5 node01:/hadoop/install/scp -r hbase-2.0.5 node02:/hadoop/install/scp -r hbase-2.0.5 node03:/hadoop/install/ 6.配置环境变量 1234567891011121314151617cd /home/hadoop/.bashrcvi .bashrc# 将下面两行添加到末尾export HBASE_HOME=/hadoop/install/hbase-2.0.5export PATH=$HBASE_HOME/bin:$PATH# 使环境变量生效. .bashrc# 复制.bashrc文件给其他节点scp -r .bashrc node01:/home/hadoop/scp -r .bashrc node02:/home/hadoop/scp -r .bashrc node03:/home/hadoop/# 其他节点环境变量生效. .bashrc 7.master启动hbase 1start-hbase.sh 8.使用jps查看:都有HRegionServer,master多个HMaster 9.通过网页查看启动是否正常:打开浏览器，访问http://192.168.52.100:16010/，检查hbase是否正常 Hbase基本命令 hbase shell命令 描述 alter 修改列族（column family）模式 count 统计表中行的数量 create 创建表 describe 显示表相关的详细信息 delete 删除指定对象的值（可以为表，行，列对应的值，另外也可以指定时间戳的值） deleteall 删除指定行的所有元素值 disable 使表无效 drop 删除表 enable 使表有效 exists 测试表是否存在 exit 退出hbase shell get 获取行或单元（cell）的值 incr 增加指定表，行或列的值 list 列出hbase中存在的所有表 put 向指向的表单元添加值 tools 列出hbase所支持的工具 scan 通过对表的扫描来获取对用的值 status 返回hbase集群的状态信息 shutdown 关闭hbase集群（与exit不同） truncate 重新创建指定表 version 返回hbase版本信息 1. 进入hbase1./hbase shell 参数说明 进入到hbase目录并进入hbase 2. 浏览所有表1list 参数说明 查看表列表 3. 查看表结构1describe 'BizvaneV2.VipSearch' 参数说明 describe 动作命令，BizvaneV2.VipSearch 为要查看表结构的表名 4. 创建表1create 'UserInfo', &#123; NAME =&gt; 'info', REPLICATION_SCOPE =&gt; '1' &#125; 参数说明 create 动作命令，UserInfo 为要创建的表名 NAME 列族名，info 为列族名称 REPLICATION_SCOPE 是否复制，0为不复制，1为复制 5. 修改表结构123disable 'UserInfo'alter 'UserInfo', &#123;NAME =&gt; 'extendInfo', REPLICATION_SCOPE =&gt; '1'&#125;describe 'UserInfo' 参数说明 修改表结构要使表不启用状态 disable 动作命令,使要修改结构的表无效，UserInfo 为表名 修改命令 alter 动作命令 UserInfo 要修改的表名称 {NAME =&gt; ‘extendInfo’, REPLICATION_SCOPE =&gt; ‘1’} 要修改的结构体 describe 动作命令，查看表结构描述，验证是否修改成功 6. 添加数据1put 'UserInfo','row_1','info:firstname','liu' 参数说明 添加命令 put 动作命令， UserInfo 要添加数据的表名称 row_1 数据行 info:firstname 列及列名字 liu 要添加的值 7. 查看数据1scan 'UserInfo' 参数说明 scan 动作命令 要查看表的名称 8. 修改数据1put 'UserInfo','row_1','info:firstname','liu_copy' 参数说明 添加命令 put 动作命令， UserInfo 要修改数据的表名称 row_1 数据行 info:firstname 列及列名字 liu 新数据值 9. 删除数据1delete 'UserInfo','row_1','info:firstname'参数说明 删除命令 delete 动作命令， UserInfo 要修改数据的表名称 row_1 数据行 info:firstname 列及列名字 10. 删除表12disable 'UserInfo'drop 'UserInfo' 参数说明 修改表结构要使表不启用状态 删除命令 disable 使表不启用，UserInfo 要不启用的表名称 drop 删除命令 UserInfo 要删除的表名称 11. 帮助1help 参数说明 help 帮助命令，可以查看Hbase提供的命令清单 More info: Hbase]]></content>
      <tags>
        <tag>大数据</tag>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据（十）impala]]></title>
    <url>%2F2020%2F01%2F15%2F%E5%A4%A7%E6%95%B0%E6%8D%AE10%2F</url>
    <content type="text"><![CDATA[Impala 是cloudera提供的一款高效率的sql查询工具，提供实时的查询效果，官方测试性能比hive快10到100倍，其sql查询比sparkSQL还要更加快速，号称是当前大数据领域最快的查询sql工具，impala是参照谷歌的新三篇论文（Caffeine、Pregel、Dremel）当中的Dremel实现而来，其中旧三篇论文分别是（BigTable，GFS，MapReduce）分别对应HBase和HDFS以及MapReduce。 本文章主要介绍 Impala 和 在centos环境下如何安装 。 Quick Guideimpala与hive的关系Impala 是基于 hive 的大数据分析查询引擎，直接使用hive的元数据库metadata，意味着impala元数据都存储在hive的metastore当中，并且impala兼容hive的绝大多数sql语法。所以需要安装impala的话，必须先安装hive，保证hive安装成功，并且还需要启动hive的metastore服务。 impala的优点 1.impala比较快，非常快，特别快，因为所有的计算都可以放入内存当中进行完成，只要你内存足够大 2.摈弃了MR的计算，改用C++来实现，有针对性的硬件优化 3.具有数据仓库的特性，对hive的原有数据做数据分析 4.支持ODBC，jdbc远程访问 impala的缺点 1.基于内存计算，对内存依赖性较大 2.改用C++编写，意味着维护难度增大 3.基于hive，与hive共存亡，紧耦合 4.稳定性不如hive，不存在数据丢失的情况 impala的架构 Impala的架构模块： impala-server ==&gt;启动的守护进程，执行我们的查询计划 从节点，官方建议与所有的datanode装在一起，可以通过hadoop的短路读取特性实现数据的快速查询 impala-statestore ==》 状态存储区 主节点 impalas-catalog ==》元数据管理区 主节点 frontend生成查询计划分为两个阶段： 1.生成单机查询计划，单机执行计划与关系数据库执行计划相同，所用查询优化方法也类似。 2.生成分布式查询计划。 根据单机执行计划， 生成真正可执行的分布式执行计划，降低数据移动， 尽量把数据和计算放在一起。 例如：SQL查询， 该SQL的目标是在三表join的基础上算聚集， 并按照聚集列排序取topN。 impala的安装 0.安装规划 服务名称 master node01 node02 node03 impala-catalog 安装 不安装 不安装 不安装 impala-state-store 安装 不安装 不安装 不安装 impala-server 安装 安装 安装 安装 1.前置 已经安装hadoop 已经安装hive 2.可以在页面下载以下RPM包。由于包太多，推荐使用在线yum安装。 3.master执行以下命令进行安装 12345yum install impala -yyum install impala-server -yyum install impala-state-store -yyum install impala-catalog -yyum install impala-shell -y 4.其他节点安装以下服务 1yum install impala-server -y 5.所有节点配置hive-site.xml 1vim /hadoop/install/apache-hive-3.1.2/conf/hive-site.xml 修改内容为： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;&lt;configuration&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt; &lt;value&gt;jdbc:mysql://master:3306/hive?createDatabaseIfNotExist=true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt; &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt; &lt;value&gt;root&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt; &lt;value&gt;123456&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hive.cli.print.current.db&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hive.cli.print.header&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hive.server2.thrift.bind.host&lt;/name&gt; &lt;value&gt;master&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hive.metastore.uris&lt;/name&gt; &lt;value&gt;thrift://master:9083&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hive.metastore.client.socket.timeout&lt;/name&gt; &lt;value&gt;3600&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 5.master机器启动hive的metastore服务 123cd /hadoop/install/apache-hive-3.1.2nohup bin/hive --service metastore &amp;nohup bin/hive -- service hiveserver2 &amp; 6.在master机器使用jps查看，有两个 RunJar 表示启动成功 7.所有hadoop节点修改hdfs-site.xml添加以下内容 1.所有节点创建文件夹，并给予权限 12mkdir -p /var/run/hdfs-socketschown -R hadoop:hadoop /var/run/hdfs-sockets/ - 2.修改所有节点的hdfs-site.xml添加以下配置，修改完之后重启hdfs集群生效 1vim /hadoop/install/hadoop/etc/hadoop/hdfs-site.xml 添加到文件末尾： 12345678910111213141516&lt;property&gt; &lt;name&gt;dfs.client.read.shortcircuit&lt;/name&gt; &lt;value&gt;true&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;dfs.domain.socket.path&lt;/name&gt; &lt;value&gt;/var/run/hdfs-sockets/dn&lt;/value&gt; &lt;!--/var/run/hdfs-socket为目录，dn为文件--&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;dfs.client.file-block-storage-locations.timeout.millis&lt;/name&gt; &lt;value&gt;10000&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;dfs.datanode.hdfs-blocks-metadata.enabled&lt;/name&gt; &lt;value&gt;true&lt;/value&gt;&lt;/property&gt; 8.重启hdfs 123cd /hadoop/install/hadoop/sbin/stop-dfs.shsbin/start-dfs.sh 9.创建hadoop与hive的配置文件的连接 1234# 所有节点 执行以下命令创建链接到impala配置目录下来ln -s /hadoop/install/hadoop/etc/hadoop/core-site.xml /etc/impala/conf/core-site.xmlln -s /hadoop/install/hadoop/etc/hadoop/hdfs-site.xml /etc/impala/conf/hdfs-site.xmlln -s /hadoop/install/apache-hive-3.1.2/conf/hive-site.xml /etc/impala/conf/hive-site.xml 10.修改impala的配置文件 123456789101112# 所有节点更改impala默认配置文件以及添加mysql的连接驱动包vim /etc/default/impalaIMPALA_CATALOG_SERVICE_HOST=masterIMPALA_STATE_STORE_HOST=master# 所有节点创建mysql的驱动包的软连接ln -s /hadoop/install/apache-hive-3.1.2/lib/mysql-connector-java-5.1.38.jar/usr/share/java/mysql-connector-java.jar# 所有节点修改bigtop的java_home路径vim /etc/default/bigtop-utilsexport JAVA_HOME=/hadoop/install/jdk1.8.0_141 11.master节点启动impala服务 123service impala-state-store startservice impala-catalog startservice impala-server start 12.其他节点启动impala-server 1service impala-server start 13.查看impala进程是否存在 1ps -ef | grep impala 14.浏览器页面访问 123访问impalad的管理界面: http://master:25000/访问statestored的管理界面: http://master:25010/访问catalog的管理界面: http://master:25020 注意：启动之后所有关于impala的日志默认都在/var/log/impala 这个路径下 More info: Impala]]></content>
      <tags>
        <tag>大数据</tag>
        <tag>impala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据（九）ZooKeeper]]></title>
    <url>%2F2019%2F12%2F15%2F%E5%A4%A7%E6%95%B0%E6%8D%AE09%2F</url>
    <content type="text"><![CDATA[ZooKeeper 是一个分布式的、开放源码的分布式应用程序协调服务，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。 本文章主要介绍在centos环境下如何安装 ZooKeeper。 Quick Guidezookeeper=文件系统+监听通知机制 1.文件系统 每个子目录项如 NameService 都被称作为 znode(目录节点)，和文件系统一样，我们能够自由的增加、删除znode或者在一个znode下增加和删除子znode，唯一的不同在于znode是可以存储数据的。 2.监听通知机制 客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，zookeeper会通知客户端。 假设我们的程序是分布式部署在多台机器上，如果我们要改变程序的配置文件，需要逐台机器去修改，非常麻烦，现在把这些配置全部放到zookeeper上去，保存在 zookeeper 的某个目录节点中，然后所有相关应用程序对这个目录节点进行监听，一旦配置信息发生变化，每个应用程序就会收到 zookeeper 的通知，然后从 zookeeper 获取新的配置信息应用到系统中。 单机安装 1.配置JAVA环境，检验环境：java -version 2.下载并解压zookeeper 123cd /hadoop/softwarewget http://mirror.bit.edu.cn/apache/zookeeper/stable/zookeeper-3.4.12.tar.gztar -zxvf zookeeper-3.4.12.tar.gz -C /usr/install 3.重命名配置文件zoo_sample.cfg 12cd /hadoop/install/zookeeper-3.4.12cp conf/zoo_sample.cfg conf/zoo.cfg 4.启动zookeeper 1bin/zkServer.sh start 5.测是否成功启动，用zookeeper客户端连接下服务端 1bin/zkCli.sh 命令 1.基本命令 1234567891011# 启动ZK服务: sh bin/zkServer.sh start# 查看ZK服务状态: sh bin/zkServer.sh status# 停止ZK服务: sh bin/zkServer.sh stop# 重启ZK服务: sh bin/zkServer.sh restart 2.使用客户端命令操作zookeeper 12345678910# 查看当前 ZooKeeper 中所包含的内容ls# 创建一个新的 znodecreate /zkPro myData# 获取节点数据和更新信息get /zkPro# 对 zk 所关联的字符串进行设置set /zkPro myData123# 将刚才创建的 znode 删除delete /zkPro 集群模式安装 1.配置JAVA环境，检验环境：java -version 2.下载并解压zookeeper 123cd /hadoop/softwarewget http://mirror.bit.edu.cn/apache/zookeeper/stable/zookeeper-3.4.12.tar.gztar -zxvf zookeeper-3.4.12.tar.gz -C /usr/install 3.重命名配置文件zoo_sample.cfg,并创建目录 zkdatas 123cd /hadoop/install/zookeeper-3.4.12cp conf/zoo_sample.cfg conf/zoo.cfgmkdir zkdatas 4.修改配置文件zoo.cfg，原配置文件里有的，修改成下面的值，没有的则加上 1234567vim conf/zoo.cfgdataDir=/hadoop/install/zookeeper-3.4.12/zkdatasclientPort=2181server.1=master:2887:3887server.2=node1:2888:3888server.3=node2:2889:3889server.4=node3:2890:3890 12345678配置说明tickTime：这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。initLimit：这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 10个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 10*2000=20 秒syncLimit：这个配置项标识 Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 5*2000=10秒dataDir：顾名思义就是 Zookeeper 保存数据的目录，默认情况下，Zookeeper 将写数据的日志文件也保存在这个目录里。clientPort：这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。server.A=B：C：D：其中 A 是一个数字，表示这个是第几号服务器；B 是这个服务器的 ip 地址；C 表示的是这个服务器与集群中的 Leader 服务器交换信息的端口；D 表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。如果是伪集群的配置方式，由于 B 都是一样，所以不同的 Zookeeper 实例通信端口号不能一样，所以要给它们分配不同的端口号。 5.标识Server ID:在目录中创建文件myid 文件，写入当前实例的server id，即1 123cd /hadoop/install/zookeeper-3.4.12/zkdatasvim myid1 6.复制安装目录到其他节点 123scp /hadoop/install/zookeeper-3.4.12 node01:$PWDscp /hadoop/install/zookeeper-3.4.12 node02:$PWDscp /hadoop/install/zookeeper-3.4.12 node03:$PWD 7.修改其他节点的server id为其他数字 1234567891011# 节点1vim myid2# 节点2vim myid3# 节点3vim myid4 8.检测集群状态，也可以直接用命令“zkCli.sh -server IP:PORT”连接zookeeper服务端检测]]></content>
      <tags>
        <tag>大数据</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据（八）hive的开窗函数]]></title>
    <url>%2F2019%2F11%2F15%2F%E5%A4%A7%E6%95%B0%E6%8D%AE08%2F</url>
    <content type="text"><![CDATA[我们使用 hive或者 mysql时，一般聚合函数用的比较多。但对于某些偏分析的需求，group by可能很费力，这个时候就需要使用窗口分析函数。 本文章主要介绍hive的开窗函数和自定义函数。 Quick Guide分析函数用于计算基于组的某种聚合值，它和单纯聚合函数的不同之处是：对于每个组返回多行，而聚合函数对于每个组只返回一行。 开窗函数指定了分析函数工作的数据窗口大小，这个数据窗口大小可能会随着行的变化而变化。 1.基础结构 1分析函数（如:sum(),max(),row_number()...） + 窗口子句（over函数） 2.over函数写法 12# 先根据cookieid字段分区，相同的cookieid分为一区，每个分区内根据createtime字段排序（默认升序）over（partition by cookieid order by createtime） 基础函数基础函数：SUM、AVG、MIN、MAX 用于实现分组内所有和连续累积的统计。 1.测试数据 12345678910111213141516171819202122CREATE EXTERNAL TABLE lxw1234 (cookieid string,createtime string, --day pv INT) ROW FORMAT DELIMITED FIELDS TERMINATED BY &apos;,&apos; stored as textfile location &apos;/tmp/lxw11/&apos;; DESC lxw1234;cookieid STRING createtime STRING pv INT hive&gt; select * from lxw1234;OKcookie1 2015-04-10 1cookie1 2015-04-11 5cookie1 2015-04-12 7cookie1 2015-04-13 3cookie1 2015-04-14 2cookie1 2015-04-15 4cookie1 2015-04-16 4 2.设置开窗的窗口范围 1234567891011121314151617181920SELECT cookieid,createtime,pv,SUM(pv) OVER(PARTITION BY cookieid ORDER BY createtime) AS pv1, -- 默认为从起点到当前行SUM(pv) OVER(PARTITION BY cookieid ORDER BY createtime ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS pv2, --从起点到当前行，结果同pv1 SUM(pv) OVER(PARTITION BY cookieid) AS pv3, --分组内所有行SUM(pv) OVER(PARTITION BY cookieid ORDER BY createtime ROWS BETWEEN 3 PRECEDING AND CURRENT ROW) AS pv4, --当前行+往前3行SUM(pv) OVER(PARTITION BY cookieid ORDER BY createtime ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING) AS pv5, --当前行+往前3行+往后1行SUM(pv) OVER(PARTITION BY cookieid ORDER BY createtime ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS pv6 ---当前行+往后所有行 FROM lxw1234; cookieid createtime pv pv1 pv2 pv3 pv4 pv5 pv6 -----------------------------------------------------------------------------cookie1 2015-04-10 1 1 1 26 1 6 26cookie1 2015-04-11 5 6 6 26 6 13 25cookie1 2015-04-12 7 13 13 26 13 16 20cookie1 2015-04-13 3 16 16 26 16 18 13cookie1 2015-04-14 2 18 18 26 17 21 10cookie1 2015-04-15 4 22 22 26 16 20 8cookie1 2015-04-16 4 26 26 26 13 13 4 结果解析： 123456pv1: 分组内从起点到当前行的pv累积，如，11号的pv1=10号的pv+11号的pv, 12号=10号+11号+12号pv2: 同pv1pv3: 分组内(cookie1)所有的pv累加pv4: 分组内当前行+往前3行，如，11号=10号+11号， 12号=10号+11号+12号， 13号=10号+11号+12号+13号， 14号=11号+12号+13号+14号pv5: 分组内当前行+往前3行+往后1行，如，14号=11号+12号+13号+14号+15号=5+7+3+2+4=21pv6: 分组内当前行+往后所有行，如，13号=13号+14号+15号+16号=3+2+4+4=13，14号=14号+15号+16号=2+4+4=10 ROWS BETWEEN 叫做window子句，如果不指定ROWS BETWEEN,默认统计窗口为从起点到当前行： PRECEDING：往前 FOLLOWING：往后 CURRENT ROW：当前行 UNBOUNDED：无边界，UNBOUNDED PRECEDING 表示从最前面的起点开始， UNBOUNDED – FOLLOWING：表示到最后面的终点 – 3.AVG，MIN，MAX，和SUM用法一样 1234567891011121314151617181920-- AVGSELECT cookieid,createtime,pv,AVG(pv) OVER(PARTITION BY cookieid ORDER BY createtime) AS pv1, -- 默认为从起点到当前行AVG(pv) OVER(PARTITION BY cookieid ORDER BY createtime ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS pv2, --从起点到当前行，结果同pv1 AVG(pv) OVER(PARTITION BY cookieid) AS pv3, --分组内所有行AVG(pv) OVER(PARTITION BY cookieid ORDER BY createtime ROWS BETWEEN 3 PRECEDING AND CURRENT ROW) AS pv4, --当前行+往前3行AVG(pv) OVER(PARTITION BY cookieid ORDER BY createtime ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING) AS pv5, --当前行+往前3行+往后1行AVG(pv) OVER(PARTITION BY cookieid ORDER BY createtime ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS pv6 ---当前行+往后所有行 FROM lxw1234; cookieid createtime pv pv1 pv2 pv3 pv4 pv5 pv6 -----------------------------------------------------------------------------cookie1 2015-04-10 1 1.0 1.0 3.7142857142857144 1.0 3.0 3.7142857142857144cookie1 2015-04-11 5 3.0 3.0 3.7142857142857144 3.0 4.333333333333333 4.166666666666667cookie1 2015-04-12 7 4.333333333333333 4.333333333333333 3.7142857142857144 4.333333333333333 4.0 4.0cookie1 2015-04-13 3 4.0 4.0 3.7142857142857144 4.0 3.6 3.25cookie1 2015-04-14 2 3.6 3.6 3.7142857142857144 4.25 4.2 3.3333333333333335cookie1 2015-04-15 4 3.6666666666666665 3.6666666666666665 3.7142857142857144 4.0 4.0 4.0cookie1 2015-04-16 4 3.7142857142857144 3.7142857142857144 3.7142857142857144 3.25 3.25 4.0 123456789101112131415161718192021-- MINSELECT cookieid,createtime,pv,MIN(pv) OVER(PARTITION BY cookieid ORDER BY createtime) AS pv1, -- 默认为从起点到当前行MIN(pv) OVER(PARTITION BY cookieid ORDER BY createtime ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS pv2, --从起点到当前行，结果同pv1 MIN(pv) OVER(PARTITION BY cookieid) AS pv3, --分组内所有行MIN(pv) OVER(PARTITION BY cookieid ORDER BY createtime ROWS BETWEEN 3 PRECEDING AND CURRENT ROW) AS pv4, --当前行+往前3行MIN(pv) OVER(PARTITION BY cookieid ORDER BY createtime ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING) AS pv5, --当前行+往前3行+往后1行MIN(pv) OVER(PARTITION BY cookieid ORDER BY createtime ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS pv6 ---当前行+往后所有行 FROM lxw1234; cookieid createtime pv pv1 pv2 pv3 pv4 pv5 pv6 -----------------------------------------------------------------------------cookie1 2015-04-10 1 1 1 1 1 1 1cookie1 2015-04-11 5 1 1 1 1 1 2cookie1 2015-04-12 7 1 1 1 1 1 2cookie1 2015-04-13 3 1 1 1 1 1 2cookie1 2015-04-14 2 1 1 1 2 2 2cookie1 2015-04-15 4 1 1 1 2 2 4cookie1 2015-04-16 4 1 1 1 2 2 4 123456789101112131415161718192021-- MAXSELECT cookieid,createtime,pv,MAX(pv) OVER(PARTITION BY cookieid ORDER BY createtime) AS pv1, -- 默认为从起点到当前行MAX(pv) OVER(PARTITION BY cookieid ORDER BY createtime ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS pv2, --从起点到当前行，结果同pv1 MAX(pv) OVER(PARTITION BY cookieid) AS pv3, --分组内所有行MAX(pv) OVER(PARTITION BY cookieid ORDER BY createtime ROWS BETWEEN 3 PRECEDING AND CURRENT ROW) AS pv4, --当前行+往前3行MAX(pv) OVER(PARTITION BY cookieid ORDER BY createtime ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING) AS pv5, --当前行+往前3行+往后1行MAX(pv) OVER(PARTITION BY cookieid ORDER BY createtime ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS pv6 ---当前行+往后所有行 FROM lxw1234; cookieid createtime pv pv1 pv2 pv3 pv4 pv5 pv6 -----------------------------------------------------------------------------cookie1 2015-04-10 1 1 1 7 1 5 7cookie1 2015-04-11 5 5 5 7 5 7 7cookie1 2015-04-12 7 7 7 7 7 7 7cookie1 2015-04-13 3 7 7 7 7 7 4cookie1 2015-04-14 2 7 7 7 7 7 4cookie1 2015-04-15 4 7 7 7 7 7 4cookie1 2015-04-16 4 7 7 7 4 4 4 序列函数序列函数:NTILE、ROW_NUMBER、RANK、DENSE_RANK、CUME_DIST和PERCENT_RANK，不支持WINDOW子句. 1.数据准备 1234567891011121314151617181920212223242526272829303132333435363738394041424344cookie1,2015-04-10,1cookie1,2015-04-11,5cookie1,2015-04-12,7cookie1,2015-04-13,3cookie1,2015-04-14,2cookie1,2015-04-15,4cookie1,2015-04-16,4cookie2,2015-04-10,2cookie2,2015-04-11,3cookie2,2015-04-12,5cookie2,2015-04-13,6cookie2,2015-04-14,3cookie2,2015-04-15,9cookie2,2015-04-16,7 CREATE EXTERNAL TABLE lxw1234 (cookieid string,createtime string, --day pv INT) ROW FORMAT DELIMITED FIELDS TERMINATED BY &apos;,&apos; stored as textfile location &apos;/tmp/lxw11/&apos;; DESC lxw1234;cookieid STRING createtime STRING pv INT hive&gt; select * from lxw1234;OKcookie1 2015-04-10 1cookie1 2015-04-11 5cookie1 2015-04-12 7cookie1 2015-04-13 3cookie1 2015-04-14 2cookie1 2015-04-15 4cookie1 2015-04-16 4cookie2 2015-04-10 2cookie2 2015-04-11 3cookie2 2015-04-12 5cookie2 2015-04-13 6cookie2 2015-04-14 3cookie2 2015-04-15 9cookie2 2015-04-16 7 2.NTILE: NTILE(n)，用于将分组数据按照顺序切分成n片，返回当前切片值 如果切片不均匀，默认增加第一个切片的分布 NTILE不支持ROWS BETWEEN 1234567891011121314151617181920212223242526SELECT cookieid,createtime,pv,NTILE(2) OVER(PARTITION BY cookieid ORDER BY createtime) AS rn1, --分组内将数据分成2片NTILE(3) OVER(PARTITION BY cookieid ORDER BY createtime) AS rn2, --分组内将数据分成3片NTILE(4) OVER(ORDER BY createtime) AS rn3 --将所有数据分成4片FROM lxw1234 ORDER BY cookieid,createtime; cookieid day pv rn1 rn2 rn3-------------------------------------------------cookie1 2015-04-10 1 1 1 1cookie1 2015-04-11 5 1 1 1cookie1 2015-04-12 7 1 1 2cookie1 2015-04-13 3 1 2 2cookie1 2015-04-14 2 2 2 3cookie1 2015-04-15 4 2 3 3cookie1 2015-04-16 4 2 3 4cookie2 2015-04-10 2 1 1 1cookie2 2015-04-11 3 1 1 1cookie2 2015-04-12 5 1 1 2cookie2 2015-04-13 6 1 2 2cookie2 2015-04-14 3 2 2 3cookie2 2015-04-15 9 2 3 4cookie2 2015-04-16 7 2 3 4 3.ROW_NUMBER：从1开始，按照顺序，生成分组内记录的序列 123456789101112131415161718192021222324-- 按照pv降序排列，生成分组内每天的pv名次SELECT cookieid,createtime,pv,ROW_NUMBER() OVER(PARTITION BY cookieid ORDER BY pv desc) AS rn FROM lxw1234; cookieid day pv rn------------------------------------------- cookie1 2015-04-12 7 1cookie1 2015-04-11 5 2cookie1 2015-04-15 4 3cookie1 2015-04-16 4 4cookie1 2015-04-13 3 5cookie1 2015-04-14 2 6cookie1 2015-04-10 1 7cookie2 2015-04-15 9 1cookie2 2015-04-16 7 2cookie2 2015-04-13 6 3cookie2 2015-04-12 5 4cookie2 2015-04-14 3 5cookie2 2015-04-11 3 6cookie2 2015-04-10 2 7 4.RANK 和 DENSE_RANK RANK() :生成数据项在分组中的排名，排名相等会在名次中留下空位 DENSE_RANK() :生成数据项在分组中的排名，排名相等会在名次中不会留下空位 1234567891011121314151617181920212223SELECT cookieid,createtime,pv,RANK() OVER(PARTITION BY cookieid ORDER BY pv desc) AS rn1,DENSE_RANK() OVER(PARTITION BY cookieid ORDER BY pv desc) AS rn2,ROW_NUMBER() OVER(PARTITION BY cookieid ORDER BY pv DESC) AS rn3 FROM lxw1234 WHERE cookieid = &apos;cookie1&apos;; cookieid day pv rn1 rn2 rn3 -------------------------------------------------- cookie1 2015-04-12 7 1 1 1cookie1 2015-04-11 5 2 2 2cookie1 2015-04-15 4 3 3 3cookie1 2015-04-16 4 3 3 4cookie1 2015-04-13 3 5 4 5cookie1 2015-04-14 2 6 5 6cookie1 2015-04-10 1 7 6 7 rn1: 15号和16号并列第3, 13号排第5rn2: 15号和16号并列第3, 13号排第4rn3: 如果相等，则按记录值排序，生成唯一的次序，如果所有记录值都相等，或许会随机排吧。 5.数据准备 12345678910111213141516171819202122d1,user1,1000d1,user2,2000d1,user3,3000d2,user4,4000d2,user5,5000 CREATE EXTERNAL TABLE lxw1234 (dept STRING,userid string,sal INT) ROW FORMAT DELIMITED FIELDS TERMINATED BY &apos;,&apos; stored as textfile location &apos;/tmp/lxw11/&apos;; hive&gt; select * from lxw1234;OKd1 user1 1000d1 user2 2000d1 user3 3000d2 user4 4000d2 user5 5000 6.CUME_DIST: 小于等于当前值的行数/分组内总行数 123456789101112131415161718192021SELECT dept,userid,sal,CUME_DIST() OVER(ORDER BY sal) AS rn1,CUME_DIST() OVER(PARTITION BY dept ORDER BY sal) AS rn2 FROM lxw1234; dept userid sal rn1 rn2 -------------------------------------------d1 user1 1000 0.2 0.3333333333333333d1 user2 2000 0.4 0.6666666666666666d1 user3 3000 0.6 1.0d2 user4 4000 0.8 0.5d2 user5 5000 1.0 1.0 rn1: 没有partition,所有数据均为1组，总行数为5， 第一行：小于等于1000的行数为1，因此，1/5=0.2 第三行：小于等于3000的行数为3，因此，3/5=0.6rn2: 按照部门分组，dpet=d1的行数为3, 第二行：小于等于2000的行数为2，因此，2/3=0.6666666666666666 7.PERCENT_RANK:分组内当前行的RANK值-1/分组内总行数-1 1234567891011121314151617181920212223242526SELECT dept,userid,sal,PERCENT_RANK() OVER(ORDER BY sal) AS rn1, --分组内RANK() OVER(ORDER BY sal) AS rn11, --分组内RANK值SUM(1) OVER(PARTITION BY NULL) AS rn12, --分组内总行数PERCENT_RANK() OVER(PARTITION BY dept ORDER BY sal) AS rn2 FROM lxw1234; dept userid sal rn1 rn11 rn12 rn2---------------------------------------------------d1 user1 1000 0.0 1 5 0.0d1 user2 2000 0.25 2 5 0.5d1 user3 3000 0.5 3 5 1.0d2 user4 4000 0.75 4 5 0.0d2 user5 5000 1.0 5 5 1.0 rn1: rn1 = (rn11-1) / (rn12-1) 第一行,(1-1)/(5-1)=0/4=0 第二行,(2-1)/(5-1)=1/4=0.25 第四行,(4-1)/(5-1)=3/4=0.75rn2: 按照dept分组， dept=d1的总行数为3 第一行，(1-1)/(3-1)=0 第三行，(3-1)/(3-1)=1 位置函数位置函数:LAG 、LEAD、FIRST_VALUE和LAST_VALUE,不支持WINDOW子句 1.数据准备 12345678910111213141516171819202122232425262728293031323334353637383940cookie1,2015-04-10 10:00:02,url2cookie1,2015-04-10 10:00:00,url1cookie1,2015-04-10 10:03:04,1url3cookie1,2015-04-10 10:50:05,url6cookie1,2015-04-10 11:00:00,url7cookie1,2015-04-10 10:10:00,url4cookie1,2015-04-10 10:50:01,url5cookie2,2015-04-10 10:00:02,url22cookie2,2015-04-10 10:00:00,url11cookie2,2015-04-10 10:03:04,1url33cookie2,2015-04-10 10:50:05,url66cookie2,2015-04-10 11:00:00,url77cookie2,2015-04-10 10:10:00,url44cookie2,2015-04-10 10:50:01,url55 CREATE EXTERNAL TABLE lxw1234 (cookieid string,createtime string, --页面访问时间url STRING --被访问页面) ROW FORMAT DELIMITED FIELDS TERMINATED BY &apos;,&apos; stored as textfile location &apos;/tmp/lxw11/&apos;; hive&gt; select * from lxw1234;OKcookie1 2015-04-10 10:00:02 url2cookie1 2015-04-10 10:00:00 url1cookie1 2015-04-10 10:03:04 1url3cookie1 2015-04-10 10:50:05 url6cookie1 2015-04-10 11:00:00 url7cookie1 2015-04-10 10:10:00 url4cookie1 2015-04-10 10:50:01 url5cookie2 2015-04-10 10:00:02 url22cookie2 2015-04-10 10:00:00 url11cookie2 2015-04-10 10:03:04 1url33cookie2 2015-04-10 10:50:05 url66cookie2 2015-04-10 11:00:00 url77cookie2 2015-04-10 10:10:00 url44cookie2 2015-04-10 10:50:01 url55 2.LAG:LAG(col,n,DEFAULT) 用于统计窗口内往上第n行值 第一个参数为列名 第二个参数为往上第n行（可选，默认为1） 第三个参数为默认值（当往上第n行为NULL时候，取默认值，如不指定，则为NULL） 123456789101112131415161718192021222324252627282930313233343536SELECT cookieid,createtime,url,ROW_NUMBER() OVER(PARTITION BY cookieid ORDER BY createtime) AS rn,LAG(createtime,1,&apos;1970-01-01 00:00:00&apos;) OVER(PARTITION BY cookieid ORDER BY createtime) AS last_1_time,LAG(createtime,2) OVER(PARTITION BY cookieid ORDER BY createtime) AS last_2_time FROM lxw1234; cookieid createtime url rn last_1_time last_2_time-------------------------------------------------------------------------------------------cookie1 2015-04-10 10:00:00 url1 1 1970-01-01 00:00:00 NULLcookie1 2015-04-10 10:00:02 url2 2 2015-04-10 10:00:00 NULLcookie1 2015-04-10 10:03:04 1url3 3 2015-04-10 10:00:02 2015-04-10 10:00:00cookie1 2015-04-10 10:10:00 url4 4 2015-04-10 10:03:04 2015-04-10 10:00:02cookie1 2015-04-10 10:50:01 url5 5 2015-04-10 10:10:00 2015-04-10 10:03:04cookie1 2015-04-10 10:50:05 url6 6 2015-04-10 10:50:01 2015-04-10 10:10:00cookie1 2015-04-10 11:00:00 url7 7 2015-04-10 10:50:05 2015-04-10 10:50:01cookie2 2015-04-10 10:00:00 url11 1 1970-01-01 00:00:00 NULLcookie2 2015-04-10 10:00:02 url22 2 2015-04-10 10:00:00 NULLcookie2 2015-04-10 10:03:04 1url33 3 2015-04-10 10:00:02 2015-04-10 10:00:00cookie2 2015-04-10 10:10:00 url44 4 2015-04-10 10:03:04 2015-04-10 10:00:02cookie2 2015-04-10 10:50:01 url55 5 2015-04-10 10:10:00 2015-04-10 10:03:04cookie2 2015-04-10 10:50:05 url66 6 2015-04-10 10:50:01 2015-04-10 10:10:00cookie2 2015-04-10 11:00:00 url77 7 2015-04-10 10:50:05 2015-04-10 10:50:01 last_1_time: 指定了往上第1行的值，default为&apos;1970-01-01 00:00:00&apos; cookie1第一行，往上1行为NULL,因此取默认值 1970-01-01 00:00:00 cookie1第三行，往上1行值为第二行值，2015-04-10 10:00:02 cookie1第六行，往上1行值为第五行值，2015-04-10 10:50:01last_2_time: 指定了往上第2行的值，为指定默认值 cookie1第一行，往上2行为NULL cookie1第二行，往上2行为NULL cookie1第四行，往上2行为第二行值，2015-04-10 10:00:02 cookie1第七行，往上2行为第五行值，2015-04-10 10:50:01 3.LEAD:LEAD(col,n,DEFAULT) 用于统计窗口内往下第n行值 第一个参数为列名 第二个参数为往下第n行（可选，默认为1） 第三个参数为默认值（当往下第n行为NULL时候，取默认值，如不指定，则为NULL） 123456789101112131415161718192021222324252627SELECT cookieid,createtime,url,ROW_NUMBER() OVER(PARTITION BY cookieid ORDER BY createtime) AS rn,LEAD(createtime,1,&apos;1970-01-01 00:00:00&apos;) OVER(PARTITION BY cookieid ORDER BY createtime) AS next_1_time,LEAD(createtime,2) OVER(PARTITION BY cookieid ORDER BY createtime) AS next_2_time FROM lxw1234; cookieid createtime url rn next_1_time next_2_time -------------------------------------------------------------------------------------------cookie1 2015-04-10 10:00:00 url1 1 2015-04-10 10:00:02 2015-04-10 10:03:04cookie1 2015-04-10 10:00:02 url2 2 2015-04-10 10:03:04 2015-04-10 10:10:00cookie1 2015-04-10 10:03:04 1url3 3 2015-04-10 10:10:00 2015-04-10 10:50:01cookie1 2015-04-10 10:10:00 url4 4 2015-04-10 10:50:01 2015-04-10 10:50:05cookie1 2015-04-10 10:50:01 url5 5 2015-04-10 10:50:05 2015-04-10 11:00:00cookie1 2015-04-10 10:50:05 url6 6 2015-04-10 11:00:00 NULLcookie1 2015-04-10 11:00:00 url7 7 1970-01-01 00:00:00 NULLcookie2 2015-04-10 10:00:00 url11 1 2015-04-10 10:00:02 2015-04-10 10:03:04cookie2 2015-04-10 10:00:02 url22 2 2015-04-10 10:03:04 2015-04-10 10:10:00cookie2 2015-04-10 10:03:04 1url33 3 2015-04-10 10:10:00 2015-04-10 10:50:01cookie2 2015-04-10 10:10:00 url44 4 2015-04-10 10:50:01 2015-04-10 10:50:05cookie2 2015-04-10 10:50:01 url55 5 2015-04-10 10:50:05 2015-04-10 11:00:00cookie2 2015-04-10 10:50:05 url66 6 2015-04-10 11:00:00 NULLcookie2 2015-04-10 11:00:00 url77 7 1970-01-01 00:00:00 NULL --逻辑与LAG一样，只不过LAG是往上，LEAD是往下。 4.FIRST_VALUE:取分组内排序后，截止到当前行，第一个值 1234567891011121314151617181920212223SELECT cookieid,createtime,url,ROW_NUMBER() OVER(PARTITION BY cookieid ORDER BY createtime) AS rn,FIRST_VALUE(url) OVER(PARTITION BY cookieid ORDER BY createtime) AS first1 FROM lxw1234; cookieid createtime url rn first1---------------------------------------------------------cookie1 2015-04-10 10:00:00 url1 1 url1cookie1 2015-04-10 10:00:02 url2 2 url1cookie1 2015-04-10 10:03:04 1url3 3 url1cookie1 2015-04-10 10:10:00 url4 4 url1cookie1 2015-04-10 10:50:01 url5 5 url1cookie1 2015-04-10 10:50:05 url6 6 url1cookie1 2015-04-10 11:00:00 url7 7 url1cookie2 2015-04-10 10:00:00 url11 1 url11cookie2 2015-04-10 10:00:02 url22 2 url11cookie2 2015-04-10 10:03:04 1url33 3 url11cookie2 2015-04-10 10:10:00 url44 4 url11cookie2 2015-04-10 10:50:01 url55 5 url11cookie2 2015-04-10 10:50:05 url66 6 url11cookie2 2015-04-10 11:00:00 url77 7 url11 5.LAST_VALUE:取分组内排序后，截止到当前行，最后一个值 1234567891011121314151617181920212223SELECT cookieid,createtime,url,ROW_NUMBER() OVER(PARTITION BY cookieid ORDER BY createtime) AS rn,LAST_VALUE(url) OVER(PARTITION BY cookieid ORDER BY createtime) AS last1 FROM lxw1234; cookieid createtime url rn last1 -----------------------------------------------------------------cookie1 2015-04-10 10:00:00 url1 1 url1cookie1 2015-04-10 10:00:02 url2 2 url2cookie1 2015-04-10 10:03:04 1url3 3 1url3cookie1 2015-04-10 10:10:00 url4 4 url4cookie1 2015-04-10 10:50:01 url5 5 url5cookie1 2015-04-10 10:50:05 url6 6 url6cookie1 2015-04-10 11:00:00 url7 7 url7cookie2 2015-04-10 10:00:00 url11 1 url11cookie2 2015-04-10 10:00:02 url22 2 url22cookie2 2015-04-10 10:03:04 1url33 3 1url33cookie2 2015-04-10 10:10:00 url44 4 url44cookie2 2015-04-10 10:50:01 url55 5 url55cookie2 2015-04-10 10:50:05 url66 6 url66 聚合函数聚合函数：GROUPING SETS、CUBE和ROLLUP 1.数据准备 123456789101112131415161718192021222324252627282930313233343536373839402015-03,2015-03-10,cookie12015-03,2015-03-10,cookie52015-03,2015-03-12,cookie72015-04,2015-04-12,cookie32015-04,2015-04-13,cookie22015-04,2015-04-13,cookie42015-04,2015-04-16,cookie42015-03,2015-03-10,cookie22015-03,2015-03-10,cookie32015-04,2015-04-12,cookie52015-04,2015-04-13,cookie62015-04,2015-04-15,cookie32015-04,2015-04-15,cookie22015-04,2015-04-16,cookie1 CREATE EXTERNAL TABLE lxw1234 (month STRING,day STRING, cookieid STRING ) ROW FORMAT DELIMITED FIELDS TERMINATED BY &apos;,&apos; stored as textfile location &apos;/tmp/lxw11/&apos;; hive&gt; select * from lxw1234;OK2015-03 2015-03-10 cookie12015-03 2015-03-10 cookie52015-03 2015-03-12 cookie72015-04 2015-04-12 cookie32015-04 2015-04-13 cookie22015-04 2015-04-13 cookie42015-04 2015-04-16 cookie42015-03 2015-03-10 cookie22015-03 2015-03-10 cookie32015-04 2015-04-12 cookie52015-04 2015-04-13 cookie62015-04 2015-04-15 cookie32015-04 2015-04-15 cookie22015-04 2015-04-16 cookie1 2.GROUPING SETS:在一个GROUP BY查询中，根据不同的维度组合进行聚合，等价于将不同维度的GROUP BY结果集进行UNION ALL 1234567891011121314151617181920212223242526SELECT month,day,COUNT(DISTINCT cookieid) AS uv,GROUPING__ID FROM lxw1234 GROUP BY month,day GROUPING SETS (month,day) ORDER BY GROUPING__ID; month day uv GROUPING__ID------------------------------------------------2015-03 NULL 5 12015-04 NULL 6 1NULL 2015-03-10 4 2NULL 2015-03-12 1 2NULL 2015-04-12 2 2NULL 2015-04-13 3 2NULL 2015-04-15 2 2NULL 2015-04-16 2 2 等价于 SELECT month,NULL,COUNT(DISTINCT cookieid) AS uv,1 AS GROUPING__ID FROM lxw1234 GROUP BY month UNION ALL SELECT NULL,day,COUNT(DISTINCT cookieid) AS uv,2 AS GROUPING__ID FROM lxw1234 GROUP BY day 注：GROUPING__ID，表示结果属于哪一个分组集合。 3.CUBE:根据GROUP BY的维度的所有组合进行聚合 123456789101112131415161718192021222324252627282930313233343536373839SELECT month,day,COUNT(DISTINCT cookieid) AS uv,GROUPING__ID FROM lxw1234 GROUP BY month,day WITH CUBE ORDER BY GROUPING__ID; month day uv GROUPING__ID--------------------------------------------NULL NULL 7 02015-03 NULL 5 12015-04 NULL 6 1NULL 2015-04-12 2 2NULL 2015-04-13 3 2NULL 2015-04-15 2 2NULL 2015-04-16 2 2NULL 2015-03-10 4 2NULL 2015-03-12 1 22015-03 2015-03-10 4 32015-03 2015-03-12 1 32015-04 2015-04-16 2 32015-04 2015-04-12 2 32015-04 2015-04-13 3 32015-04 2015-04-15 2 3 等价于SELECT NULL,NULL,COUNT(DISTINCT cookieid) AS uv,0 AS GROUPING__ID FROM lxw1234UNION ALL SELECT month,NULL,COUNT(DISTINCT cookieid) AS uv,1 AS GROUPING__ID FROM lxw1234 GROUP BY month UNION ALL SELECT NULL,day,COUNT(DISTINCT cookieid) AS uv,2 AS GROUPING__ID FROM lxw1234 GROUP BY dayUNION ALL SELECT month,day,COUNT(DISTINCT cookieid) AS uv,3 AS GROUPING__ID FROM lxw1234 GROUP BY month,day 4.ROLLUP:是CUBE的子集，以最左侧的维度为主，从该维度进行层级聚合。 12345678910111213141516171819202122232425-- 以month维度进行层级聚合：SELECT month,day,COUNT(DISTINCT cookieid) AS uv,GROUPING__ID FROM lxw1234 GROUP BY month,dayWITH ROLLUP ORDER BY GROUPING__ID; month day uv GROUPING__ID---------------------------------------------------NULL NULL 7 02015-03 NULL 5 12015-04 NULL 6 12015-03 2015-03-10 4 32015-03 2015-03-12 1 32015-04 2015-04-12 2 32015-04 2015-04-13 3 32015-04 2015-04-15 2 32015-04 2015-04-16 2 3 可以实现这样的上钻过程：月天的UV-&gt;月的UV-&gt;总UV 自定义函数 1.创建文件set_message.sql 2.在文件中定位存储过程 12345-- 创建一个存储过程set_message，它接受一个STRING类型的IN参数，输出一个STRING类型的OUT参数。CREATE PROCEDURE set_message(IN name STRING, OUT result STRING)BEGIN SET result = &apos;Hello, &apos; || name || &apos;!&apos;;END; 3.自定义函数 1234INCLUDE /home/hadoop/set_message.sqlDECLARE str STRING;CALL set_message(&apos;hadoop&apos;, str);PRINT str;]]></content>
      <tags>
        <tag>大数据</tag>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据（七）Hive的部署]]></title>
    <url>%2F2019%2F10%2F15%2F%E5%A4%A7%E6%95%B0%E6%8D%AE07%2F</url>
    <content type="text"><![CDATA[Hive是构建在Hadoop HDFS上的一个数据仓库，可以将结构化的数据文件映射为一张数据库表（Hive的表其实就是HDFS的目录/文件），并提供类SQL查询功能，其本质是将SQL转换为MapReduce程序。 本文章主要介绍在centos环境下如何安装Hive。 Quick GuideHive的底层运算是MapReduce计算框架，Hive只是将可读性强，容易编程的SQL语句通过Hive软件转换成MR程序在集群上执行。hive可以看做mapreduce客户端，能用mapreduce程序完成的任务基本都可以对应的替换成hql（Hive SQL）编写的hive任务。Hive最大的限制特点就是不支持基于行记录的更新，删除，增加。但是用户可以通过查询生成新表，或者将查询结果导入文件中来“实现”hive基于行记录的操作。 一.安装1.安装前准备 1.安装MySQL并创建hive数据库：数据库主要是存放hive的数据源路径和数据元信息，可以安装，也可以使用内置数据库 Derby。 2.安装JDK和Hadoop：详细安装见 大数据（六） 2.hive安装步骤 1.下载hive版本包： 根据hadoop版本选择对应版本包下载，如hive-2.x与hadoop-2.x匹配，hive-3.x与hadoop-3.x匹配 2.解压并配置Hive 12tar -zxvf apache-hive-3.1.2-bin.tar.gz -C /hadoop/installmv apache-hive-3.1.2-bin/ apache-hive-3.1.2/ 3.修改配置文件 12345# 复制一个"hive-default.xml.template",命名为hive-default.xmlcd /hadoop/install/apache-hive-3.1.2/conf/cp hive-log4j2.properties.template hive-log4j2.properties# 创建hive-site.xml，并填入内容vi hive-site.xml hive-site.xml 的内容： 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;&lt;configuration&gt; &lt;!-- ########################### hive的 JDBC连接 ############################ --&gt; &lt;!-- mysql 连接用户名 --&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt; &lt;value&gt;UserName&lt;/value&gt; &lt;/property&gt; &lt;!-- mysql 连接密码 --&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt; &lt;value&gt;Password!&lt;/value&gt; &lt;/property&gt; &lt;!-- mysql 连接URL 如果hive和mysql在同一服务器上，使用localhost --&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt; &lt;value&gt;jdbc:mysql://localhost:3306/myhive&lt;/value&gt; &lt;/property&gt; &lt;!-- mysql 连接驱动 --&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt; &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 4.添加驱动包 1.下载mysql驱动jar包 2.上传jar包到 hive的安装目录下 的lib目录 5.初始化元数据库 12cd /hadoop/install/apache-hive-3.1.2/bin/schematool -dbType mysql -initSchema 6.配置hive环境变量 12# 打开profile文件vim /etc/profile 末尾添加如下内容：12export HIVE_HOME=/hadoop/install/apache-hive-3.1.2export PATH=$PATH:$HIVE_HOME/bin 12# 环境变量生效source /etc/profile 7.启动hive 1hive 8.测试 12345678910111213hive&gt; create database test; # 创建test数据库OKTime taken: 0.069 secondshive&gt; use test; # 进入test数据库OKTime taken: 0.068 secondshive&gt; create table tbl_test(id int); # 创建表 ttOKTime taken: 1.886 secondshive&gt; show tables; # 查看test库中所有的表OKtbl_testTime taken: 0.093 seconds, Fetched: 1 row(s) 二.常用命令hiveql的命令大部分跟SQL一样,下面列一下差异点： 123456789101112131415161718192021# 1 select distinct 后必须指定字段名# 2 join 条件仅支持等值关联且不支持or条件# 3 子查询不能在select中使用；# 4 HQL中没有UNION，可使用distinct+ union all 实现 UNION；# 5 HQL以分号分隔，必须在每个语句结尾写上分号；# 6 HQL中字符串的比较比较严格，区分大小写及空格，因此在比较时建议upper(trim(a))=upper(trim(b))# 7 日期判断，建议使用to_date(),如：to_date(orderdate)=‘2016-07-18’# 8 关键字必须在字段名上加``符号，如select `exchange` from xxdb.xxtb;# 9 数据库和表/视图之间仅有1个点，如xx_db.xx_tb;# HQL不支持update/delete# 实际采用union all + left join (is null)变相实现update# 思路：# 1 取出增量数据；# 2 使用昨日分区的全量数据通过主键左连接增量数据，并且只取增量表中主键为空的数据（即，取未发生变化的全量数据）；# 3 合并1、2的数据覆盖至最新的分区，即实现了update；# HQL delete实现# 采用not exists/left join(is null)的方法变相实现。# 1.取出已删除的主键数据（表B）；# 2.使用上一个分区的全量数据（表A）通过主键左连接A，并且只取A中主键为空的数据，然后直接insert overwrite至新的分区； 1.基础命令1234567891011121314151617181920212223242526272829303132333435# 查看某个数据库show databases; use 数据库; # 进入某个数据库show tables; # 展示所有表desc 表名; # 显示表结构show partitions 表名; # 显示表名的分区show create table_name; # 显示创建表的结构# 建表语句# 内部表use xxdb; create table xxx;# 创建一个表，结构与其他一样create table xxx like xxx;# 外部表use xxdb; create external table xxx;# 分区表use xxdb; create external table xxx (l int) partitoned by (d string)# 内外部表转化alter table table_name set TBLPROPROTIES (&apos;EXTERNAL&apos;=&apos;TRUE&apos;); # 内部表转外部表alter table table_name set TBLPROPROTIES (&apos;EXTERNAL&apos;=&apos;FALSE&apos;);# 外部表转内部表# 表结构修改# 重命名表use xxxdb; alter table table_name rename to new_table_name;# 增加字段alter table table_name add columns (newcol1 int comment ‘新增’)；# 修改字段alter table table_name change col_name new_col_name new_type；# 删除字段(COLUMNS中只放保留的字段)alter table table_name replace columns (col1 int,col2 string,col3 string)；# 删除表use xxxdb; drop table table_name;# 删除分区# 注意：若是外部表，则还需要删除文件(hadoop fs -rm -r -f hdfspath)alter table table_name drop if exists partitions (d=‘2016-07-01&apos;); 2.常用函数2.1 数学函数 Name (Signature) Description Return Type round(DOUBLE a) Returns the rounded BIGINT value of a.返回对a四舍五入的BIGINT值 DOUBLE round(DOUBLE a, INT d) Returns a rounded to d decimal places.返回DOUBLE型d的保留n位小数的DOUBLW型的近似值 DOUBLE bround(DOUBLE a) Returns the rounded BIGINT value of a using HALF_EVEN rounding mode (as of Hive 1.3.0, 2.0.0). Also known as Gaussian rounding or bankers’ rounding. Example: bround(2.5) = 2, bround(3.5) = 4. 银行家舍入法（1~4：舍，6~9：进，5-&gt;前位数是偶：舍，5-&gt;前位数是奇：进） DOUBLE bround(DOUBLE a, INT d) Returns a rounded to d decimal places using HALF_EVEN rounding mode (as of Hive 1.3.0, 2.0.0). Example: bround(8.25, 1) = 8.2, bround(8.35, 1) = 8.4. 银行家舍入法,保留d位小数 DOUBLE floor(DOUBLE a) Returns the maximum BIGINT value that is equal to or less than a向下取整，最数轴上最接近要求的值的左边的值 如：6.10-&gt;6 -3.4-&gt;-4 BIGINT ceil(DOUBLE a), ceiling(DOUBLE a) Returns the minimum BIGINT value that is equal to or greater than a.求其不小于小给定实数的最小整数如：ceil(6) = ceil(6.1)= ceil(6.9) = 6 BIGINT rand(), rand(INT seed) Returns a random number (that changes from row to row) that is distributed uniformly from 0 to 1. Specifying the seed will make sure the generated random number sequence is deterministic.每行返回一个DOUBLE型随机数seed是随机因子 DOUBLE exp(DOUBLE a), exp(DECIMAL a) Returns ea where e is the base of the natural logarithm. Decimal version added in Hive 0.13.0.返回e的a幂次方， a可为小数 DOUBLE ln(DOUBLE a), ln(DECIMAL a) Returns the natural logarithm of the argument a. Decimal version added in Hive 0.13.0.以自然数为底d的对数，a可为小数 DOUBLE log10(DOUBLE a), log10(DECIMAL a) Returns the base-10 logarithm of the argument a. Decimal version added in Hive 0.13.0.以10为底d的对数，a可为小数 DOUBLE log2(DOUBLE a), log2(DECIMAL a) Returns the base-2 logarithm of the argument a. Decimal version added in Hive 0.13.0.以2为底数d的对数，a可为小数 DOUBLE log(DOUBLE base, DOUBLE a)log(DECIMAL base, DECIMAL a) Returns the base-base logarithm of the argument a. Decimal versions added in Hive 0.13.0.以base为底的对数，base 与 a都是DOUBLE类型 DOUBLE pow(DOUBLE a, DOUBLE p), power(DOUBLE a, DOUBLE p) Returns ap.计算a的p次幂 DOUBLE sqrt(DOUBLE a), sqrt(DECIMAL a) Returns the square root of a. Decimal version added in Hive 0.13.0.计算a的平方根 DOUBLE bin(BIGINT a) Returns the number in binary format (see http://dev.mysql.com/doc/refman/5.0/en/string-functions.html#function_bin).计算二进制a的STRING类型，a为BIGINT类型 STRING hex(BIGINT a) hex(STRING a) hex(BINARY a) If the argument is an INT or binary, hex returns the number as a STRING in hexadecimal format. Otherwise if the number is a STRING, it converts each character into its hexadecimal representation and returns the resulting STRING. (Seehttp://dev.mysql.com/doc/refman/5.0/en/string-functions.html#function_hex, BINARY version as of Hive 0.12.0.)计算十六进制a的STRING类型，如果a为STRING类型就转换成字符相对应的十六进制 STRING unhex(STRING a) Inverse of hex. Interprets each pair of characters as a hexadecimal number and converts to the byte representation of the number. (BINARY version as of Hive 0.12.0, used to return a string.)hex的逆方法 BINARY conv(BIGINT num, INT from_base, INT to_base), conv(STRING num, INT from_base, INT to_base) Converts a number from a given base to another (see http://dev.mysql.com/doc/refman/5.0/en/mathematical-functions.html#function_conv).将GIGINT/STRING类型的num从from_base进制转换成to_base进制 STRING abs(DOUBLE a) Returns the absolute value.计算a的绝对值 DOUBLE pmod(INT a, INT b), pmod(DOUBLE a, DOUBLE b) Returns the positive value of a mod b.a对b取模 INT or DOUBLE sin(DOUBLE a), sin(DECIMAL a) Returns the sine of a (a is in radians). Decimal version added in Hive 0.13.0.求a的正弦值 DOUBLE asin(DOUBLE a), asin(DECIMAL a) Returns the arc sin of a if -1&lt;=a&lt;=1 or NULL otherwise. Decimal version added in Hive 0.13.0.求d的反正弦值 DOUBLE cos(DOUBLE a), cos(DECIMAL a) Returns the cosine of a (a is in radians). Decimal version added in Hive 0.13.0.求余弦值 DOUBLE acos(DOUBLE a), acos(DECIMAL a) Returns the arccosine of a if -1&lt;=a&lt;=1 or NULL otherwise. Decimal version added in Hive 0.13.0.求反余弦值 DOUBLE tan(DOUBLE a), tan(DECIMAL a) Returns the tangent of a (a is in radians). Decimal version added in Hive 0.13.0.求正切值 DOUBLE atan(DOUBLE a), atan(DECIMAL a) Returns the arctangent of a. Decimal version added in Hive 0.13.0.求反正切值 DOUBLE degrees(DOUBLE a), degrees(DECIMAL a) Converts value of a from radians to degrees. Decimal version added in Hive 0.13.0.奖弧度值转换角度值 DOUBLE radians(DOUBLE a), radians(DOUBLE a) Converts value of a from degrees to radians. Decimal version added in Hive 0.13.0.将角度值转换成弧度值 DOUBLE positive(INT a), positive(DOUBLE a) Returns a.返回a INT or DOUBLE negative(INT a), negative(DOUBLE a) Returns -a.返回a的相反数 INT or DOUBLE sign(DOUBLE a), sign(DECIMAL a) Returns the sign of a as ‘1.0’ (if a is positive) or ‘-1.0’ (if a is negative), ‘0.0’ otherwise. The decimal version returns INT instead of DOUBLE. Decimal version added in Hive 0.13.0.如果a是正数则返回1.0，是负数则返回-1.0，否则返回0.0 DOUBLE or INT e() Returns the value of e.数学常数e DOUBLE pi() Returns the value of pi.数学常数pi DOUBLE factorial(INT a) Returns the factorial of a (as of Hive 1.2.0). Valid a is [0..20]. 求a的阶乘 BIGINT cbrt(DOUBLE a) Returns the cube root of a double value (as of Hive 1.2.0). 求a的立方根 DOUBLE shiftleft(TINYINT\ SMALLINT\ INT a, INT b)shiftleft(BIGINT a, INT b) Bitwise left shift (as of Hive 1.2.0). Shifts a b positions to the left.Returns int for tinyint, smallint and int a. Returns bigint for bigint a.按位左移 INT BIGINT shiftright(TINYINT\ SMALLINT\ INT a, INTb)shiftright(BIGINT a, INT b) Bitwise right shift (as of Hive 1.2.0). Shifts a b positions to the right.Returns int for tinyint, smallint and int a. Returns bigint for bigint a.按拉右移 INTBIGINT shiftrightunsigned(TINYINT\ SMALLINT\ INTa, INT b),shiftrightunsigned(BIGINT a, INT b) Bitwise unsigned right shift (as of Hive 1.2.0). Shifts a b positions to the right.Returns int for tinyint, smallint and int a. Returns bigint for bigint a.无符号按位右移（&lt;&lt;&lt;） INTBIGINT greatest(T v1, T v2, …) Returns the greatest value of the list of values (as of Hive 1.1.0). Fixed to return NULL when one or more arguments are NULL, and strict type restriction relaxed, consistent with “&gt;” operator (as of Hive 2.0.0). 求最大值 T least(T v1, T v2, …) Returns the least value of the list of values (as of Hive 1.1.0). Fixed to return NULL when one or more arguments are NULL, and strict type restriction relaxed, consistent with “&lt;” operator (as of Hive 2.0.0). 求最小值 T 2.2 集合函数 Name(Signature) Description Return Type size(Map&lt;K.V&gt;) Returns the number of elements in the map type.求map的长度 int size(Array) Returns the number of elements in the array type.求数组的长度 int map_keys(Map&lt;K.V&gt;) Returns an unordered array containing the keys of the input map.返回map中的所有key array map_values(Map&lt;K.V&gt;) Returns an unordered array containing the values of the input map.返回map中的所有value array array_contains(Array, value) Returns TRUE if the array contains value.如该数组Array包含value返回true。，否则返回false boolean sort_array(Array) Sorts the input array in ascending order according to the natural ordering of the array elements and returns it (as of version 0.9.0).按自然顺序对数组进行排序并返回 array 2.3 类型转换函数 Name(Signature) Description Return Type binary(string\ binary) Casts the parameter into a binary.将输入的值转换成二进制 binary cast(expr as ) Converts the results of the expression expr to . For example, cast(‘1’ as BIGINT) will convert the string ‘1’ to its integral representation. A null is returned if the conversion does not succeed. If cast(expr as boolean) Hive returns true for a non-empty string.将expr转换成type类型 如：cast(“1” as BIGINT) 将字符串1转换成了BIGINT类型，如果转换失败将返回NULL Expected “=” to follow “type” 2.4 日期函数 Name(Signature) Description Return Type from_unixtime(bigint unixtime[, string format]) Converts the number of seconds from unix epoch (1970-01-01 00:00:00 UTC) to a string representing the timestamp of that moment in the current system time zone in the format of “1970-01-01 00:00:00”.将时间的秒值转换成format格式（format可为“yyyy-MM-dd hh:mm:ss”,“yyyy-MM-dd hh”,“yyyy-MM-dd hh:mm”等等）如from_unixtime(1250111000,”yyyy-MM-dd”) 得到2009-03-12 string unix_timestamp() Gets current Unix timestamp in seconds.获取本地时区下的时间戳 bigint unix_timestamp(string date) Converts time string in format yyyy-MM-dd HH:mm:ss to Unix timestamp (in seconds), using the default timezone and the default locale, return 0 if fail: unix_timestamp(‘2009-03-20 11:30:01’) = 1237573801将格式为yyyy-MM-dd HH:mm:ss的时间字符串转换成时间戳 如unix_timestamp(‘2009-03-20 11:30:01’) = 1237573801 bigint unix_timestamp(string date, string pattern) Convert time string with given pattern (see [http://docs.oracle.com/javase/tutorial/i18n/format/simpleDateFormat.html]) to Unix time stamp (in seconds), return 0 if fail: unix_timestamp(‘2009-03-20’, ‘yyyy-MM-dd’) = 1237532400.将指定时间字符串格式字符串转换成Unix时间戳，如果格式不对返回0 如：unix_timestamp(‘2009-03-20’, ‘yyyy-MM-dd’) = 1237532400 bigint to_date(string timestamp) Returns the date part of a timestamp string: to_date(“1970-01-01 00:00:00”) = “1970-01-01”.返回时间字符串的日期部分 string year(string date) Returns the year part of a date or a timestamp string: year(“1970-01-01 00:00:00”) = 1970, year(“1970-01-01”) = 1970.返回时间字符串的年份部分 int quarter(date/timestamp/string) Returns the quarter of the year for a date, timestamp, or string in the range 1 to 4 (as of Hive 1.3.0). Example: quarter(‘2015-04-08’) = 2.返回当前时间属性哪个季度 如quarter(‘2015-04-08’) = 2 int month(string date) Returns the month part of a date or a timestamp string: month(“1970-11-01 00:00:00”) = 11, month(“1970-11-01”) = 11.返回时间字符串的月份部分 int day(string date) dayofmonth(date) Returns the day part of a date or a timestamp string: day(“1970-11-01 00:00:00”) = 1, day(“1970-11-01”) = 1.返回时间字符串的天 int hour(string date) Returns the hour of the timestamp: hour(‘2009-07-30 12:58:59’) = 12, hour(‘12:58:59’) = 12.返回时间字符串的小时 int minute(string date) Returns the minute of the timestamp.返回时间字符串的分钟 int second(string date) Returns the second of the timestamp.返回时间字符串的秒 int weekofyear(string date) Returns the week number of a timestamp string: weekofyear(“1970-11-01 00:00:00”) = 44, weekofyear(“1970-11-01”) = 44.返回时间字符串位于一年中的第几个周内 如weekofyear(“1970-11-01 00:00:00”) = 44, weekofyear(“1970-11-01”) = 44 int datediff(string enddate, string startdate) Returns the number of days from startdate to enddate: datediff(‘2009-03-01’, ‘2009-02-27’) = 2.计算开始时间startdate到结束时间enddate相差的天数 int date_add(string startdate, int days) Adds a number of days to startdate: date_add(‘2008-12-31’, 1) = ‘2009-01-01’.从开始时间startdate加上days string date_sub(string startdate, int days) Subtracts a number of days to startdate: date_sub(‘2008-12-31’, 1) = ‘2008-12-30’.从开始时间startdate减去days string from_utc_timestamp(timestamp, string timezone) Assumes given timestamp is UTC and converts to given timezone (as of Hive 0.8.0). For example, from_utc_timestamp(‘1970-01-01 08:00:00’,’PST’) returns 1970-01-01 00:00:00.如果给定的时间戳并非UTC，则将其转化成指定的时区下时间戳 timestamp to_utc_timestamp(timestamp, string timezone) Assumes given timestamp is in given timezone and converts to UTC (as of Hive 0.8.0). For example, to_utc_timestamp(‘1970-01-01 00:00:00’,’PST’) returns 1970-01-01 08:00:00.如果给定的时间戳指定的时区下时间戳，则将其转化成UTC下的时间戳 timestamp current_date Returns the current date at the start of query evaluation (as of Hive 1.2.0). All calls of current_date within the same query return the same value.返回当前时间日期 date current_timestamp Returns the current timestamp at the start of query evaluation (as of Hive 1.2.0). All calls of current_timestamp within the same query return the same value.返回当前时间戳 timestamp add_months(string start_date, int num_months) Returns the date that is num_months after start_date (as of Hive 1.1.0). start_date is a string, date or timestamp. num_months is an integer. The time part of start_date is ignored. If start_date is the last day of the month or if the resulting month has fewer days than the day component of start_date, then the result is the last day of the resulting month. Otherwise, the result has the same day component as start_date.返回当前时间下再增加num_months个月的日期 string last_day(string date) Returns the last day of the month which the date belongs to (as of Hive 1.1.0). date is a string in the format ‘yyyy-MM-dd HH:mm:ss’ or ‘yyyy-MM-dd’. The time part of date is ignored.返回这个月的最后一天的日期，忽略时分秒部分（HH:mm:ss） string next_day(string start_date, string day_of_week) Returns the first date which is later than start_date and named as day_of_week (as of Hive1.2.0). start_date is a string/date/timestamp. day_of_week is 2 letters, 3 letters or full name of the day of the week (e.g. Mo, tue, FRIDAY). The time part of start_date is ignored. Example: next_day(‘2015-01-14’, ‘TU’) = 2015-01-20.返回当前时间的下一个星期X所对应的日期 如：next_day(‘2015-01-14’, ‘TU’) = 2015-01-20 以2015-01-14为开始时间，其下一个星期二所对应的日期为2015-01-20 string trunc(string date, string format) Returns date truncated to the unit specified by the format (as of Hive 1.2.0). Supported formats: MONTH/MON/MM, YEAR/YYYY/YY. Example: trunc(‘2015-03-17’, ‘MM’) = 2015-03-01.返回时间的最开始年份或月份 如trunc(“2016-06-26”,“MM”)=2016-06-01 trunc(“2016-06-26”,“YY”)=2016-01-01 注意所支持的格式为MONTH/MON/MM, YEAR/YYYY/YY string months_between(date1, date2) Returns number of months between dates date1 and date2 (as of Hive 1.2.0). If date1 is later than date2, then the result is positive. If date1 is earlier than date2, then the result is negative. If date1 and date2 are either the same days of the month or both last days of months, then the result is always an integer. Otherwise the UDF calculates the fractional portion of the result based on a 31-day month and considers the difference in time components date1 and date2. date1 and date2 type can be date, timestamp or string in the format ‘yyyy-MM-dd’ or ‘yyyy-MM-dd HH:mm:ss’. The result is rounded to 8 decimal places. Example: months_between(‘1997-02-28 10:30:00’, ‘1996-10-30’) = 3.94959677**返回date1与date2之间相差的月份，如date1&gt;date2，则返回正，如果date1 double date_format(date/timestamp/string ts, string fmt) Converts a date/timestamp/string to a value of string in the format specified by the date format fmt (as of Hive 1.2.0). Supported formats are Java SimpleDateFormat formats –https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html. The second argument fmt should be constant. Example: date_format(‘2015-04-08’, ‘y’) = ‘2015’.date_format can be used to implement other UDFs, e.g.:dayname(date) is date_format(date, ‘EEEE’)dayofyear(date) is date_format(date, ‘D’)按指定格式返回时间date 如：date_format(“2016-06-22”,”MM-dd”)=06-22 string 2.5 条件函数 Name(Signature) Description Return Type if(boolean testCondition, T valueTrue, T valueFalseOrNull) Returns valueTrue when testCondition is true, returns valueFalseOrNull otherwise.如果testCondition 为true就返回valueTrue,否则返回valueFalseOrNull ，（valueTrue，valueFalseOrNull为泛型） T nvl(T value, T default_value) Returns default value if value is null else returns value (as of HIve 0.11).如果value值为NULL就返回default_value,否则返回value T COALESCE(T v1, T v2, …) Returns the first v that is not NULL, or NULL if all v’s are NULL.返回第一非null的值，如果全部都为NULL就返回NULL 如：COALESCE (NULL,44,55)=44/strong&gt; T CASE a WHEN b THEN c [WHEN d THEN e]* [ELSE f] END When a = b, returns c; when a = d, returns e; else returns f.如果a=b就返回c,a=d就返回e，否则返回f 如CASE 4 WHEN 5 THEN 5 WHEN 4 THEN 4 ELSE 3 END 将返回4 T CASE WHEN a THEN b [WHEN c THEN d]* [ELSE e] END When a = true, returns b; when c = true, returns d; else returns e.如果a=ture就返回b,c= ture就返回d，否则返回e 如：CASE WHEN 5&gt;0 THEN 5 WHEN 4&gt;0 THEN 4 ELSE 0 END 将返回5；CASE WHEN 5&lt;0 THEN 5 WHEN 4&lt;0 THEN 4 ELSE 0 END 将返回0 T isnull( a ) Returns true if a is NULL and false otherwise.如果a为null就返回true，否则返回false boolean isnotnull ( a ) Returns true if a is not NULL and false otherwise.如果a为非null就返回true，否则返回false boolean 2.6 字符函数 Name(Signature) Description Return Type ascii(string str) Returns the numeric value of the first character of str.返回str中首个ASCII字符串的整数值 int base64(binary bin) Converts the argument from binary to a base 64 string (as of Hive 0.12.0)..将二进制bin转换成64位的字符串 string concat(string\ binary A, string\ binary B…) Returns the string or bytes resulting from concatenating the strings or bytes passed in as parameters in order. For example, concat(‘foo’, ‘bar’) results in ‘foobar’. Note that this function can take any number of input strings..对二进制字节码或字符串按次序进行拼接 string context_ngrams(array&lt;array&gt;, array, int K, int pf) Returns the top-k contextual N-grams from a set of tokenized sentences, given a string of “context”. See StatisticsAndDataMining for more information..与ngram类似，但context_ngram()允许你预算指定上下文(数组)来去查找子序列，具体看StatisticsAndDataMining(这里的解释更易懂) array&lt;struct&lt;string,double&gt;&gt; concat_ws(string SEP, string A, string B…) Like concat() above, but with custom separator SEP..与concat()类似，但使用指定的分隔符喜进行分隔 string concat_ws(string SEP, array) Like concat_ws() above, but taking an array of strings. (as of Hive 0.9.0).拼接Array中的元素并用指定分隔符进行分隔 string decode(binary bin, string charset) Decodes the first argument into a String using the provided character set (one of ‘US-ASCII’, ‘ISO-8859-1’, ‘UTF-8’, ‘UTF-16BE’, ‘UTF-16LE’, ‘UTF-16’). If either argument is null, the result will also be null. (As of Hive 0.12.0.).使用指定的字符集charset将二进制值bin解码成字符串，支持的字符集有：’US-ASCII’, ‘ISO-8859-1’, ‘UTF-8’, ‘UTF-16BE’, ‘UTF-16LE’, ‘UTF-16’，如果任意输入参数为NULL都将返回NULL string encode(string src, string charset) Encodes the first argument into a BINARY using the provided character set (one of ‘US-ASCII’, ‘ISO-8859-1’, ‘UTF-8’, ‘UTF-16BE’, ‘UTF-16LE’, ‘UTF-16’). If either argument is null, the result will also be null. (As of Hive 0.12.0.).使用指定的字符集charset将字符串编码成二进制值，支持的字符集有：’US-ASCII’, ‘ISO-8859-1’, ‘UTF-8’, ‘UTF-16BE’, ‘UTF-16LE’, ‘UTF-16’，如果任一输入参数为NULL都将返回NULL binary find_in_set(string str, string strList) Returns the first occurance of str in strList where strList is a comma-delimited string. Returns null if either argument is null. Returns 0 if the first argument contains any commas. For example, find_in_set(‘ab’, ‘abc,b,ab,c,def’) returns 3..返回以逗号分隔的字符串中str出现的位置，如果参数str为逗号或查找失败将返回0，如果任一参数为NULL将返回NULL回 int format_number(number x, int d) Formats the number X to a format like ‘#,###,###.##’, rounded to D decimal places, and returns the result as a string. If D is 0, the result has no decimal point or fractional part. (As of Hive 0.10.0; bug with float types fixed in Hive 0.14.0, decimal type support added in Hive 0.14.0).将数值X转换成”#,###,###.##”格式字符串，并保留d位小数，如果d为0，将进行四舍五入且不保留小数 string get_json_object(string json_string, string path) Extracts json object from a json string based on json path specified, and returns json string of the extracted json object. It will return null if the input json string is invalid. NOTE: The json path can only have the characters [0-9a-z_], i.e., no upper-case or special characters. Also, the keys cannot start with numbers. This is due to restrictions on Hive column names..从指定路径上的JSON字符串抽取出JSON对象，并返回这个对象的JSON格式，如果输入的JSON是非法的将返回NULL,注意此路径上JSON字符串只能由数字 字母 下划线组成且不能有大写字母和特殊字符，且key不能由数字开头，这是由于Hive对列名的限制 string in_file(string str, string filename) Returns true if the string str appears as an entire line in filename..如果文件名为filename的文件中有一行数据与字符串str匹配成功就返回true boolean instr(string str, string substr) Returns the position of the first occurrence of substr in str. Returns null if either of the arguments are null and returns 0 if substr could not be found in str. Be aware that this is not zero based. The first character in str has index 1..查找字符串str中子字符串substr出现的位置，如果查找失败将返回0，如果任一参数为Null将返回null，注意位置为从1开始的 int length(string A) Returns the length of the string..返回字符串的长度 int locate(string substr, string str[, int pos]) Returns the position of the first occurrence of substr in str after position pos..查找字符串str中的pos位置后字符串substr第一次出现的位置 int lower(string A) lcase(string A) Returns the string resulting from converting all characters of B to lower case. For example, lower(‘fOoBaR’) results in ‘foobar’..将字符串A的所有字母转换成小写字母 string lpad(string str, int len, string pad) Returns str, left-padded with pad to a length of len..从左边开始对字符串str使用字符串pad填充，最终len长度为止，如果字符串str本身长度比len大的话，将去掉多余的部分 string ltrim(string A) Returns the string resulting from trimming spaces from the beginning(left hand side) of A. For example, ltrim(‘ foobar ‘) results in ‘foobar ‘..去掉字符串A前面的空格 string ngrams(array&lt;array&gt;, int N, int K, int pf) Returns the top-k N-grams from a set of tokenized sentences, such as those returned by the sentences() UDAF. See StatisticsAndDataMining for more information..返回出现次数TOP K的的子序列,n表示子序列的长度，具体看StatisticsAndDataMining (这里的解释更易懂) array&lt;struct&lt;string,double&gt;&gt; parse_url(string urlString, string partToExtract [, string keyToExtract]) Returns the specified part from the URL. Valid values for partToExtract include HOST, PATH, QUERY, REF, PROTOCOL, AUTHORITY, FILE, and USERINFO. For example, parse_url(‘http://facebook.com/path1/p.php?k1=v1&amp;k2=v2#Ref1&#39;, ‘HOST’) returns ‘facebook.com’. Also a value of a particular key in QUERY can be extracted by providing the key as the third argument, for example, parse_url(‘http://facebook.com/path1/p.php?k1=v1&amp;k2=v2#Ref1&#39;, ‘QUERY’, ‘k1’) returns ‘v1’..返回从URL中抽取指定部分的内容，参数url是URL字符串，而参数partToExtract是要抽取的部分，这个参数包含(HOST, PATH, QUERY, REF, PROTOCOL, AUTHORITY, FILE, and USERINFO,例如：parse_url(‘http://facebook.com/path1/p.php?k1=v1&amp;k2=v2#Ref1&#39;, ‘HOST’) =’facebook.com’，如果参数partToExtract值为QUERY则必须指定第三个参数key 如：parse_url(‘http://facebook.com/path1/p.php?k1=v1&amp;k2=v2#Ref1&#39;, ‘QUERY’, ‘k1’) =‘v1’ string printf(String format, Obj… args) Returns the input formatted according do printf-style format strings (as of Hive0.9.0)..按照printf风格格式输出字符串 string regexp_extract(string subject, string pattern, int index) Returns the string extracted using the pattern. For example, regexp_extract(‘foothebar’, ‘foo(.*?)(bar)’, 2) returns ‘bar.’ Note that some care is necessary in using predefined character classes: using ‘\s’ as the second argument will match the letter s; ‘\s’ is necessary to match whitespace, etc. The ‘index’ parameter is the Java regex Matcher group() method index. See docs/api/java/util/regex/Matcher.html for more information on the ‘index’ or Java regex group() method..抽取字符串subject中符合正则表达式pattern的第index个部分的子字符串，注意些预定义字符的使用，如第二个参数如果使用’\s’将被匹配到s,’\s’才是匹配空格 string regexp_replace(string INITIAL_STRING, string PATTERN, string REPLACEMENT) Returns the string resulting from replacing all substrings in INITIAL_STRING that match the java regular expression syntax defined in PATTERN with instances of REPLACEMENT. For example, regexp_replace(“foobar”, “oo\ ar”, “”) returns ‘fb.’ Note that some care is necessary in using predefined character classes: using ‘\s’ as the second argument will match the letter s; ‘\s’ is necessary to match whitespace, etc..按照Java正则表达式PATTERN将字符串INTIAL_STRING中符合条件的部分成REPLACEMENT所指定的字符串，如里REPLACEMENT这空的话，抽符合正则的部分将被去掉 如：regexp_replace(“foobar”, “oo\ ar”, “”) = ‘fb.’ 注意些预定义字符的使用，如第二个参数如果使用’\s’将被匹配到s,’\s’才是匹配空格 string repeat(string str, int n) Repeats str n times..重复输出n次字符串str string reverse(string A) Returns the reversed string..反转字符串 string rpad(string str, int len, string pad) Returns str, right-padded with pad to a length of len..从右边开始对字符串str使用字符串pad填充，最终len长度为止，如果字符串str本身长度比len大的话，将去掉多余的部分 string rtrim(string A) Returns the string resulting from trimming spaces from the end(right hand side) of A. For example, rtrim(‘ foobar ‘) results in ‘ foobar’..去掉字符串后面出现的空格 string sentences(string str, string lang, string locale) Tokenizes a string of natural language text into words and sentences, where each sentence is broken at the appropriate sentence boundary and returned as an array of words. The ‘lang’ and ‘locale’ are optional arguments. For example, sentences(‘Hello there! How are you?’) returns ( (“Hello”, “there”), (“How”, “are”, “you”) )..字符串str将被转换成单词数组，如：sentences(‘Hello there! How are you?’) =( (“Hello”, “there”), (“How”, “are”, “you”) ) array&lt;array&gt; space(int n) Returns a string of n spaces..返回n个空格 string split(string str, string pat) Splits str around pat (pat is a regular expression)..按照正则表达式pat来分割字符串str,并将分割后的数组字符串的形式返回 array str_to_map(text[, delimiter1, delimiter2]) Splits text into key-value pairs using two delimiters. Delimiter1 separates text into K-V pairs, and Delimiter2 splits each K-V pair. Default delimiters are ‘,’ for delimiter1 and ‘=’ for delimiter2..将字符串str按照指定分隔符转换成Map，第一个参数是需要转换字符串，第二个参数是键值对之间的分隔符，默认为逗号;第三个参数是键值之间的分隔符，默认为”=” map&lt;string,string&gt; substr(string\ binary A, int start) substring(string\ binary A, int start) Returns the substring or slice of the byte array of A starting from start position till the end of string A. For example, substr(‘foobar’, 4) results in ‘bar’ (see [http://dev.mysql.com/doc/refman/5.0/en/string-functions.html#function_substr])..对于字符串A,从start位置开始截取字符串并返回 string substr(string\ binary A, int start, int len) substring(string\ binary A, int start, int len) Returns the substring or slice of the byte array of A starting from start position with length len. For example, substr(‘foobar’, 4, 1) results in ‘b’ (see [http://dev.mysql.com/doc/refman/5.0/en/string-functions.html#function_substr])..对于二进制/字符串A,从start位置开始截取长度为length的字符串并返回 string substring_index(string A, string delim, int count) Returns the substring from string A before count occurrences of the delimiter delim (as of Hive 1.3.0). If count is positive, everything to the left of the final delimiter (counting from the left) is returned. If count is negative, everything to the right of the final delimiter (counting from the right) is returned. Substring_index performs a case-sensitive match when searching for delim. Example: substring_index(‘www.apache.org&#39;, ‘.’, 2) = ‘www.apache&#39;..截取第count分隔符之前的字符串，如count为正则从左边开始截取，如果为负则从右边开始截取 string translate(string\ char\ varchar input, string\ char\ varchar from, string\ char\ varchar to) Translates the input string by replacing the characters present in the from string with the corresponding characters in the to string. This is similar to the translatefunction in PostgreSQL. If any of the parameters to this UDF are NULL, the result is NULL as well. (Available as of Hive 0.10.0, for string types)Char/varchar support added as of Hive 0.14.0..将input出现在from中的字符串替换成to中的字符串 如：translate(“MOBIN”,”BIN”,”M”)=”MOM” string trim(string A) Returns the string resulting from trimming spaces from both ends of A. For example, trim(‘ foobar ‘) results in ‘foobar’.将字符串A前后出现的空格去掉 string unbase64(string str) Converts the argument from a base 64 string to BINARY. (As of Hive 0.12.0.).将64位的字符串转换二进制值 binary upper(string A) ucase(string A) Returns the string resulting from converting all characters of A to upper case. For example, upper(‘fOoBaR’) results in ‘FOOBAR’..将字符串A中的字母转换成大写字母 string initcap(string A) Returns string, with the first letter of each word in uppercase, all other letters in lowercase. Words are delimited by whitespace. (As of Hive 1.1.0.).将字符串A转换第一个字母大写其余字母的字符串 string levenshtein(string A, string B) Returns the Levenshtein distance between two strings (as of Hive 1.2.0). For example, levenshtein(‘kitten’, ‘sitting’) results in 3..计算两个字符串之间的差异大小 如：levenshtein(‘kitten’, ‘sitting’) = 3 int soundex(string A) Returns soundex code of the string (as of Hive 1.2.0). For example, soundex(‘Miller’) results in M460..将普通字符串转换成soundex字符串 string 2.7 聚合函数 Name(Signature) Description Return Type count(*), count(expr), count(DISTINCT expr[, expr…]) count(*) - Returns the total number of retrieved rows, including rows containing NULL values.统计总行数，包括含有NULL值的行count(expr) - Returns the number of rows for which the supplied expression is non-NULL.统计提供非NULL的expr表达式值的行数count(DISTINCT expr[, expr]) - Returns the number of rows for which the supplied expression(s) are unique and non-NULL. Execution of this can be optimized with hive.optimize.distinct.rewrite.统计提供非NULL且去重后的expr表达式值的行数 BIGINT sum(col), sum(DISTINCT col) Returns the sum of the elements in the group or the sum of the distinct values of the column in the group.sum(col),表示求指定列的和，sum(DISTINCT col)表示求去重后的列的和 DOUBLE avg(col), avg(DISTINCT col) Returns the average of the elements in the group or the average of the distinct values of the column in the group.avg(col),表示求指定列的平均值，avg(DISTINCT col)表示求去重后的列的平均值 DOUBLE min(col) Returns the minimum of the column in the group.求指定列的最小值 DOUBLE max(col) Returns the maximum value of the column in the group.求指定列的最大值 DOUBLE variance(col), var_pop(col) Returns the variance of a numeric column in the group.求指定列数值的方差 DOUBLE var_samp(col) Returns the unbiased sample variance of a numeric column in the group.求指定列数值的样本方差 DOUBLE stddev_pop(col) Returns the standard deviation of a numeric column in the group.求指定列数值的标准偏差 DOUBLE stddev_samp(col) Returns the unbiased sample standard deviation of a numeric column in the group.求指定列数值的样本标准偏差 DOUBLE covar_pop(col1, col2) Returns the population covariance of a pair of numeric columns in the group.求指定列数值的协方差 DOUBLE covar_samp(col1, col2) Returns the sample covariance of a pair of a numeric columns in the group.求指定列数值的样本协方差 DOUBLE corr(col1, col2) Returns the Pearson coefficient of correlation of a pair of a numeric columns in the group.返回两列数值的相关系数 DOUBLE percentile(BIGINT col, p) Returns the exact pth percentile of a column in the group (does not work with floating point types). p must be between 0 and 1. NOTE: A true percentile can only be computed for integer values. Use PERCENTILE_APPROX if your input is non-integral.返回col的p%分位数 DOUBLE 2.8 表生成函数 Name(Signature) Description Return Type explode(array a) For each element in a, generates a row containing that element.对于a中的每个元素，将生成一行且包含该元素 Array Type explode(ARRAY) Returns one row for each element from the array..每行对应数组中的一个元素 N rows explode(MAP) Returns one row for each key-value pair from the input map with two columns in each row: one for the key and another for the value. (As of Hive 0.8.0.).每行对应每个map键-值，其中一个字段是map的键，另一个字段是map的值 N rows posexplode(ARRAY) Behaves like explode for arrays, but includes the position of items in the original array by returning a tuple of (pos, value). (As of Hive 0.13.0.).与explode类似，不同的是还返回各元素在数组中的位置 N rows stack(INT n, v_1, v_2, …, v_k) Breaks up v_1, …, v_k into n rows. Each row will have k/n columns. n must be constant..把M列转换成N行，每行有M/N个字段，其中n必须是个常数 N rows json_tuple(jsonStr, k1, k2, …) Takes a set of names (keys) and a JSON string, and returns a tuple of values. This is a more efficient version of the get_json_object UDF because it can get multiple keys with just one call..从一个JSON字符串中获取多个键并作为一个元组返回，与get_json_object不同的是此函数能一次获取多个键值 tuple parse_url_tuple(url, p1, p2, …) This is similar to the parse_url() UDF but can extract multiple parts at once out of a URL. Valid part names are: HOST, PATH, QUERY, REF, PROTOCOL, AUTHORITY, FILE, USERINFO, QUERY:..返回从URL中抽取指定N部分的内容，参数url是URL字符串，而参数p1,p2,….是要抽取的部分，这个参数包含HOST, PATH, QUERY, REF, PROTOCOL, AUTHORITY, FILE, USERINFO, QUERY: tuple inline(ARRAY&lt;STRUCT[,STRUCT]&gt;) Explodes an array of structs into a table. (As of Hive 0.10.).将结构体数组提取出来并插入到表中 3.加载数据123456789101112131415161718192021222324252627282930313233343536373839404142434445# arraycreate table person(name string,work_locations array&lt;string&gt;)ROW FORMAT DELIMITEDFIELDS TERMINATED BY &apos;\t&apos;COLLECTION ITEMS TERMINATED BY &apos;,&apos;;# 数据biansutao beijing,shanghai,tianjin,hangzhoulinan changchu,chengdu,wuhan# 入库数据LOAD DATA LOCAL INPATH &apos;/home/hadoop/person.txt&apos; OVERWRITE INTO TABLE person;select * from person;# biansutao [&quot;beijing&quot;,&quot;shanghai&quot;,&quot;tianjin&quot;,&quot;hangzhou&quot;]# linan [&quot;changchu&quot;,&quot;chengdu&quot;,&quot;wuhan&quot;]# mapcreate table score(name string, score map&lt;string,int&gt;)ROW FORMAT DELIMITEDFIELDS TERMINATED BY &apos;\t&apos;COLLECTION ITEMS TERMINATED BY &apos;,&apos;MAP KEYS TERMINATED BY &apos;:&apos;;# 数据biansutao &apos;数学&apos;:80,&apos;语文&apos;:89,&apos;英语&apos;:95jobs &apos;语文&apos;:60,&apos;数学&apos;:80,&apos;英语&apos;:99# 入库数据LOAD DATA LOCAL INPATH &apos;/home/hadoop/score.txt&apos; OVERWRITE INTO TABLE score;select * from score;# biansutao &#123;&quot;数学&quot;:80,&quot;语文&quot;:89,&quot;英语&quot;:95&#125;# jobs &#123;&quot;语文&quot;:60,&quot;数学&quot;:80,&quot;英语&quot;:99&#125;# structCREATE TABLE test(id int,course struct&lt;course:string,score:int&gt;)ROW FORMAT DELIMITEDFIELDS TERMINATED BY &apos;\t&apos;COLLECTION ITEMS TERMINATED BY &apos;,&apos;;# 数据1 english,802 math,893 chinese,95# 入库LOAD DATA LOCAL INPATH &apos;/home/hadoop/test.txt&apos; OVERWRITE INTO TABLE test;# 查询select * from test;# 1 &#123;&quot;course&quot;:&quot;english&quot;,&quot;score&quot;:80&#125;# 2 &#123;&quot;course&quot;:&quot;math&quot;,&quot;score&quot;:89&#125;# 3 &#123;&quot;course&quot;:&quot;chinese&quot;,&quot;score&quot;:95&#125; 4.配置优化1234567891011121314151617181920212223242526272829303132# 开启任务并行执行set hive.exec.parallel=true# 设置运行内存set mapreduce.map.memory.mb=1024;set mapreduce.reduce.memory.mb=1024;# 指定队列set mapreduce.job.queuename=jppkg_high;# 动态分区，为了防止一个reduce处理写入一个分区导致速度严重降低，下面需设置为false# 默认为trueset hive.optimize.sort.dynamic.partition=false;# 设置变量set hivevar:factor_timedecay=-0.3;set hivevar:pre_month=$&#123;zdt.addDay(-30).format(&quot;yyyy-MM-dd&quot;)&#125;;set hivevar:pre_date=$&#123;zdt.addDay(-1).format(&quot;yyyy-MM-dd&quot;)&#125;;set hivevar:cur_date=$&#123;zdt.format(&quot;yyyy-MM-dd&quot;)&#125;;# 添加第三方jar包, 添加临时函数add jar ***.jar;# 压缩输出，ORC默认自带压缩，不需要额外指定,如果使用非ORCFile,则设置如下hive.exec.compress.output=true# 如果一个大文件可以拆分，为防止一个Map读取过大的数据，拖慢整体流程，需设置hive.hadoop.suports.splittable.combineinputformat# 避免因数据倾斜造成的计算效率，默认falsehive.groupby.skewindata# 避免因join引起的数据倾斜hive.optimize.skewjoin# map中会做部分聚集操作，效率高，但需要更多内存hive.map.aggr -- 默认打开hive.groupby.mapaggr.checkinterval -- 在Map端进行聚合操作的条目数目# 当多个group by语句有相同的分组列，则会优化为一个MR任务。默认关闭。hive.multigroupby.singlemr# 自动使用索引，默认不开启，需配合row group index，可以提高计算速度hive.optimize.index.filter 5. 常用技巧 1.插入中文数据 1insert into temp.tbl_test PARTITION(ymd=&apos;2019-06-19&apos;) select decode(binary(&apos;李白&apos;),&apos;utf-8&apos;); 2.更新数据 1insert overwrite table temp.tbl_test values (&apos;1&apos;,&apos;2&apos;,&apos;3&apos;); 3.按照分隔符拆分某个列返回多条 一条转多条 1select new_column_name from tbl_test lateral view explode(split(column_list_name,&apos;拆分符号&apos;)) as new_column_name; 4.将分组中多条的某列的值转为一条的一个数组返回 1234-- column_name字段不去重select username, collect_set(column_name) as new_column_list_name from tbl_test group by username;-- column_name字段去重select username, collect_list(column_name) as new_column_list_name from tbl_test group by username;]]></content>
      <tags>
        <tag>大数据</tag>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据（六）Hadoop的部署]]></title>
    <url>%2F2019%2F09%2F15%2F%E5%A4%A7%E6%95%B0%E6%8D%AE06%2F</url>
    <content type="text"><![CDATA[本文章主要介绍在centos环境下如何安装Hadoop。 Quick Guide下载并安装Hadoop 1.使用以下命令添加Hadoop系统用户12sudo addgroup hadoop # 新建用户组 sudo adduser --ingroup hadoop hadoop # 新建用户 注意：出现这个报错”hadoop is not in the sudoers file. This incident will be reported.”,可以通过以root用户身份登录解决此错误 2.配置SSH1234su - hadoop # 切换用户ssh-keygen -t rsa -P "" # 创建一个新密钥cat $HOME/.ssh/id_rsa.pub &gt;&gt; $HOME/.ssh/authorized_keys # 启用密钥ssh localhost # 测试是否可用 注意：出现 openssh-server没安装的错误，请使用下面命令安装1yum openssh-server 3.下载Hadoop 3.1 点击Hadoop链接,再点击镜像地址 3.2 选择稳定版本 3.3 选择tar.gz文件（文件名没有’src’） 4.放到服务器解压 1234sudo tar xzf hadoop-3.2.1.tar.gz -C /hadoop/install # 解压cd /hadoop/installsudo mv hadoop-3.2.1 hadoop # 修改文件名sudo chown -R hadoop:hadoop hadoop # 目录增加用户权限 配置Hadoop配置环境变量1234export HADOOP_HOME=&lt;Hadoop的安装路径&gt; # 设置HADOOP_HOMEexport JAVA_HOME=&lt;Java的安装路径&gt; # 设置JAVA_HOMEexport PATH=$PATH:$HADOOP_HOME/bin # 将Hadoop的bin目录添加到PATH. ~/.bashrc # 环境下应用该配置 配置 HDFS配置环境变量在 $HADOOP_HOME/etc/hadoop/hadoop-env.sh 设置 JAVA_HOME 配置前： 配置后： 配置核心组件文件$HADOOP_HOME/etc/hadoop/core-site.xml 中有两个参数 hadoop.tmp.dir - 用于Hadoop的存储数据文件的目录 fs.default.name - 指定默认的文件系统 1.打开文件 1sudo gedit $HADOOP_HOME/etc/hadoop/core-site.xml 2.复制下面配置到 文件内容的 &lt;configuration&gt; 和 &lt;/configuration&gt; 之间 12345678910&lt;property&gt;&lt;name&gt;hadoop.tmp.dir&lt;/name&gt;&lt;value&gt;/hadoop/install/hadoop/tmp&lt;/value&gt;&lt;description&gt;Parent directory for other temporary directories.&lt;/description&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;fs.defaultFS &lt;/name&gt;&lt;value&gt;hdfs://master:54310&lt;/value&gt;&lt;description&gt;The name of the default file system. &lt;/description&gt;&lt;/property&gt; 3.移动到目录 $HADOOP_HOME/etc/hadoop 1sudo mkdir -p &lt;以上设置中使用的目录路径&gt; 4.授权目录权限 12sudo chown -R hadoop:hadoop &lt;在上一步中创建的目录路径&gt;sudo chmod 750 &lt;在上一步中创建的目录路径&gt; 配置文件系统 1.打开文件 $HADOOP_HOME/etc/hadoop/hdfs-site.xml 1sudo gedit $HADOOP_HOME/etc/hadoop/hdfs-site.xml 2.复制下面配置到 文件内容的 &lt;configuration&gt; 和 &lt;/configuration&gt; 之间 123456789&lt;property&gt;&lt;name&gt;dfs.replication&lt;/name&gt;&lt;value&gt;1&lt;/value&gt;&lt;description&gt;Default block replication.&lt;/description&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;&lt;value&gt;/hadoop/install/hadoop/hdfs&lt;/value&gt;&lt;/property&gt; 3.创建以上设置中指定的目录并授权123sudo mkdir -p /hadoop/install/hadoop/hdfssudo chown -R hadoop:hadoop /hadoop/install/hadoop/hdfssudo chmod 750 /hadoop/install/hadoop/hdfs 配置 Map Reduce配置环境变量 1.设置HADOOP_HOME路径 123sudo gedit /etc/profile.d/hadoop.sh # 打开文件export HADOOP_HOME=&lt;Hadoop的安装路径&gt; # 增加设置环境变量命令sudo chmod +x /etc/profile.d/hadoop.sh # 脚本增加执行权限 2.增加脚本权限，并退出终端界面 123sudo chmod +x /etc/profile.d/hadoop.sh # 脚本增加执行权限# 重新登陆使用命令验证变量设置是否生效echo $HADOOP_HOME 配置MapReduce计算框架文件 1.复制文件 mapred-site.xml 并打开 12sudo cp $HADOOP_HOME/etc/hadoop/mapred-site.xml.template $HADOOP_HOME/etc/hadoop/mapred-site.xmlsudo gedit $HADOOP_HOME/etc/hadoop/mapred-site.xml 2.复制下面配置到 文件内容的 &lt;configuration&gt; 和 &lt;/configuration&gt; 之间 123456&lt;property&gt;&lt;name&gt;mapreduce.jobtracker.address&lt;/name&gt;&lt;value&gt;master:54311&lt;/value&gt;&lt;description&gt;MapReduce job tracker runs at this host and port.&lt;/description&gt;&lt;/property&gt; 配置 yarn-site.xml 文件 1.打开文件 $HADOOP_HOME/etc/hadoop/yarn-site.xml 1sudo gedit $HADOOP_HOME/etc/hadoop/yarn-site.xml 2.复制下面配置到 文件内容的 &lt;configuration&gt; 和 &lt;/configuration&gt; 之间 123456789101112131415161718192021222324&lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;yarn.resourcemanager.address&lt;/name&gt; &lt;value&gt;master:18040&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;yarn.resourcemanager.scheduler.address&lt;/name&gt; &lt;value&gt;master:18030&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;yarn.resourcemanager.resource-tracker.address&lt;/name&gt; &lt;value&gt;master:18025&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;yarn.resourcemanager.admin.address&lt;/name&gt; &lt;value&gt;master:18141&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt; &lt;value&gt;master:18088&lt;/value&gt;&lt;/property&gt; 格式化HDFS1$HADOOP_HOME/bin/hdfs namenode -format 启动Hadoop 1.使用以下命令启动hdfs1$HADOOP_HOME/sbin/start-dfs.sh 2.使用以下命令启动yarn 1$HADOOP_HOME/sbin/start-yarn.sh 3.使用 jps 工具/命令，验证所有与Hadoop相关的进程是否正在运行。如果Hadoop已成功启动，则jps的输出应显示NameNode/NodeManager/ResourceManager/SecondaryNameNode/DataNode。 停止Hadoop12$HADOOP_HOME/sbin/stop-dfs.sh$HADOOP_HOME/sbin/stop-yarn.sh]]></content>
      <tags>
        <tag>大数据</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据（五）Hadoop的基础概念]]></title>
    <url>%2F2019%2F08%2F15%2F%E5%A4%A7%E6%95%B0%E6%8D%AE05%2F</url>
    <content type="text"><![CDATA[随着海量数据增加，需要大数据技术去存储和处理它。Hadoop是大数据技术的基础，对Hadoop基础知识的掌握的扎实程度，会决定在大数据技术道路上走多远。本文章主要介绍Hadoop的基础知识。 Quick Guide起源Google 遇到两个问题 大量的网页日益增加怎么存储 和 搜索算法，提出了三大理论（GFS 文件存储、Map-Reduce 计算、BigTable）来解决这个问题，受到启发的Doug Cutting等人开始尝试实现MapReduce计算框架，并将它与NDFS（Nutch Distributed File System）结合，用以支持Nutch引擎的主要算法。由于NDFS和MapReduce在Nutch引擎中有着良好的应用，所以它们于2006年2月被分离出来，成为一套完整而独立的软件，并被命名为Hadoop。 HadoopApache Hadoop 是一个开源分布式计算软件框架，允许使用 简单的编程模型 在 跨计算机集群 的 分布式环境 中存储和处理大数据。 数据分布在多台机器,单份数据复制到多个节点 尽量地将任务分配到离数据最近的机器上运行(网络IO速度 &lt;&lt; 本地磁盘IO速度) 使用串行IO取代随机IO,一般数据写入后不再修改(传输时间 &lt;&lt; 寻道时间) 优点 高可靠性：冗余副本策略、机架感知策略、心跳机制、安全模式、校验和、回收站、元数据保护和快照机制等设计保证可靠性。例如冗余副本策略，自动保存数据的多个副本，并且能够自动将失败的任务重新分配。 高扩展性：Hadoop是在可用的计算机集簇间分配数据并完成计算任务的，这些集簇可以方便地扩展到数以千计的节点中。 高效性：Hadoop能够在节点之间动态地移动数据，并保证各个节点的动态平衡，因此处理速度非常快 。 低成本：开源的，只需要一般的商用硬件。 生态系统和组件 Hadoop架构 主节点：主节点允许您使用Hadoop MapReduce进行数据并行处理。 从节点：从节点是Hadoop集群中的其他计算机，可让您存储数据以进行复杂的计算。此外，所有从属节点都随附有Task Tracker和一个DataNode。这使您可以分别与NameNode和Job Tracker同步进程。 NameNode：NameNode表示名称空间中使用的每个文件和目录 数据节点：DataNode可帮助您管理HDFS节点的状态，并允许您与块进行交互 Hadoop组成 MapReduce: 分布式计算 HDFS: 分布式文件存储 YARN: 分布式资源管理 Others: 利用YARN的资源管理功能实现其他的数据处理方式 HDFS Block数据块 基本存储单位，一般大小为64M(注:配置大的块 ) 减少搜寻时间，一般硬盘传输速率比寻道时间要快，大的块可以减少寻道时间； 减少管理块的数据开销，每个块都需要在NameNode上有对应的记录； 对数据块进行读写，减少建立网络的连接成本; 一个大文件会被拆分成一个个的块，然后存储于不同的机器。如果一个文件少于Block大小，那么实际占用的空间为其文件的大小 基本的读写单位，类似于磁盘的页，每次都是读写一个块 每个块都会被复制到多台机器，默认复制3份 NameNode 存储文件的metadata，运行时所有数据都保存到内存，整个HDFS可存储的文件数受限于NameNode的内存大小 一个Block在NameNode中对应一条记录（一般一个block占用150字节），如果是大量的小文件，会消耗大量内存。同时map task的数量是由splits来决定的，所以用MapReduce处理大量的小文件时，就会产生过多的map task，线程管理开销将会增加作业时间。处理大量小文件的速度远远小于处理同等大小的大文件的速度。因此Hadoop建议存储大文件 数据会定时保存到本地磁盘，但不保存block的位置信息，而是由DataNode注册时上报和运行时维护（NameNode中与DataNode相关的信息并不保存到NameNode的文件系统中，而是NameNode每次重启后，动态重建） NameNode失效则整个HDFS都失效了，所以要保证NameNode的可用性 Secondary NameNode 定时与NameNode进行同步（定期合并文件系统镜像和编辑日志，然后把合并后的传给NameNode，替换其镜像，并清空编辑日志，类似于CheckPoint机制），但NameNode失效后仍需要手工将其设置成主机 DataNode 保存具体的block数据 负责数据的读写操作和复制操作 DataNode启动时会向NameNode报告当前存储的数据块信息，后续也会定时报告修改信息 DataNode之间会进行通信，复制数据块，保证数据的冗余性 YARN 旧的MapReduce架构：存在单点和资源利用率问题 JobTracker: 负责资源管理，跟踪资源消耗和可用性，作业生命周期管理（调度作业任务，跟踪进度，为任务提供容错） TaskTracker: 加载或关闭任务，定时报告任务状态 YARN就是将JobTracker的职责进行拆分，将资源管理和任务调度监控拆分成独立的进程： ResourceManager: 全局资源管理和任务调度 NodeManager: 单个节点的资源管理和监控 ApplicationMaster: 单个作业的资源管理和任务监控 Container: 资源申请的单位和任务运行的容器 MapReduceMapReduce主要是先读取文件数据，然后进行Map处理，接着Reduce处理，最后把处理结果写到文件中 More info: Hadoop]]></content>
      <tags>
        <tag>大数据</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据（四）大数据生态]]></title>
    <url>%2F2019%2F07%2F15%2F%E5%A4%A7%E6%95%B0%E6%8D%AE04%2F</url>
    <content type="text"><![CDATA[海量数据就需要对应大数据技术去存储和处理它。 本文章主要介绍如何搭建大数据生态环境。 Quick Guide现在搭建大数据环境有三种方式： 1.docker方式: 利用docker-compose一键编排部署 优点：一键部署，快捷方便 缺点：性能不高只适合测试环境或者学习 2.使用成熟的发行版本去部署：例如 CM(Cloudera Manager)+CDH（Cloudera’s Distribution Including Apache Hadoop）或者Ambari+HDP(Hortonworks Data Platform) 优点：集群安装部署和运维方便 缺点：屏蔽太多细节，妨碍对组件理解 3.使用开源版本： 优点： 完全开源免费，社区活跃， 文档、资料详实 ， 缺点： 集群安装部署复杂，需要编写大量配置文件，需要考虑组件之间的兼容性问题、版本匹配问题、冲突问题、编译问题等； 集群运维复杂，需要安装第三方软件辅助。 机器准备 1.准备多台物理机或者使用VM安装多台虚机 2.从官网下载centos系统包并安装 机器配置如果是docker方式部署，就不需要经历这个步骤 0.修改服务器的ip地址 1234567vi /etc/sysconfig/network-scripts/ifcfg-eth0BOOTPROTO="static"ONBOOT=yesIPADDR=192.168.52.100NETMASK=255.255.255.0GATEWAY=192.168.52.1DNS1=8.8.8.8 例如：将准备好的三台服务器的IP地址分别设置成为如下： 第一台机器IP地址：192.168.52.100 第二台机器IP地址：192.168.52.110 第三台机器IP地址：192.168.52.120 第四台机器IP地址：192.168.52.130 1.关闭防火墙 12345678# centos 7 默认使用的是firewall，也可以使用iptables配置规则systemctl stop firewalld.servicesystemctl mask firewalld.serviceservice iptables status # 查看状态service iptables stop # 临时关闭chkconfig iptables --list # 查看防火墙启动级别chkconfig iptables off # 永久关闭 2.关闭SELinux（所有节点） 12345# 使用root用户登录四台服务器，执行以下命令关闭selinuxvim /etc/selinux/configSELINUX=enforcing # 注释掉SELINUX=disabled # 添加/usr/sbin/sestatus -v # 查看状态 3.修改主机名 12345# 在不同机器上执行hostnamectl set-hostname masterhostnamectl set-hostname node01hostnamectl set-hostname node02hostnamectl set-hostname node03 4.更改主机名与IP地址映射 12345vim /etc/hosts192.168.52.100 master.kaikeba.com master192.168.52.110 node01.kaikeba.com node01192.168.52.120 node02.kaikeba.com node02192.168.52.130 node03.kaikeba.com node03 5.主机间ntp同步时间 123yum -y install ntpdatecrontab -e*/1 * * * * /usr/sbin/ntpdate time1.aliyun.com # 这边使用的阿里云的ntp服务器，如果不能访问外网，就应该配置内网的ntp服务器 6.添加普通用户 1234567# 创建hadoop，并设置密码为 hadoop sudo addgroup hadoop # 新建用户组 sudo adduser --ingroup hadoop hadoop # 新建用户passwd hadoop# 给用户增加roo权限：在（root ALL=(ALL)ALL）在下面添加一行sudo vim /etc/sudoershadoop ALL=(ALL) ALL 7.配置免密登录 1234567891011# 生成私钥和公钥,在/home/当前用户/.ssh目录下找到id_rsa(私钥)和id_rsa.pub(公钥)ssh-keygen -t rsa #三台机器在hadoop用户下，执行以下命令将公钥拷贝到master服务器上面去ssh-copy-id master # master在hadoop用户下，执行以下命令，将authorized_keys拷贝到 node01、node02与node03服务器cd /home/hadoop/.ssh/scp authorized_keys node01:$PWDscp authorized_keys node02:$PWDscp authorized_keys node03:$PWD 8.定义统一目录 123mkdir -p /hadoop/soft # 软件压缩包存放目录mkdir -p /hadoop/install # 软件解压后存放目录chown -R hadoop:hadoop /hadoop # 将文件夹权限更改为hadoop用户 9.安装java 12345678# 从官网下载jdk包，解压到目录tar -zxf jdk-8u141-linux-x64.tar.gz -C /hadoop/install sudo vim /etc/profile#添加以下配置内容，配置jdk环境变量export JAVA_HOME=/hadoop/install/jdk1.8.0_141export PATH=:$JAVA_HOME/bin:$PATH 10.在root用户下重启 1reoot -h now Docker 部署不少公司把所有的 大数据组件都做成了 docker image ，可以直接通过 docker-compose 一键按照，具体看一下参考下面的教程： 安装教程1 安装教程2 CM + CDH 部署 CM：Cloudera Manager，Cloudera公司编写的一个CDH的管理后台，类似各CMS的管理后台。 CDH：Cloudera’s distribution,including Apache Hadoop，Cloudera公司制作的一个Hadoop发行版，集成了Hadoop及Hive等与Hadoop关系紧密的工具。 1.下载 根据操作系统从CM bin文件下载对应版本 根据操作系统从[CM rpm包]http://archive.cloudera.com/cm5/redhat/6/x86_64/cm/)下载对应版本 根据操作系统从CDH下载对应版本的manifest.json、.parcel和.sha1文件 2.上传介质到master，上传目录为/hadoop/soft，并解压 12tar -zxvf cm5.5.1.tar.gz tar -zxvf cdh5.5.1.tar.gz 3.各个节点配置本地yum源（master） 12cd /etc/yum.repos.dvi cloudera-manager.repo 添加下面内容 1234[cloudera-manager]name=Cloudera Manager, Version 5.5.1baseurl=http://192.168.52.100/cm5.5.1gpgcheck=0 4.启动http服务 12service httpd status # 查看服务状态service httpd start # 打开服务 5.验证本地yum源 将上一步baseurl地址粘贴到浏览器 确认是否能正常访问到已经上传安装文件的机器的安装文件目录。 6.运行CM安装 12345# 赋予bin文件执行权限chmod u+x cloudera-manager-installer5.5.1.bincd /hadoop/soft# 运行bin文件./cloudera-manager-installer5.5.1.bin 7.验证CM安装是否完成 使用命令查看服务状态：service cloudera-scm-server status 点击 管理界面(http://192.168.52.100:7180/cmf) 登陆，用户名和密码都为admin 8.修正参数 123echo 0 &gt; /proc/sys/vm/swappinessecho never &gt; /sys/kernel/mm/transparent_hugepage/defragecho never &gt; /sys/kernel/mm/transparent_hugepage/enabled 9.开始安装 1.接受许可 2.选择相应的版本 3.选择主机：搜索主机，也可以自己输ip 4.选择存储库：使用Parcel，远程Parcel 存储库URL指定安装源(本地源) 5.勾选JDK 6.填写用户（hadoop）密码 7.开始安装 8.自定义添加服务 9.安装角色 10.数据库选择：建议使用默认数据库。以后可以进行修改。 11.指定数据目录 10.排错 1.完成以上，说明集群已经安装成功，其他问题需要在后续过程调试。页面显示红色不等于服务没有安装成功，验证参数没有满足默认而已。 2.关闭时钟同步 3.验证安装：例如 到安装HDFS角色的服务器上任意目录执行如下命令（hadoop fs -ls /），能正常执行即代表功能可用 开源版本部署从下图可以知道，使用开源版本部署比较麻烦，组件比较多，后面就一章一章慢慢说。]]></content>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据（三）大数据测试]]></title>
    <url>%2F2019%2F06%2F15%2F%E5%A4%A7%E6%95%B0%E6%8D%AE03%2F</url>
    <content type="text"><![CDATA[大数据是无法使用传统计算技术处理的大型数据集的集合，所以这些数据集的测试涉及各种要处理的工具，技术和框架，需要去了解和掌握。 大数据测试是大数据应用程序的测试，不是测试软件产品的各个功能，而是测试大数据应用程序对其数据处理的验证，数据处理功能和性能测试是关键。 本文章主要介绍大数据测试的基本知识。 Quick Guide大数据测试类型 数据处理 批量 实时 交互 数据质量 一致性 准确性 有效性 完整性 大数据测试步骤 数据阶段验证大数据测试的第一步，也称作pre-hadoop阶段该过程包括如下验证： 来自各方面的数据资源应该被验证，来确保正确的数据被加载进系统 将源数据与推送到Hadoop系统中的数据进行比较，以确保它们匹配 验证正确的数据被提取并被加载到HDFS正确的位置 该阶段可以使用工具 Talend 或 Datameer，进行数据阶段验证。 MapReduce 验证大数据测试的第二步是MapReduce的验证。在这个阶段，测试者在每个节点上进行业务逻辑验证，然后在运行多个节点后验证它们，确保如下操作的正确性： Map与Reduce进程正常工作 在数据上实施数据聚合或隔离规则 生成键值对 在执行Map和Reduce进程后验证数据 输出阶段验证大数据测试的最后或第三阶段是输出验证过程。生成输出数据文件，同时把文件移到一个EDW(Enterprise Data Warehouse:企业数据仓库)中或着把文件移动到任何其他基于需求的系统中。在第三阶段的活动包括： 检查转换(Transformation)规则被正确应用 检查数据完整性和成功的数据加载到目标系统中 通过将目标数据与HDFS文件系统数据进行比较来检查没有数据损坏 架构测试Hadoop处理大量数据，并且资源非常密集。因此，架构测试对于确保大数据项目的成功至关重要。设计不良或不正确的系统可能会导致性能下降，并且系统可能无法满足要求。至少应在Hadoop环境中完成 性能 和 故障转移 测试服务。 性能测试 包括测试作业完成时间，内存利用率，数据吞吐量和类似的系统指标。 故障转移 测试服务的目的是验证数据节点发生故障时无缝地进行数据处理 性能测试大数据性能测试包括两个主要措施 数据提取和遍历：在此阶段，测试人员将验证快速系统如何使用各种数据源中的数据。测试涉及识别队列可以在给定时间范围内处理的其他消息。它还包括可以将数据插入基础数据存储库的速度，例如向Mongo和Cassandra数据库的插入率。 数据处理：它涉及验证查询或映射归约作业的执行速度。它还包括当基础数据存储区填充在数据集中时，单独测试数据处理。例如，在基础HDFS上运行Map Reduce作业。 注：由于系统由多个组件组成，并且必须单独测试每个组件。例如，对消息进行索引和使用的速度、MapReduce作业、查询性能和搜索等。 性能测试方法大数据应用性能测试涉及大量结构化和非结构化数据的测试，并且需要特定的测试方法来测试这些海量数据。 测试步骤 过程从设置要测试性能的大数据群集开始 确定和设计相应的工作量 准备个人客户(自定义脚本创建) 执行测试并分析结果(如果不满足目标，则调整组件并重新执行) 最佳配置 性能测试的参数需要进行性能测试验证的各种参数是： 数据存储：数据如何存储在不同的节点中 提交日志：允许增长的提交日志有多大 并发性：有多少个线程可以执行写入和读取操作 缓存：调整缓存设置“行缓存”和“键缓存”。 超时：连接超时值，查询超时值等 JVM参数：堆大小，GC收集算法等 地图降低性能：排序，合并等 消息队列：消息速率，大小等 测试环境需求测试环境需要取决于您正在测试的应用程序的类型。对于大数据测试，测试环境应包含 它应该有足够的空间用于存储和处理大量数据 它应该具有包含分布式节点和数据的集群 它应具有最低的CPU和内存利用率以保持高性能 大数据测试 与 传统数据库测试 对比 类型 传统数据库测试 大数据测试 数据 使用结构化数据;测试方法定义明确且经过时间检验;测试人员可以选择手动执行采样策略或通过自动化工具选择”详尽验证”策略 使用结构化和非结构化数据;测试方法类似开发工作;大数据中的采样策略是一个挑战 环境 由于文件大小有限，因此不需要特殊的测试环境 由于数据量大和文件大（HDFS），因此需要特殊的测试环境 验证工具 使用基于Excel的宏或基于UI的自动化工具 没有定义的工具，范围从MapReduce到HiveQL等编程工具 大数据场景中使用的工具 类型 组件 数据处理 Apache Flink Apache Spark 消息系统 Apache Kafka Apache Pulsar 数据查询引擎 Apache Hive Apache SparkSQL Apache Impala Elasticsearch 数据采集 Apache Flume Logstash 数据存储 Apache HBase HDFS 数据转换、同步 Apache Sqoop 资源管理 Apache Hadoop YARN 应用协调 Apache Zookeeper 数据分析和报告工具 Apache Zeppelin Cloudera Hue 大数据测试中的挑战 自动化:大数据的自动化测试需要具有专业技术知识的人员。自动化工具不具备处理测试期间出现的意外问题的能力 虚拟化:这是测试不可或缺的阶段之一。虚拟机延迟会在实时大数据测试中造成时序问题。在大数据中管理图像也很麻烦。 大数据集 需要验证更多数据，并且需要更快地进行处理 需要自动化测试工作 需要能够在不同平台上进行测试 性能测试挑战 多种技术：每个子组件都属于不同的技术，并且需要单独进行测试 特定工具不可用：没有单个工具可以执行端到端测试。例如，NoSQL可能不适用于消息队列 测试脚本：设计测试方案和测试用例需要高度的脚本编写 测试环境：由于数据量大，需要特殊的测试环境 监视解决方案：存在可以监视整个环境的有限解决方案 诊断解决方案：需要开发自定义解决方案来挖掘性能瓶颈区域 More info: 大数据测试]]></content>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据（二）大数据的流程和应用]]></title>
    <url>%2F2019%2F05%2F15%2F%E5%A4%A7%E6%95%B0%E6%8D%AE02%2F</url>
    <content type="text"><![CDATA[本文章主要介绍大数据业务流程以及应用。 Quick Guide 大数据业务流程 数据采集 数据提取 数据应用 数据采集数据采集就是使用不同的方式去各种数据源采集数据 数据来源 外部 内部 内部 数据类型 公开的信息 用户的行为信息 用户信息 获取方式 爬虫 埋点 业务数据库 数据提取 数据清洗：数据由于来自各个源，为了使用方便和隐私考虑，需要清洗 判断是否加密信息 加密信息解密，获取明文数据 脱敏数据，跳过清洗 数据规则：例如去掉空格和一些特殊字符，让数据变得有效和统一规范 数据统一加密，生成衍生加密表 企业数仓：清洗的数据最后统一存储到企业数仓,在企业数仓通过数据整理分类和分析,提取有效的应用信息 数据分类,形成基础信息表 通过基础信息表,形成综合信息表(宽表 维度表) 通过业务综合表进行一定数据计算形成应用标签存储数据集市 数据应用 通过业务综合表进行一定数据计算（算法模型/决策）形成应用标签存储数据集市 通过接口查询或者报表展示 大数据数据流 大数据应用 精准营销: 从数据集市获取用户特征(行为/角色标签) 组合不同的特征形成不一样受众群体 针对不同的受众群体制定不同的策略去营销:,通过不同方式(短信/邮件/软件的消息和广告位)去推荐商品 风险控制 从数据获取用户的风险信息 通过风控策略（决策引擎）把用户划分成不同风险级别，采取不同风险控制 数据报表 从数据集市获取产品和公司的运行信息 通过不同图表去展示，反应产品和公司的状况]]></content>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据（一）大数据的基本概念]]></title>
    <url>%2F2019%2F04%2F15%2F%E5%A4%A7%E6%95%B0%E6%8D%AE01%2F</url>
    <content type="text"><![CDATA[本文章主要介绍大数据的基本概念。 Quick Guide什么是数据计算机执行中操作的字符或符号，可以以电信号的形式存储和传输，并记录在磁、光或机械记录介质上。 什么是大数据大数据是数量巨大且随时间呈指数增长的数据集合。此类数据是如此庞大和复杂，以至于传统的数据管理工具都无法对其进行存储或有效处理。 大数据示例 在 纽约股票交易所 产生约 一兆兆字节 每天新的贸易数据。 统计数据显示，每天有 500 TB 以上的新数据被摄入社交媒体网站 Facebook 的数据库中 。这些数据主要通过照片和视频上传，消息交换，发表评论等方式生成。 单个 Jet 引擎 可以在 30分钟 的飞行时间内生成 10 TB 以上的数据 。每天有成千上万的航班，因此数据生成量可达 PB级。 大数据类型结构化的可以以固定格式存储，访问和处理的任何数据称为结构化数据。关系数据库管理系统中存储的 数据是 “结构化”数据的一个示例 。 数据库中的“雇员”表是结构化数据的示例 员工ID 员工姓名 性别 部门 Salary_In_lacs 2365 拉杰什·库尔卡尼（Rajesh Kulkarni） 男 金融 650000 3398 Pratibha Joshi 女 管理员 650000 7465 舒希尔·罗伊 男 管理员 500000 7500 Shubhojit Das 男 金融 500000 7699 普里亚·桑（Priya Sane） 女 金融 550000 非结构化任何形式或结构未知的数据都归为非结构化数据。非结构化数据的典型示例是包含简单文本文件，图像，视频等的组合的异构数据源。 非结构化数据的示例如下图： 半结构化半结构化数据可以包含两种形式的数据。我们可以将半结构化数据看作是结构化的形式，但实际上它不是通过例如关系型数据库中的表来定义的。半结构化数据的示例如下图： 12345&lt;rec&gt; &lt;name&gt;闷闷不乐&lt;/ name&gt; &lt;sex&gt;男&lt;/ sex&gt; &lt;age&gt; 35 &lt;/ age&gt; &lt;/ rec&gt;&lt;rec&gt; &lt;name&gt; Seema R &lt;/ name&gt; &lt;sex&gt;女&lt;/ sex&gt; &lt;age&gt; 41 &lt;/ age&gt; &lt;/ rec&gt;&lt;rec&gt; &lt;name&gt; Satish Mane &lt;/ name&gt; &lt;sex&gt; Male &lt;/ sex&gt; &lt;age&gt; 29 &lt;/ age&gt; &lt;/ rec&gt;&lt;rec&gt; &lt;name&gt; Subrato Roy &lt;/ name&gt; &lt;sex&gt; Male &lt;/ sex&gt; &lt;age&gt; 26 &lt;/ age&gt; &lt;/ rec&gt;&lt;rec&gt; &lt;name&gt; Jeremiah J &lt;/ name&gt; &lt;sex&gt; Male &lt;/ sex&gt; &lt;age&gt; 35 &lt;/ age&gt; &lt;/ rec&gt; 大数据的特征 大量: 随着信息技术的高速发展，数据开始爆发性增长，存储单位从早期的KB和MB,到后面的GB到TB，乃至现在的PB、EB级别。 多样性 : 广泛的数据来源决定了大数据形式的多样性。在早期，电子表格和数据库是大多数应用程序考虑的唯一数据源。如今，分析应用程序中还考虑了电子邮件、照片、视频、监视设备、PDF和音频等形式的数据。各种各样的非结构化数据给存储，挖掘和分析数据带来了某些问题。 高速: 大数据的产生非常迅速，主要通过互联网传输，需要数据的生成和处理速度可以满足需求。生活中每个人都离不开互联网，也就是说每天每个人都在向大数据提供大量的资料。并且这些数据是需要及时处理的，因为花费大量资本去存储作用较小的历史数据是非常不划算的，对于一个平台而言，也许保存的数据只有过去几天或者一个月之内，再远的数据就要及时清理，不然代价太大。基于这种情况，大数据对处理速度有非常严格的要求，服务器中大量的资源都用于处理和计算数据，很多平台都需要做到实时分析。数据无时无刻不在产生，谁的速度更快，谁就有优势。 价值: 现实世界所产生的数据中，有价值的数据所占比例很小。相比于传统的小数据，大数据最大的价值在于通过从大量不相关的各种类型的数据中，挖掘出对未来趋势与模式预测分析有价值的数据，并通过机器学习方法、人工智能方法或数据挖掘方法深度分析，发现新规律和新知识，并运用于农业、金融、医疗等各个领域，从而最终达到改善社会治理、提高生产效率、推进科学研究的效果。 大数据处理的优势 企业可以在决策时利用外部情报 改善客户服务 及早发现产品和服务的风险 更高的运营效率]]></content>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker（十）Kubernetes]]></title>
    <url>%2F2019%2F03%2F11%2FDocker10%2F</url>
    <content type="text"><![CDATA[Kubernetes（k8s）是Google(基于borg)开源的容器集群管理系统，使用Docker对应用程序包装、实例化、运行，能方便地管理跨机器运行容器化的应用，自我修复机制使得容器集群总是运行在用户期望的状态。本文章介绍 Kubernetes 。 Quick GuideKubernetes的名字来自希腊语，意思是“舵手” 或 “领航员”。K8s是将8个字母“ubernete”替换为“8”的缩写。 可移植: 支持公有云，私有云，混合云，多重云（multi-cloud） 可扩展: 模块化, 插件化, 可挂载, 可组合 自动化: 自动部署，自动重启，自动复制，自动伸缩/扩展 集群架构 Master集群控制节点，master节点上运行着一组关键的进程 Kubernetes API Server(kube-apiserver):集群控制的入口进程,提供 HTTP Rest 接口的关键服务程序(所有资源增、删、改、查等操作的唯一入口) Kubernetes Controller Manager(kube-controller-manager):所有资源对象的自动化控制中心 Kubernetes Scheduler(kube-scheduler):资源调度(pod)的进程 Etcd Server:Kubernetes 里所有资源对象的数据全部是保持在etcd中 NodeNode是Master管理的工作主机，可以是物理主机、VM等，运行Kubelet、kube-proxy和docker Engine kubelet: pod对应容器的创建、暂停等任务 kube-proxy: k8s service 的通信与负载均衡机制的重要组件 Docker Engine:dokcer 引擎，负责本机容器的创建与管理 其他概念 Pods：最小部署单元，可包含多个容器，是连接在一起的容器组合并共享文件卷。一个Pod中的多个容器应用通常是紧密耦合的，Pod在Node上被创建、启动或者销毁。 Services：抽象服务出口。可以看作一组提供相同服务的Pod的对外访问接口，就像一个基础版本的负载均衡器,Service作用于哪些Pod是通过Label Selector来定义的 拥有一个指定的名字（比如my-mysql-server） 拥有一个虚拟IP（Cluster IP、Service IP或VIP）和端口号，销毁之前不会改变，只能内网访问 NodePort:每个Node的真实端口，能够访问Node的客户端就能通过这个端口访问到内部的Service了 Namespace:命名空间将对象逻辑上分配到不同Namespace，可以是不同的项目、用户等区分管理，并设定控制策略，从而实现多租户。 Volume ：Pod中能够被多个容器访问的共享目录，其生命周期与Pod相同跟容器无关。 EmptyDir，Pod分配到Node时创建的，初始内容为空，Pod从Node中移除时EmptyDir数久删 - 除。主要用于临时空间、CheckPoint临时保存目录等 hostPath，在Pod上挂载宿主机上的文件或目录，主要用于需要永久保存的 gcePersistentDisk,使用谷歌计算引擎上永久磁盘上的文件，写入数据永久保存。 awsElasticBlockStore，使用Amazon提供的EBS Volume nfs，使用NFS(网络文件系统)提供的共享目录 iscsi，使用iSCSI设备 glusterfs，使用开源GlusterFS网络文件系统 rbd，使用Linux块设备共享存储 gitRepo，通过挂载一个空目录，从Git库clone一个&gt; - git repository给Pod使用 secret，一个secret volume用于为Pod提供加密的信息 persistent Volume, “网络存储”，独立于“计算资源”而存在的实体资源，可以看做一个与Kubernetes无关的网盘 Labels： Label以key/value形式附加到Pos、Service、RC、Node等上面，每个对象可以定义多个label，以提供Label Selector来选择对象， Label Selector有两种形式： 基于等式，name=redis-slave选择k/v都相等的，env!=production选择k=env但是v!=production的 基于集合，name [not] in (redis-master,redis-slave)，类似于SQL中in Replication controllers： 管理 Pods 的生命周期。它们确保指定数量的 Pods 会一直运行，还有实现资源伸缩。 定义RC实现Pod的创建与副本数量的自动控制 RC 通过Lable Selector机制实现对副本的自动控制 通过改变RC的Pod副本数量，实现Pod的扩容或缩容 通过改变RC里Pod模板中的镜像版本，实现Pod的滚动更新 Deployment: 1.2引入，为了更好地解决pod的编排问题，内部使用了Replica Set 实现；它相对于RC的最大的升级是可以随时知道当前Pod部署的进度 Horizontal Pod Autocaler(HPA): Pod横向自动扩容，通过追踪分析RC控制的所有目标Pod的负载变化情况，确定是否需要针对性地调整目标Pod的副本数 Annotation：与Lable类似，也使用key/value 键值对的形式定义，不同于Lable定义Kubernetes的元数据，它是用户任意定义的附加信息，以便于外部工具进行查找 组件 Kubernetes主要由以下几个核心组件组成： etcd:保存了整个集群的状态； apiserver:提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制； controller manager:负责维护集群的状态，比如故障检测、自动扩展、滚动更新等； scheduler:负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上； kubelet:负责维护容器的生命周期，同时也负责Volume（CVI）和网络（CNI）的管理； Container runtime:负责镜像管理以及Pod和容器的真正运行（CRI）； kube-proxy:负责为Service提供cluster内部的服务发现和负载均衡； 除了核心组件，还有一些推荐的Add-ons： kube-dns:负责为整个集群提供DNS服务 Ingress Controller:为服务提供外网入口 Heapster:提供资源监控 Dashboard:提供GUI Federation:提供跨可用区的集群 分层架构 核心层：Kubernetes最核心的功能，对外提供API构建高层的应用，对内提供插件式应用执行环境 应用层：部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS解析等） 管理层：系统度量（如基础设施、容器和网络的度量），自动化（如自动扩展、动态Provision等）以及策略管理（RBAC、Quota、PSP、NetworkPolicy等） 接口层：kubectl命令行工具)、客户端SDK以及集群联邦 生态系统：在接口层之上的庞大容器集群管理调度的生态系统，可以划分为两个范畴 Kubernetes外部：日志、监控、配置管理、CI、CD、Workflow、FaaS、OTS应用、ChatOps等 Kubernetes内部：CRI、CNI、CVI、镜像仓库、Cloud Provider、集群自身的配置和管理等 使用步骤123456789101112131415161718# 创建集群kubeadm init --apiserver-advertise-address=&lt;master_ip&gt; --kubernetes-version=&lt;kube_version&gt; --pod-network-cidr=&lt;ip/netmasks&gt; # 初始化kubeadm reset # 还原kubeadm init或join操作kubectl join --token &lt;node&gt; &lt;master_ip:master_port&gt; # 在子节点执行,加入这个集群# 部署应用kubectl run &lt;apply_name&gt; \ --image=&lt;image&gt; \ --port=&lt;nodeport&gt;# 发布应用kubectl expose delpoyment &lt;apply_name&gt; --type="NodePort" --port &lt;nodeport&gt;# 扩展应用kubectl scale delpoyment/&lt;apply_name&gt; --replicas=2# 更新应用kubectl set image delpoyment/&lt;apply_name&gt; &lt;apply_name&gt;=&lt;image&gt; 常用命令 1.help：获取命令的相关帮助信息 1kubectl &lt;command&gt; --help 2.get：用于获取集群的一个或一些resource信息 1234567891011# 格式kubectl get [(-o|--output=)json|yaml|wide|custom-columns=...|custom-columns-file=...|go-template=...|go-template-file=...|jsonpath=...|jsonpath-file=...] (TYPE [NAME | -l label] | TYPE/NAME ...) [flags]# 获取pod信息kubectl get pod -o wide# 获取namespace信息kubectl get namespace# 查看rc和service列表kubectl get rc,service 3.describe：类似于get，get获得的是resource状态信息，describe获得的是resource集群相关的信息。 1234567891011121314# 获取pod信息kubectl describe pod# 获取namespace信息kubectl describe namespace# 显示Node的详细信息kubectl describe nodes &lt;node-name&gt;# 显示Pod的详细信息kubectl describe pods/&lt;pod-name&gt;# 显示由RC管理的Pod的信息kubectl describe pods &lt;rc-name&gt; 4.create：通过配置文件名或stdin创建集群resource 12345678910111213141516171819# 格式kubectl create -f &lt;file_name&gt;kubectl create clusterrole NAME --verb=verb --resource=resource.group [--resource-name=resourcename] [--dry-run] # 创建一个ClusterRolekubectl create clusterrolebinding NAME --clusterrole=NAME [--user=username] [--group=groupname] [--serviceaccount=namespace:serviceaccountname] [--dry-run] # 为特定的ClusterRole创建ClusterRoleBindingkubectl create configmap NAME [--from-file=[key=]source] [--from-literal=key1=value1] [--dry-run] # 根据配置文件、目录或指定的literal-value创建configmap kubectl create deployment NAME --image=image [--dry-run] # 创建具有指定名称的deployment kubectl create namespace NAME [--dry-run] # 创建一个具有指定名称的namespacekubectl create poddisruptionbudget NAME --selector=SELECTOR --min-available=N [--dry-run] # 使用指定的name、selector和所需的最小pod数量，创建一个pod disruption budgetkubectl create quota NAME [--hard=key1=value1,key2=value2] [--scopes=Scope1,Scope2] [--dry-run=bool] # 创建具有指定名称、hard限制和可选scopes的resourcequotakubectl create role NAME --verb=verb --resource=resource.group/subresource [--resource-name=resourcename] [--dry-run] # 使用单一规则创建Rolekubectl create rolebinding NAME --clusterrole=NAME|--role=NAME [--user=username] [--group=groupname] [--serviceaccount=namespace:serviceaccountname] [--dry-run] # 为特定Role或ClusterRole创建RoleBindingkubectl create service &lt;clusterip|externalname|loadbalancer|nodeport|account&gt; # 使用指定的子命令创建 Service服务kubectl create secret &lt;docker-registry|generic|tls&gt; # 使用指定的子命令创建 secret# 根据yaml配置文件一次性创建service和rckubectl create -f my-service.yaml -f my-rc.yaml# 根据&lt;directory&gt;目录下所有.yaml、.yml、.json文件的定义进行创建操作kubectl create -f &lt;directory&gt; 5.replace：对已有资源进行更新、替换 12345# 格式kubectl replace -f &lt;file_name&gt;# 根据yaml配置文件更新nignxkubectl replace -f rc-nginx.yaml 6.patch：在容器运行时，直接对容器进行修改属性 12345# 格式kubectl patch (-f FILENAME | TYPE NAME) -p PATCH# 修改label为nginx-3kubectl patch pod rc-nginx-2-kpiqt -p '&#123;"metadata":&#123;"labels":&#123;"app":"nginx-3"&#125;&#125;&#125;' 7.edit：在线编辑resource源的操作 12345# 格式kubectl edit (RESOURCE/NAME | -f FILENAME)# 获取pod信息kubectl edit po rc-nginx-btv4j 8.delete：删除资源对象 1234567891011# 格式kubectl delete ([-f FILENAME] | TYPE [(NAME | -l label | --all)])# 基于Pod.yaml定义的名称删除Podkubectl delete -f pod.yaml# 删除所有包含某个label的Pod和servicekubectl delete pods,services -l name=&lt;label-name&gt;# 删除所有Podkubectl delete pods --all 9.apply：在原有resource的基础上进行更新，还会resource中添加一条注释，标记当前的apply 10.logs：用于显示pod运行中，容器内程序输出到标准输出的内容 12# 获取pod的日志kubectl logs &lt;pod_name&gt; 11.rolling-update:创建了一个新的RC， 然后一次更新一个pod方式逐步使用新的PodTemplate，最终实现Pod滚动更新，new-controller.json需要与之前RC在相同的namespace下 12345# 格式kubectl rolling-update OLD_CONTROLLER_NAME ([NEW_CONTROLLER_NAME] --image=NEW_CONTAINER_IMAGE | -f NEW_CONTROLLER_SPEC)# 根据yaml模板更新rc-nginx-2kubectl rolling-update rc-nginx-2 -f rc-nginx.yaml 12.scale:扩容或缩容 Deployment、ReplicaSet、Replication Controller或 Job 中Pod数量 12345# 格式kubectl scale [--resource-version=version] [--current-replicas=count] --replicas=COUNT (-f FILENAME | TYPE NAME)# 设置pod的数量为4(原本数量小于4为扩容,大于为缩容)kubectl scale rc rc-nginx-3 —replicas=4 13.exec：执行容器的命令 12345678# 执行Pod的data命令，默认是用Pod中的第一个容器执行kubectl exec &lt;pod-name&gt; data# 指定Pod中某个容器执行data命令kubectl exec &lt;pod-name&gt; -c &lt;container-name&gt; data# 通过bash获得Pod中某个容器的TTY，相当于登录容器kubectl exec -it &lt;pod-name&gt; -c &lt;container-name&gt; bash 14.attach:查看容器中以daemon形式运行的进程的输出 12# 获取pod的容器输出吸血流kubectl attach &lt;pod-name&gt; -c &lt;containers_name&gt; 15.run：创建并运行容器镜像、deployment 和job 12345# 格式kubectl run NAME --image=image [--env="key=value"] [--port=port] [--replicas=replicas] [--dry-run=bool] [--overrides=inline-json] [--command] -- [COMMAND] [args...]# 启动nginx实例kubectl run nginx --image=nginx 16.expose：指定deployment、service、replica set、replication controller或pod ，并使用该资源的选择器作为指定端口上新服务的选择器 12345# 格式kubectl expose (-f FILENAME | TYPE NAME) [--port=port] [--protocol=TCP|UDP] [--target-port=number-or-name] [--name=name] [--external-ip=external-ip-of-service] [--type=type]# 为RC的nginx创建service，并通过Service的80端口转发至容器的8000端口上kubectl expose rc nginx --port=80 --target-port=8000 17.annotate：更新一个或多个资源的Annotations信息 12345# 格式kubectl annotate [--overwrite] (-f FILENAME | TYPE NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--resource-version=version]# 根据“pod.json”中的type和name更新pod的annotationkubectl annotate -f pod.json description='my frontend' 18.autoscale：使用 autoscaler 自动设置在kubernetes集群中运行的pod数量 12345# 格式kubectl autoscale (-f FILENAME | TYPE NAME | TYPE/NAME) [--min=MINPODS] --max=MAXPODS [--cpu-percent=CPU] [flags]# 使用RC“foo”设定，使其Pod的数量介于1和5之间，CPU使用率维持在80％kubectl autoscale rc foo --max=5 --cpu-percent=80 19.convert：转换配置文件为不同的API版本，支持YAML和JSON格式 12345# 格式kubectl convert -f &lt;file_name&gt;# 将“pod.yaml”转换为最新版本并打印到stdoutkubectl convert -f pod.yaml 20.label：更新资源上的 label 12345# 格式kubectl label [--overwrite] (-f FILENAME | TYPE NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--resource-version=version]# 给名为foo的Pod添加label unhealthy=true。kubectl label pods foo unhealthy=true 21.rollout：对资源进行管理 12345# 格式kubectl rollout &lt;history|pause|resume|status|undo&gt;# 回滚到之前的deploymentkubectl rollout undo deployment/abc 22.set：配置应用资源 12345# 格式kubectl set &lt;image|resources|selector|subject&gt;# 将deployment的nginx容器cpu限制为“200m”，将内存设置为“512Mi”kubectl set resources deployment nginx -c=nginx --limits=cpu=200m,memory=5 More info: 交互教程 kubernetes]]></content>
      <tags>
        <tag>docker</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker（九）Docker 命令]]></title>
    <url>%2F2019%2F02%2F16%2FDocker09%2F</url>
    <content type="text"><![CDATA[在本章介绍 Docker 命令。 Quick Guide容器生命周期管理rundocker run ：创建一个新的容器并运行一个命令 1docker run [OPTIONS] IMAGE [COMMAND] [ARG...] OPTIONS说明： -a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项； -d: 后台运行容器，并返回容器ID； -i: 以交互模式运行容器，通常与 -t 同时使用； -P: 随机端口映射，容器内部端口随机映射到主机的端口 -p: 指定端口映射，格式为：主机(宿主)端口:容器端口 -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用； –name=”nginx-lb”: 为容器指定一个名称； –dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致； –dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致； -h “mars”: 指定容器的hostname； -e username=”ritchie”: 设置环境变量； –env-file=[]: 从指定文件读入环境变量； –cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行； -m : 设置容器使用内存最大值； –net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型； –link=[]: 添加链接到另一个容器； –expose=[]: 开放一个端口或一组端口； –volume , -v: 绑定一个卷 12# 使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。docker run --name mynginx -d nginx:latest start/stop/restartdocker start :启动一个或多个已经被停止的容器 docker stop :停止一个运行中的容器 docker restart :重启容器 123docker start [OPTIONS] CONTAINER [CONTAINER...]docker stop [OPTIONS] CONTAINER [CONTAINER...]docker restart [OPTIONS] CONTAINER [CONTAINER...] 123456# 启动已被停止的容器myrunoobdocker start myrunoob# 停止运行中的容器myrunoobdocker stop myrunoob# 重启容器myrunoobdocker restart myrunoob killdocker kill :杀掉一个运行中的容器。 1docker kill [OPTIONS] CONTAINER [CONTAINER...] OPTIONS说明： -s : 向容器发送一个信号 12# 杀掉运行中的容器mynginxrunoob@runoob:~$ docker kill -s KILL mynginx rmdocker rm ： 删除一个或多个容器。 1docker rm [OPTIONS] CONTAINER [CONTAINER...] OPTIONS说明： -f : 通过 SIGKILL 信号强制删除一个运行中的容器。 -l : 移除容器间的网络连接，而非容器本身。 -v : 删除与容器关联的卷。 12# 强制删除容器 db01、db02docker rm -f db01 db02 pause/unpausedocker pause :暂停容器中所有的进程。 docker unpause :恢复容器中所有的进程。 12docker pause [OPTIONS] CONTAINER [CONTAINER...]docker unpause [OPTIONS] CONTAINER [CONTAINER...] 1234# 暂停数据库容器db01提供服务。docker pause db01# 恢复数据库容器db01提供服务。docker unpause db01 createdocker create ： 创建一个新的容器但不启动它 1docker create [OPTIONS] IMAGE [COMMAND] [ARG...] 12# 使用docker镜像nginx:latest创建一个容器,并将容器命名为myrunoobrunoob@runoob:~$ docker create --name myrunoob nginx:latest execdocker exec ： 在运行的容器中执行命令 1docker exec [OPTIONS] CONTAINER COMMAND [ARG...] OPTIONS说明： -d : 分离模式: 在后台运行 -i : 即使没有附加也保持STDIN 打开 -t : 分配一个伪终端 1234# 在容器 mynginx 中以交互模式执行容器内 /root/runoob.sh 脚本:runoob@runoob:~$ docker exec -it mynginx /bin/sh /root/runoob.sh# 在容器 mynginx 中开启一个交互模式的终端:runoob@runoob:~$ docker exec -i -t mynginx /bin/bash 容器操作psdocker ps : 列出容器 1docker ps [OPTIONS] OPTIONS说明： -a :显示所有的容器，包括未运行的。 -f :根据条件过滤显示的内容。 –format :指定返回值的模板文件。 -l :显示最近创建的容器。 -n :列出最近创建的n个容器。 –no-trunc :不截断输出。 -q :静默模式，只显示容器编号。 -s :显示总的文件大小。 12345# 列出所有在运行的容器信息runoob@runoob:~$ docker psCONTAINER ID IMAGE COMMAND ... PORTS NAMES09b93464c2f7 nginx:latest "nginx -g 'daemon off" ... 80/tcp, 443/tcp myrunoob96f7f14e99ab mysql:5.6 "docker-entrypoint.sh" ... 0.0.0.0:3306-&gt;3306/tcp mymysql 输出详情介绍： CONTAINER ID: 容器 ID。 IMAGE: 使用的镜像。 COMMAND: 启动容器时运行的命令。 CREATED: 容器的创建时间。 STATUS: 容器状态。 PORTS: 容器的端口信息和使用的连接类型（tcp\udp）。 NAMES: 自动分配的容器名称。 状态有7种： created（已创建） restarting（重启中） running（运行中） removing（迁移中） paused（暂停） exited（停止） dead（死亡） inspectdocker inspect : 获取容器/镜像的元数据。 1docker inspect [OPTIONS] NAME|ID [NAME|ID...] OPTIONS说明： -f :指定返回值的模板文件。 -s :显示总的文件大小。 –type :为指定类型返回JSON。 12345678910111213141516171819202122232425# 获取镜像mysql:5.6的元信息。runoob@runoob:~$ docker inspect mysql:5.6[ &#123; "Id": "sha256:2c0964ec182ae9a045f866bbc2553087f6e42bfc16074a74fb820af235f070ec", "RepoTags": [ "mysql:5.6" ], "RepoDigests": [], "Parent": "", "Comment": "", "Created": "2016-05-24T04:01:41.168371815Z", "Container": "e0924bc460ff97787f34610115e9363e6363b30b8efa406e28eb495ab199ca54", "ContainerConfig": &#123; "Hostname": "b0cf605c7757", "Domainname": "", "User": "", "AttachStdin": false, "AttachStdout": false, "AttachStderr": false, "ExposedPorts": &#123; "3306/tcp": &#123;&#125; &#125;,... 123# 获取正在运行的容器mymysql的 IP。runoob@runoob:~$ docker inspect --format='&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;' mymysql172.17.0.3 topdocker top :查看容器中运行的进程信息，支持 ps 命令参数。 1docker top [OPTIONS] CONTAINER [ps OPTIONS] 1234# 查看容器mymysql的进程信息。runoob@runoob:~/mysql$ docker top mymysqlUID PID PPID C STIME TTY TIME CMD999 40347 40331 18 00:58 ? 00:00:02 mysqld attachdocker attach :连接到正在运行中的容器。 语法1docker attach [OPTIONS] CONTAINER 123# 容器mynginx将访问日志指到标准输出，连接到容器查看访问信息。runoob@runoob:~$ docker attach --sig-proxy=false mynginx192.168.239.1 - - [10/Jul/2016:16:54:26 +0000] "GET / HTTP/1.1" 304 0 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36" "-" eventsdocker events : 从服务器获取实时事件 1docker events [OPTIONS] OPTIONS说明： -f ：根据条件过滤事件； –since ：从指定的时间戳后显示所有事件; –until ：流水时间显示到指定的时间为止； 1234567# 显示docker 2016年7月1日后的所有事件。runoob@runoob:~/mysql$ docker events --since="1467302400"2016-07-08T19:44:54.501277677+08:00 network connect 66f958fd13dc4314ad20034e576d5c5eba72e0849dcc38ad9e8436314a4149d4 (container=b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64, name=bridge, type=bridge)2016-07-08T19:44:54.723876221+08:00 container start b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (image=nginx:latest, name=elegant_albattani)2016-07-08T19:44:54.726110498+08:00 container resize b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (height=39, image=nginx:latest, name=elegant_albattani, width=167)2016-07-08T19:46:22.137250899+08:00 container die b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (exitCode=0, image=nginx:latest, name=elegant_albattani)... logsdocker logs : 获取容器的日志 1docker logs [OPTIONS] CONTAINER OPTIONS说明： -f : 跟踪日志输出 –since :显示某个开始时间的所有日志 -t : 显示时间戳 –tail :仅列出最新N条容器日志 1234567# 跟踪查看容器mynginx的日志输出。runoob@runoob:~$ docker logs -f mynginx192.168.239.1 - - [10/Jul/2016:16:53:33 +0000] "GET / HTTP/1.1" 200 612 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36" "-"2016/07/10 16:53:33 [error] 5#5: *1 open() "/usr/share/nginx/html/favicon.ico" failed (2: No such file or directory), client: 192.168.239.1, server: localhost, request: "GET /favicon.ico HTTP/1.1", host: "192.168.239.130", referrer: "http://192.168.239.130/"192.168.239.1 - - [10/Jul/2016:16:53:33 +0000] "GET /favicon.ico HTTP/1.1" 404 571 "http://192.168.239.130/" "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36" "-"192.168.239.1 - - [10/Jul/2016:16:53:59 +0000] "GET / HTTP/1.1" 304 0 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36" "-"... waitdocker wait : 阻塞运行直到容器停止，然后打印出它的退出代码。 1docker wait [OPTIONS] CONTAINER [CONTAINER...] 1docker wait CONTAINER exportdocker export :将文件系统作为一个tar归档文件导出到STDOUT。 1docker export [OPTIONS] CONTAINER OPTIONS说明： -o :将输入内容写到文件。 1234# 将id为a404c6c174a2的容器按日期保存为tar文件。runoob@runoob:~$ docker export -o mysql-`date +%Y%m%d`.tar a404c6c174a2runoob@runoob:~$ ls mysql-`date +%Y%m%d`.tarmysql-20160711.tar portdocker port :列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口。 1docker port [OPTIONS] CONTAINER [PRIVATE_PORT[/PROTO]] 123# 查看容器mynginx的端口映射情况。runoob@runoob:~$ docker port mymysql3306/tcp -&gt; 0.0.0.0:3306 容器rootfs命令commitdocker commit :从容器创建一个新的镜像。 1docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] OPTIONS说明： -a :提交的镜像作者； -c :使用Dockerfile指令来创建镜像； -m :提交时的说明文字； -p :在commit时，将容器暂停。 123# 将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。runoob@runoob:~$ docker commit -a "runoob.com" -m "my apache" a404c6c174a2 mymysql:v1 sha256:37af1236adef1544e8886be23010b66577647a40bc02c0885a6600b33ee28057 cpdocker cp :用于容器与主机之间的数据拷贝。 语法12docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH OPTIONS说明： -L :保持源目标中的链接 12# 将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下。docker cp /www/runoob 96f7f14e99ab:/www/ diffdocker diff : 检查容器里文件结构的更改。 1docker diff [OPTIONS] CONTAINER 123# 查看容器mymysql的文件结构更改。runoob@runoob:~$ docker diff mymysqlA /logs 镜像仓库logindocker login : 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub docker logout : 登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub 12docker login [OPTIONS] [SERVER]docker logout [OPTIONS] [SERVER] OPTIONS说明： -u :登陆的用户名 -p :登陆的密码 1234# 登陆到Docker Hubdocker login -u 用户名 -p 密码# 登出Docker Hubdocker logout pulldocker pull : 从镜像仓库中拉取或者更新指定镜像 1docker pull [OPTIONS] NAME[:TAG|@DIGEST] OPTIONS说明： -a :拉取所有 tagged 镜像 –disable-content-trust :忽略镜像的校验,默认开启 12# 从Docker Hub下载java最新版镜像。docker pull java pushdocker push : 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库 1docker push [OPTIONS] NAME[:TAG] OPTIONS说明： –disable-content-trust :忽略镜像的校验,默认开启 12# 上传本地镜像myapache:v1到镜像仓库中。docker push myapache:v1 searchdocker search : 从Docker Hub查找镜像 1docker search [OPTIONS] TERM OPTIONS说明： –automated :只列出 automated build类型的镜像； –no-trunc :显示完整的镜像描述； -s :列出收藏数不小于指定值的镜像。 123456789# 从Docker Hub查找所有镜像名包含java，并且收藏数大于10的镜像runoob@runoob:~$ docker search -s 10 javaNAME DESCRIPTION STARS OFFICIAL AUTOMATEDjava Java is a concurrent, class-based... 1037 [OK] anapsix/alpine-java Oracle Java 8 (and 7) with GLIBC ... 115 [OK]develar/java 46 [OK]isuper/java-oracle This repository contains all java... 38 [OK]lwieske/java-8 Oracle Java 8 Container - Full + ... 27 [OK]nimmis/java-centos This is docker images of CentOS 7... 13 [OK] 参数说明： NAME: 镜像仓库源的名称 DESCRIPTION: 镜像的描述 OFFICIAL: 是否 docker 官方发布 stars: 类似 Github 里面的 star，表示点赞、喜欢的意思。 AUTOMATED: 自动构建。 本地镜像管理imagesdocker images : 列出本地镜像。 1docker images [OPTIONS] [REPOSITORY[:TAG]] OPTIONS说明： -a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）； –digests :显示镜像的摘要信息； -f :显示满足条件的镜像； –format :指定返回值的模板文件； –no-trunc :显示完整的镜像信息； -q :只显示镜像ID。 12# 查看本地镜像列表runoob@runoob:~$ docker images rmidocker rmi : 删除本地一个或多少镜像。 1docker rmi [OPTIONS] IMAGE [IMAGE...] OPTIONS说明： -f :强制删除； –no-prune :不移除该镜像的过程镜像，默认移除； 12# 强制删除本地镜像 runoob/ubuntu:v4root@runoob:~# docker rmi -f runoob/ubuntu:v4 tagdocker tag : 标记本地镜像，将其归入某一仓库。 1docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG] 12# 将镜像ubuntu:15.10标记为 runoob/ubuntu:v3 镜像root@runoob:~# docker tag ubuntu:15.10 runoob/ubuntu:v3 builddocker build 命令用于使用 Dockerfile 创建镜像。 1docker build [OPTIONS] PATH | URL | - OPTIONS说明： –build-arg=[] :设置镜像创建时的变量； –cpu-shares :设置 cpu 使用权重； –cpu-period :限制 CPU CFS周期； –cpu-quota :限制 CPU CFS配额； –cpuset-cpus :指定使用的CPU id； –cpuset-mems :指定使用的内存 id； –disable-content-trust :忽略校验，默认开启； -f :指定要使用的Dockerfile路径； –force-rm :设置镜像过程中删除中间容器； –isolation :使用容器隔离技术； –label=[] :设置镜像使用的元数据； -m :设置内存最大值； –memory-swap :设置Swap的最大值为内存+swap，”-1”表示不限swap； –no-cache :创建镜像的过程不使用缓存； –pull :尝试去更新镜像的新版本； –quiet, -q :安静模式，成功后只输出镜像 ID； –rm :设置镜像成功后删除中间容器； –shm-size :设置/dev/shm的大小，默认值是64M； –ulimit :Ulimit配置。 –tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。 –network: 默认 default。在构建期间设置RUN指令的网络模式 12# 使用当前目录的 Dockerfile 创建镜像，标签为 runoob/ubuntu:v1docker build -t runoob/ubuntu:v1 . historydocker history : 查看指定镜像的创建历史。 1docker history [OPTIONS] IMAGE OPTIONS说明： -H :以可读的格式打印镜像大小和日期，默认为true； –no-trunc :显示完整的提交记录； -q :仅列出提交记录ID。 12# 查看本地镜像runoob/ubuntu:v3的创建历史root@runoob:~# docker history runoob/ubuntu:v3 savedocker save : 将指定镜像保存成 tar 归档文件。 1docker save [OPTIONS] IMAGE [IMAGE...] OPTIONS 说明： -o :输出到的文件。 12# 将镜像 runoob/ubuntu:v3 生成 my_ubuntu_v3.tar 文档runoob@runoob:~$ docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3 loaddocker load : 导入使用 docker save 命令导出的镜像。 1docker load [OPTIONS] OPTIONS 说明： –input , -i : 指定导入的文件，代替 STDIN。 –quiet , -q : 精简输出信息。 12# 导入镜像$ docker load &lt; busybox.tar.gz importdocker import : 从归档文件中创建镜像。 1docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]] OPTIONS说明： -c :应用docker 指令创建镜像； -m :提交时的说明文字； 12# 从镜像归档文件my_ubuntu_v3.tar创建镜像，命名为runoob/ubuntu:v4runoob@runoob:~$ docker import my_ubuntu_v3.tar runoob/ubuntu:v4 其他infodocker info : 显示 Docker 系统信息，包括镜像和容器数。。 1docker info [OPTIONS] versiondocker version :显示 Docker 版本信息。 1docker version [OPTIONS] OPTIONS说明： -f :指定返回值的模板文件。]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker（八）Docker API]]></title>
    <url>%2F2019%2F01%2F16%2FDocker08%2F</url>
    <content type="text"><![CDATA[Docker 本身提供了强大的API功能，我们可以通过访问Docker API来对Docker服务进行管理。在本章介绍如何使用Docker API。 Quick GuideDocker APIDocker提供了很多的API以便用户使用。这些API包含四个方面： Docker Registry API：提供了与存储Docker镜像的Docker Registry集成的功能。 Docker Hub API：：提供了与Docker HUB集成的功能 Docker OAuth API: 提供了与OAuth的认证授权的功能 Docker Remote API：：提供与Docker守护进程进行集成的功能 Docker Registry API 用途 方法 url 样例 取出镜像层 GET /v1/images/(image_id)/layer 插入镜像层 PUT /v1/images/(image_id)/layer 检索镜像 GET /v1/images/(image_id)/json 检索根镜像 GET /v1/images/(image_id)/ancestry 获取库里所有的标签或者指定标签 GET /v1/repositories/(namespace)/(repository)/tags 获取库里所有的标签或者指定标签 GET /v1/repositories/(namespace)/(repository)/tags/(tag*) 删除标签 DELETE /v1/repositories/(namespace)/(repository)/tags/(tag*) registry状态检查 GET /v1/_ping 创建镜像 POST /images/create 利用容器创建镜像 POST /commit 获取镜像清单 GET /images/json 导入指定的路径文件 POST /images/(name)/insert 删除镜像 DELETE /images/(name) 推送镜像到Registry POST /images/(name)/push Tag镜像 POST /images/(name)/tag 搜索镜像 GET /images/search 查看镜像历史 GET /images/(name)/history 构建镜像 POST /build Docker Hub API 用途 方法 url 样例 创建一个新的仓库 PUT /v1/repositories/(repo_name)/ 删除已经存在的仓库 DELETE /v1/repositories/(repo_name)/ 更新仓库镜像 PUT /v1/repositories/(repo_name)/images 从仓库中获取镜像 GET /v1/repositories/(repo_name)/images 授权 PUT /v1/repositories/(repo_name)/auth 创建用户仓库 PUT /v1/repositories/(namespace)/(repo_name)/ 删除用户仓库 DELETE /v1/repositories/(namespace)/(repo_name)/ 更新用户仓库镜像 PUT /v1/repositories/(namespace)/(repo_name)/images 从仓库中下载镜像 GET /v1/repositories/(namespace)/(repo_name)/images 验证用户登录 GET /v1/users 添加新用户 POST /v1/users 更新用户信息 PUT /v1/users/(username)/ Docker Remote API 用途 方法 url 样例 容器列表 GET /containers/json 创建新容器 POST /containers/create 监控容器 GET /containers/(id)/json 进程列表 GET /containers/(id)/top 容器日志 GET /containers/(id)/logs 导出容器 GET /containers/(id)/export 启动容器 POST /containers/(id)/start 停止容器 POST /containers/(id)/stop 重启容器 POST /containers/(id)/restart 终止容器 POST /containers/(id)/kill 注意事项 当Docker允许与访客容器目录共享而不限制其访问权限时，Docker Daemon的控制权应该只给授权用户。 REST API支持Unix sockets，从而防止了cross-site-scripting攻击。 REST API的HTTP接口应该在可信网络或者VPN下使用。 在服务器上单独运行Docker时，需要与其它服务隔离。 容器以非特权用户运行。 Apparmor、SELinux、GRSEC解决方案，可用于额外的安全层。 可以使用其它容器系统的安全功能。 More info:Docker API]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker（七）Docker Registry]]></title>
    <url>%2F2018%2F12%2F16%2FDocker07%2F</url>
    <content type="text"><![CDATA[Docker Registry 是所有仓库（包括共有和私有）以及工作流的中央Registry。本章介绍Docker Registry的工作角色。 Quick GuideDocker RegistryDocker Registry有三个角色，分别是index、registry和registry client。 1.Index:负责并维护有关用户帐户、镜像的校验以及公共命名空间的信息。它使用以下组件维护这些信息： Web UI 元数据存储 认证服务 符号化 2.Registry:是镜像和图表的仓库。然而，它没有一个本地数据库，也不提供用户的身份认证，由S3、云文件和本地文件系统提供数据库支持。此外，通过Index Auth service的Token方式进行身份认证。 Sponsor Registry：第三方的registry，供客户和Docker社区使用。 Mirror Registry：第三方的registry，只让客户使用。 Vendor Registry：由发布Docker镜像的供应商提供的registry。 Private Registry：通过设有防火墙和额外的安全层的私有实体提供的registry。 3.Registry Client:Docker充当registry客户端来负责维护推送和拉取的任务，以及客户端的授权。 工作流程详解 1:用户要获取并下载镜像。所涉及的步骤如下： 1.用户发送请求到index来下载镜像。 2.index 发出响应，返回三个相关部分信息： 该镜像所处的registry 该镜像包括所有层的校验 以授权为目的的Token &gt; 注意：当请求header里有X-Docker-Token时才会返回Token。而私人仓库需要基本的身份验证，对于公有仓库这一点不是强制性的。 3.用户通过响应后返回的Token和registry沟通，registry全权负责镜像，它用来存储基本的镜像和继承的层。 4.registry现在要与index证实该token是被授权的。 5.index会发送“true” 或者 “false”给registry，由此判定是否允许用户下载所需要的镜像。 2:用户想要将镜像推送到registry中。其中涉及的步骤如下： 1.用户发送附带证书的请求到index要求分配库名。 2.在认证成功，命名空间可用之后，库名也被分配。index发出响应返回临时的token。 3.镜像连带token，一起被推送到registry中。 4.registry与index证实token被授权，然后在index验证之后开始读取推送流。 5.该index由Docker校验的镜像更新。 3.用户想要从index或registry中删除镜像： 1.index接收来自Docker一个删除库的信号。 2.如果index对库验证成功，它将删除该库，并返回一个临时的token。 3.registry现在接收到带有该token的删除信号。 4.registry与index核实该token，然后删除库以及所有与其相关的信息。 5.Docker现在通知有关删除的index，然后index移除库的所有记录。 4：用户希望在没有index的独立模式中使用registry。 使用没有index的registry，这完全由Docker控制，它最适合于在私有网络中存储镜像。registry运行在一个特殊的模式里，此模式限制了registry与Docker index的通信。所有有关安全性和身份验证的信息需要用户自己注意。 5：用户想要在有index的独立模式中使用registry。 在这种情况下，一个自定义的index会被创建在私有网络里来存储和访问镜像的问题。然而，通知Docker有关定制的index是耗时的。 Docker提供一个有趣的概念chaining registries，从而，实现负载均衡和为具体请求而指定的registry分配。在接下来的Docker教程系列中，我们将讨论如何在上述每个情景中使用Docker Registry API ，以及深入了解Docker Security。]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker（六）Docker Swarm]]></title>
    <url>%2F2018%2F11%2F16%2FDocker06%2F</url>
    <content type="text"><![CDATA[Docker Swarm 和 Docker Compose 一样，都是 Docker 官方容器编排项目，但不同的是，Docker Compose 是一个在单个服务器或主机上创建多个容器的工具，而 Docker Swarm 则可以在多个服务器或主机上创建容器集群服务，对于微服务的部署，显然 Docker Swarm 会更加适合。 本文章介绍如何使用 Docker Swarm 。 Quick Guide 从 Docker 1.12.0 版本开始，Docker Swarm 已经包含在 Docker 引擎中（docker swarm），并且已经内置了服务发现工具，我们就不需要像之前一样，再配置 Etcd 或者 Consul 来进行服务发现配置了。 Swarm Deamon 只是一个调度器(Scheduler)和路由器(router),自身不运行容器，只接受Docker客户端发来的请求，调度适合的节点来运行容器。意味着即使Swarm由于某些原因挂掉了，集群中的节点也会照常运行，当Swarm重新恢复运行之后，他会收集重建集群信息。 运行机制 Swarm是典型的master-slave结构，通过发现服务来选举manager。manager是中心管理节点，各个node上运行agent接受manager的统一管理，集群会自动通过Raft协议分布式选举出manager节点，无需额外的发现服务支持，避免了单点的瓶颈问题，同时也内置了DNS的负载均衡和对外部负载均衡机制的集成支持。 下图是Docker Client使用Swarm对 集群(Cluster)进行调度使用。 基本概念 1.Swarm集群的管理和编排是使用嵌入docker引擎的SwarmKit，可以在docker初始化时启动swarm模式或者加入已存在的swarm。子命令有init, join, leave, update。（docker swarm –help查看帮助） 2.Node：node是加入到swarm集群中的一个docker引擎实体，可以在一台物理机上运行多个node。子命令有accept, promote, demote, inspect, update, tasks, ls, rm。（docker node –help查看帮助） manager node管理节点：执行集群的管理功能，维护集群的状态，选举一个leader节点去执行调度任务。 worker node工作节点：接收和执行任务。参与容器集群负载调度，仅用于承载task。 3.Service服务：一个服务是工作节点上执行任务的定义。创建一个服务，指定了容器所使用的镜像和容器运行的命令。子命令有create, inspect, update, remove, tasks。（docker service–help查看帮助） 4.Task任务：一个任务包含了一个容器及其运行的命令。task是service的执行实体，task启动docker容器并在容器中执行任务。 工作模式 Node Service 任务与调度 服务副本与全局服务 Swarm的调度策略Swarm在调度(scheduler)节点（leader节点）运行容器的时候，会根据指定的策略来计算最适合运行容器的节点，目前支持的策略有：spread, binpack, random. 1.Random顾名思义，就是随机选择一个Node来运行容器，一般用作调试用，spread和binpack策略会根据各个节点的可用的CPU, RAM以及正在运行的容器的数量来计算应该运行容器的节点。 2.Spread在同等条件下，Spread策略会选择运行容器最少的那台节点来运行新的容器，binpack策略会选择运行容器最集中的那台机器来运行新的节点。使用Spread策略会使得容器会均衡的分布在集群中的各个节点上运行，一旦一个节点挂掉了只会损失少部分的容器。 3.BinpackBinpack策略最大化的避免容器碎片化，就是说binpack策略尽可能的把还未使用的节点留给需要更大空间的容器运行，尽可能的把容器运行在一个节点上面。 使用以下示例，均以 Docker Machine 和 virtualbox 进行介绍，确保你的主机已安装 virtualbox。 1.创建 swarm 集群管理节点（manager）12# 创建 docker 机器$ docker-machine create -d virtualbox swarm-manager 123# 初始化 swarm 集群，进行初始化的这台机器，就是集群的管理节点。$docker-machine ssh swarm-manager$ docker swarm init --advertise-addr 192.168.99.107 #这里的 IP 为创建机器时分配的 ip。 以上输出，证明已经初始化成功。需要把以下这行复制出来，在增加工作节点时会用到： 1docker swarm join --token SWMTKN-1-4oogo9qziq768dma0uh3j0z0m5twlm10iynvz7ixza96k6jh9p-ajkb6w7qd06y1e33yrgko64sk 192.168.99.107:2377 2.创建 swarm 集群工作节点（worker） 这里直接创建好俩台机器，swarm-worker1 和 swarm-worker2 。 分别进入两个机器里，用到上一步复制的内容,添加至上一步中创建的集群. 1$ docker swarm join --token SWMTKN-1-4oogo9qziq768dma0uh3j0z0m5twlm10iynvz7ixza96k6jh9p-ajkb6w7qd06y1e33yrgko64sk 192.168.99.107:2377 以上数据输出说明已经添加成功。 3.查看集群信息 进入管理节点，执行：docker info 可以查看当前集群的信息。 1$ docker info 通过画红圈的地方，可以知道当前运行的集群中，有三个节点，其中有一个是管理节点。 4.部署服务到集群中 注意：跟集群管理有关的任何操作，都是在管理节点上操作的。 以下例子，在一个工作节点上创建一个名为 helloworld 的服务，这里是随机指派给一个工作节点： 1docker@swarm-manager:~$ docker service create --replicas 1 --name helloworld alpine ping docker.com 5.查看服务部署情况 查看 helloworld 服务运行在哪个节点上，可以看到目前是在 swarm-worker1 节点： 1docker@swarm-manager:~$ docker service ps helloworld 查看 helloworld 部署的具体信息： 1docker@swarm-manager:~$ docker service inspect --pretty helloworld 6.扩展集群服务 我们将上述的 helloworld 服务扩展到俩个节点。 1docker@swarm-manager:~$ docker service scale helloworld=2 可以看到已经从一个节点，扩展到两个节点。 7.删除服务 1docker@swarm-manager:~$ docker service rm helloworld 查看是否已删除： 8.滚动升级服务 以下实例，我们将介绍 redis 版本如何滚动升级至更高版本。 创建一个 3.0.6 版本的 redis。 1docker@swarm-manager:~$ docker service create --replicas 1 --name redis --update-delay 10s redis:3.0.6 滚动升级 redis 1docker@swarm-manager:~$ docker service update --image redis:3.0.7 redis 看图可以知道 redis 的版本已经从 3.0.6 升级到了 3.0.7，说明服务已经升级成功。 9.停止某个节点接收新的任务 查看所有的节点： 1docker@swarm-manager:~$ docker node ls 可以看到目前所有的节点都是 Active, 可以接收新的任务分配。 停止节点 swarm-worker1： 注意：swarm-worker1 状态变为 Drain。不会影响到集群的服务，只是 swarm-worker1 节点不再接收新的任务，集群的负载能力有所下降。 可以通过以下命令重新激活节点： 1docker@swarm-manager:~$ docker node update --availability active swarm-worker1 More info: Docker Swarm]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker（五）Docker Machine]]></title>
    <url>%2F2018%2F10%2F16%2FDocker05%2F</url>
    <content type="text"><![CDATA[Docker Machine 是 Docker 官方提供的一个工具，它可以帮助我们在远程的机器上安装 Docker，或者在虚拟机 host 上直接安装虚拟机并在虚拟机中安装 Docker。 本文章介绍如何使用 Docker Machine 。 Quick GuideDocker MachineDocker Machine是一个工具，可让您在虚拟主机上安装Docker Engine，并使用docker-machine命令管理主机。 Docker Engine：人们说的“Docker”通常指的是Docker Engine，由Docker守护程序组成的客户端 - 服务器应用程序，指定用于与守护进程交互的接口的REST API，以及与守护进程通信的命令行界面（CLI）客户端（通过REST API包装器）。 Docker Machine是一个用于配置和管理Dockerized主机（带有Docker Engine的主机）的工具。 Docker Machine有自己的命令行客户端 docker-machine和Docker Engine客户端。 使用Machine在一个或多个虚拟系统上安装Docker Engine，这些虚拟系统可以是本地的（使用Machine在Mac或Windows上的VirtualBox中安装和运行Docker Engine）或远程（使用Machine在云提供商上配置Dockerized主机）。 这些Dockerized机器就是托管在 Docker Machine上的机器。 安装 Docker Machine安装 Docker Machine 之前你需要先安装 Docker。 Docker Mechine 可以在多种平台上安装使用，包括 Linux 、MacOS 以及 windows。 Linux 安装命令1234$ base=https://github.com/docker/machine/releases/download/v0.16.0 &amp;&amp; curl -L $base/docker-machine-$(uname -s)-$(uname -m) &gt;/tmp/docker-machine &amp;&amp; sudo mv /tmp/docker-machine /usr/local/bin/docker-machine &amp;&amp; chmod +x /usr/local/bin/docker-machine macOS 安装命令123$ base=https://github.com/docker/machine/releases/download/v0.16.0 &amp;&amp; curl -L $base/docker-machine-$(uname -s)-$(uname -m) &gt;/usr/local/bin/docker-machine &amp;&amp; chmod +x /usr/local/bin/docker-machine Windows 安装命令如果你是 Windows 平台，可以使用 Git BASH，并输入以下命令： 1234$ base=https://github.com/docker/machine/releases/download/v0.16.0 &amp;&amp; mkdir -p "$HOME/bin" &amp;&amp; curl -L $base/docker-machine-Windows-x86_64.exe &gt; "$HOME/bin/docker-machine.exe" &amp;&amp; chmod +x "$HOME/bin/docker-machine.exe" 查看是否安装成功： 12$ docker-machine versiondocker-machine version 0.16.0, build 9371605 在远程主机上安装 Docker如果我们有多台 Ubuntu 主机都需要安装 Docker，不需要一个个登录安装，通过 docker-machine 命令我们可以轻松的在远程主机上安装 Docker。 1.前提条件在使用 docker-machine 进行远程安装前我们需要做一些准备工作： 1.在目标主机上创建一个用户并加入sudo 组 123# 比如我们要在远程主机上添加一个名为 nick 的用户并加入 sudo 组$ sudo adduser nick$ sudo usermod -a -G sudo nick 2.为该用户设置 sudo 操作不需要输入密码 1234# 打开/etc/sudoerssudo visudo# 把下面一行内容添加到文档的最后并保存文件nick ALL=(ALL:ALL) NOPASSWD: ALL 3.把本地用户的 ssh public key 添加到目标主机上 1$ ssh-copy-id -i ~/.ssh/id_rsa.pub nick@xxx.xxx.xxx.xxx 2.安装在本地运行下面的命令：123456# generic驱动$ docker-machine create -d generic \ --generic-ip-address=xxx.xxx.xxx.xxx \ --generic-ssh-user=nick \ --generic-ssh-key ~/.ssh/id_rsa \ krdevdb create 命令本是要创建虚拟主机并安装 Docker，因为本例中的目标主机已经存在，所以仅安装 Docker。 -d 是 –driver 的简写形式，主要用来指定使用什么驱动程序来创建目标主机。 –generic 开头的三个参数主要是指定操作的目标主机和使用的账户。 krdevdb 是虚拟机的名称，Docker Machine 会用它来设置目标主机的名称。 3.检查安装结果1$ docker-machine ls 4.管理远程的 Docker1234# 远程到主机krdevdbeval $(docker-machine env krdevdb) # 查看版本docker version 5.在本地主机上安装带有 Docker 的虚机在本地的一台安装了 vSphere 的虚拟机 host 上安装带有 Docker 的虚拟机。 123456789$ docker-machine create \ --driver vmwarevsphere \ --vmwarevsphere-vcenter=xxx.xxx.xxx.xxx \ --vmwarevsphere-username=root \ --vmwarevsphere-password=12345678 \ --vmwarevsphere-cpu-count=1 \ --vmwarevsphere-memory-size=512 \ --vmwarevsphere-disk-size=10240 \ testvm 解释一下比较重要的参数： –driver vmwarevsphere ：我们的虚拟机 host 上安装的是 vmware 的产品 vSphere，因此需要给 Docker Machine 提供对应的驱动，这样才能够在上面安装新的虚拟机。 –vmwarevsphere-vcenter=xxx.xxx.xxx.xxx ：虚拟机 host 的 IP 地址 –vmwarevsphere-username=root ：虚拟机 host 的 用户名 –vmwarevsphere-password=12345678 ：虚拟机 host 的 密码 –vmwarevsphere-cpu-count=1 ：虚拟机 host 的 cpu –vmwarevsphere-memory-size=512 ：虚拟机 host 的 内存 –vmwarevsphere-disk-size=10240 ：虚拟机 host 的 磁盘资源 testvm：新建虚拟机的名称。 常用命令 1.列出可用的机器 1$ docker-machine ls 2.创建机器 1$ docker-machine create --driver virtualbox test –driver：指定用来创建机器的驱动类型，这里是 virtualbox。 3.查看机器的 ip 1$ docker-machine ip test 4.停止机器 1$ docker-machine stop test 5.启动机器 1$ docker-machine start test 6.进入机器 1$ docker-machine ssh test 命令参数说明 docker-machine active：查看当前激活状态的 Docker 主机。 1234567891011$ docker-machine lsNAME ACTIVE DRIVER STATE URLdev - virtualbox Running tcp://192.168.99.103:2376staging * digitalocean Running tcp://203.0.113.81:2376$ echo $DOCKER_HOSTtcp://203.0.113.81:2376$ docker-machine activestaging config：查看当前激活状态 Docker 主机的连接信息。 creat：创建 Docker 主机 env：显示连接到某个主机需要的环境变量 inspect： 以 json 格式输出指定Docker的详细信息 ip： 获取指定 Docker 主机的地址 kill： 直接杀死指定的 Docker 主机 ls： 列出所有的管理主机 provision： 重新配置指定主机 regenerate-certs： 为某个主机重新生成 TLS 信息 restart： 重启指定的主机 rm： 删除某台 Docker 主机，对应的虚拟机也会被删除 ssh： 通过 SSH 连接到主机上，执行命令 scp： 在 Docker 主机之间以及 Docker 主机和本地主机之间通过 scp 远程复制数据 mount： 使用 SSHFS 从计算机装载或卸载目录 start： 启动一个指定的 Docker 主机，如果对象是个虚拟机，该虚拟机将被启动 status： 获取指定 Docker 主机的状态(包括：Running、Paused、Saved、Stopped、Stopping、Starting、Error)等 stop： 停止一个指定的 Docker 主机 upgrade： 将一个指定主机的 Docker 版本更新为最新 url： 获取指定 Docker 主机的监听 URL version： 显示 Docker Machine 的版本或者主机 Docker 版本 help： 显示帮助信息]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker（四）Docker Compose]]></title>
    <url>%2F2018%2F09%2F16%2FDocker04%2F</url>
    <content type="text"><![CDATA[Docker Compose是 Docker 提供的一个命令行工具，使用 Docker Compose 可以轻松、高效的管理容器，它是一个用于定义和运行多容器 Docker 的应用程序工具 。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。 本文章介绍如何使用 Docker Compose 。 Quick Guide安装macOS和windows PC 桌面版的Docker自带，不需要安装。下面介绍Linux的安装 Linux 上我们可以从 Github 上下载最新发行的版本包来使用。 12345678910# 下载 1.24.1 版本包sudo curl -L "https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose# 授权可执行权限sudo chmod +x /usr/local/bin/docker-compose# 创建软链sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose# 测试是否安装成功docker-compose --version 使用步骤工程、服务、容器Docker Compose 将所管理的容器分为三层，分别是工程（project）、服务（service）、容器（container）Docker Compose 运行目录下的所有文件（docker-compose.yml）组成一个工程,一个工程包含多个服务，每个服务中定义了容器运行的镜像、参数、依赖，一个服务可包括多个容器实例. 使用 docker-compose 构建一个在docker中运行的基于python flask框架的web应用。 12345678# 预计最终目录结构└── compose_project ├── docker │ └── docker-compose.yml ├── Dockerfile └── src ├── app.py └── requirements.txt 1.准备 1.1.创建工程目录 1234mkdir compose_projectcd compose_projectmkdir src # 源码文件夹mkdir docker # docker配置文件夹 1.2.在compose_project/src/目录下创建python flask应用 compose_project/src/app.py文件 12345678910111213rom flask import Flaskfrom redis import Redis app = Flask(__name__)redis = Redis(host='redis_ip', port=6666) @app.route('/')def count_num(): count = redis.incr('hits') return f'&#123;count&#125; times.\n' if __name__ == "__main__": app.run(host="0.0.0.0", debug=True) 1.3.创建python 需求文件 compose_project/src/requirements.txt12flaskredis 2. 定义创建容器的Dockerfile文件 compose_project/目录下创建Dockerfile文件： 1234567FROM python:3.7 COPY src/ /opt/srcWORKDIR /opt/src RUN pip install -r requirements.txtCMD ["python", "app.py"] 3. 定义docker-compose脚本在compose_project/docker/目录下创建docker-compose.yml文件，并在里面定义服务 。 12345678version: '3'services: web: build: ../../../../../09.cahe/Desktop ports: - "5000:5000" redis: image: "redis:3.0.7" web容器： 使用当前docker-compose.yml文件所在目录的上级目录（compose_project/Dockerfile）中的Dockerfile构建映像。 Flask Web服务器的默认端口5000,将容器上的暴露端口5000映射到主机上的端口5000。 redis容器: redis 服务使用从Docker Hub提取的官方redis镜像3.0.7版本 4. 使用Compose构建并运行您的应用程序 在compose_project/docker/目录下执行docker-compose.yml文件： 12345docker-compose up# 若是要后台运行，命令需要-d：docker-compose up -d# 若不使用默认的docker-compose.yml 文件名：docker-compose -f server.yml up -d Docker Compose 常用命令 ps：列出所有运行容器 1docker-compose ps logs：查看服务日志输出 1docker-compose logs port：打印绑定的公共端口，下面命令可以输出 flask 服务 8761 端口所绑定的公共端口 1docker-compose port flask 8761 build：构建或者重新构建服务 1docker-compose build start：启动指定服务已存在的容器 1docker-compose start flask stop：停止已运行的服务的容器 1docker-compose stop flask rm：删除指定服务的容器 1docker-compose rm flask up：构建、启动容器 1docker-compose up kill：通过发送 SIGKILL 信号来停止指定服务的容器 1docker-compose kill flask pull：下载服务镜像 scale：设置指定服务运气容器的个数，以 service=num 形式指定 1docker-compose scale user=3 movie=3 run：在一个服务上执行一个命令 1docker-compose run web bash yml 配置指令参考 version：指指定本 yml 依从的 compose 哪个版本制定的 services：多个容器集合 build：指定为构建镜像上下文路径，该值可以是一个路径，也可以是一个对象，用于指定 Dockerfile 参数,例如 1234version: "3.7"services: webapp: build: ./dir 12345678910111213version: "3.7"services: webapp: build: context: ./dir dockerfile: Dockerfile-alternate args: buildno: 1 labels: - "com.example.description=Accounting webapp" - "com.example.department=Finance" - "com.example.label-with-empty-value" target: prod context：上下文路径。 dockerfile：指定构建镜像的 Dockerfile 文件名。 args：添加构建参数，这是只能在构建过程中访问的环境变量。 labels：设置构建镜像的标签。 target：多层构建，可以指定构建哪一层。 cap_add cap_drop:添加或删除容器拥有的宿主机的内核功能。 12345cap_add: - ALL # 开启全部权限cap_drop: - SYS_PTRACE # 关闭 ptrace权限 cgroup_parent:为容器指定父 cgroup 组，意味着将继承该组的资源限制。 1cgroup_parent: m-executor-abcd container_name:指定自定义容器名称，而不是生成的默认名称。 1container_name: my-web-container depends_on:设置依赖关系 docker-compose up ：以依赖性顺序启动服务。在以下示例中，先启动 db 和 redis ，才会启动 web。 docker-compose up SERVICE ：自动包含 SERVICE 的依赖项。在以下示例中，docker-compose up web 还将创建并启动 db 和 redis。 docker-compose stop ：按依赖关系顺序停止服务。在以下示例中，web 在 db 和 redis 之前停止。 1234567891011version: "3.7"services: web: build: . depends_on: - db - redis redis: image: redis db: image: postgres 注意：web 服务不会等待 redis db 完全启动 之后才启动。 deploy:指定与服务的部署和运行有关的配置,只在 swarm 模式下才会有用。 12345678910111213141516171819202122version: "3.7"services: redis: image: redis:alpine deploy: mode：replicated replicas: 6 endpoint_mode: dnsrr labels: description: "This redis service label" resources: limits: cpus: '0.50' memory: 50M reservations: cpus: '0.25' memory: 20M restart_policy: condition: on-failure delay: 5s max_attempts: 3 window: 120s 可以选参数： endpoint_mode：访问集群服务的方式。 1234endpoint_mode: vip # Docker 集群服务一个对外的虚拟 ip。所有的请求都会通过这个虚拟 ip 到达集群服务内部的机器。endpoint_mode: dnsrr# DNS 轮询（DNSRR）。所有的请求会自动轮询获取到集群 ip 列表中的一个 ip 地址。 labels：在服务上设置标签。可以用容器上的 labels（跟 deploy 同级的配置） 覆盖 deploy 下的 labels。 mode：指定服务提供的模式。 replicated：复制服务，复制指定服务到集群的机器上。 global：全局服务，服务将部署至集群的每个节点。 图解：下图中黄色的方块是 replicated 模式的运行情况，灰色方块是 global 模式的运行情况。 replicas：mode 为 replicated 时，需要使用此参数配置具体运行的节点数量。 resources：配置服务器资源使用的限制，例如上例子，配置 redis 集群运行需要的 cpu 的百分比 和 内存的占用。避免占用资源过高出现异常。 restart_policy：配置如何在退出容器时重新启动容器。 condition：可选 none，on-failure 或者 any（默认值：any）。 delay：设置多久之后重启（默认值：0）。 max_attempts：尝试重新启动容器的次数，超出次数，则不再尝试（默认值：一直重试）。 window：设置容器重启超时时间（默认值：0）。 rollback_config：配置在更新失败的情况下应如何回滚服务。 parallelism：一次要回滚的容器数。如果设置为0，则所有容器将同时回滚。 delay：每个容器组回滚之间等待的时间（默认为0s）。 failure_action：如果回滚失败，该怎么办。其中一个 continue 或者 pause（默认pause）。 monitor：每个容器更新后，持续观察是否失败了的时间 (ns|us|ms|s|m|h)（默认为0s）。 max_failure_ratio：在回滚期间可以容忍的故障率（默认为0）。 order：回滚期间的操作顺序。其中一个 stop-first（串行回滚），或者 start-first（并行回滚）（默认 stop-first ）。 update_config：配置应如何更新服务，对于配置滚动更新很有用。 parallelism：一次更新的容器数。 delay：在更新一组容器之间等待的时间。 failure_action：如果更新失败，该怎么办。其中一个 continue，rollback 或者pause （默认：pause）。 monitor：每个容器更新后，持续观察是否失败了的时间 (ns|us|ms|s|m|h)（默认为0s）。 max_failure_ratio：在更新过程中可以容忍的故障率。 order：回滚期间的操作顺序。其中一个 stop-first（串行回滚），或者 start-first（并行回滚）（默认stop-first）。 注：仅支持 V3.4 及更高版本。 devices：指定设备映射列表 12devices: - "/dev/ttyUSB0:/dev/ttyUSB0" dns：自定义 DNS 服务器，可以是单个值或列表的多个值。 12345dns: 8.8.8.8dns: - 8.8.8.8 - 9.9.9.9 dns_search：自定义 DNS 搜索域，可以是单个值或列表。 12345dns_search: example.comdns_search: - dc1.example.com - dc2.example.com entrypoint：覆盖容器默认的 entrypoint。 1entrypoint: /code/entrypoint.sh 也可以是以下格式： 1234567entrypoint: - php - -d - zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20100525/xdebug.so - -d - memory_limit=-1 - vendor/bin/phpunit ------ env_file：从文件添加环境变量。可以是单个值或列表的多个值。 1env_file: .env 1234env_file: - ./common.env - ./apps/web.env - /opt/secrets.env ------ environment：添加环境变量。您可以使用数组或字典、任何布尔值，布尔值需要用引号引起来，以确保 YML 解析器不会将其转换为 True 或 False。 123environment: RACK_ENV: development SHOW: 'true' expose：暴露端口，但不映射到宿主机，只被连接的服务访问。仅可以指定内部端口为参数。 123expose: - "3000" - "8000" extra_hosts：添加主机名映射。类似 docker client –add-host。 123extra_hosts: - "somehost:162.242.195.82" - "otherhost:50.31.209.229" 以上会在此服务的内部容器中 /etc/hosts 创建一个具有 ip 地址和主机名的映射关系： 12162.242.195.82 somehost50.31.209.229 otherhost ------ healthcheck：用于检测 docker 服务是否健康运行。 123456healthcheck: test: ["CMD", "curl", "-f", "http://localhost"] # 设置检测程序 interval: 1m30s # 设置检测间隔 timeout: 10s # 设置检测超时时间 retries: 3 # 设置重试次数 start_period: 40s # 启动后，多少秒开始启动检测程序 image：指定容器运行的镜像。以下格式都可以： 12345image: redisimage: ubuntu:14.04image: tutum/influxdbimage: example-registry.com:4000/postgresqlimage: a4bc65fd # 镜像id logging：服务的日志记录配置。 driver：指定服务容器的日志记录驱动程序，默认值为json-file。有以下三个选项 123driver: "json-file"driver: "syslog"driver: "none" 仅在 json-file 驱动程序下，可以使用以下参数，限制日志得数量和大小。 12345logging: driver: json-file options: max-size: "200k" # 单个文件大小为200k max-file: "10" # 最多10个文件 当达到文件限制上限，会自动删除旧得文件。 syslog 驱动程序下，可以使用 syslog-address 指定日志接收地址。 1234logging: driver: syslog options: syslog-address: "tcp://192.168.0.42:123" ------ network_mode：设置网络模式 12345network_mode: "bridge"network_mode: "host"network_mode: "none"network_mode: "service:[service name]"network_mode: "container:[container name/id]" networks 配置容器连接的网络，引用顶级 networks 下的条目 。 12345678910111213141516services: some-service: networks: some-network: aliases: - alias1 other-network: aliases: - alias2networks: some-network: # Use a custom driver driver: custom-driver-1 other-network: # Use a custom driver which takes special options driver: custom-driver-2 **aliases** ：同一网络上的其他容器可以使用服务名称或此别名来连接到对应容器的服务。 ------ restart no：是默认的重启策略，在任何情况下都不会重启容器。 always：容器总是重新启动。 on-failure：在容器非正常退出时（退出状态非0），才会重启容器。 unless-stopped：在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器 1234restart: "no"restart: alwaysrestart: on-failurerestart: unless-stopped 注：swarm 集群模式，请改用 restart_policy。 ------ secrets：存储敏感数据，例如密码 12345678910111213version: "3.1"services:mysql: image: mysql environment: MYSQL_ROOT_PASSWORD_FILE: /run/secrets/my_secret secrets: - my_secretsecrets: my_secret: file: ./my_secret.txt security_opt：修改容器默认的 schema 标签。 12345security-opt： - label:user:USER # 设置容器的用户标签 - label:role:ROLE # 设置容器的角色标签 - label:type:TYPE # 设置容器的安全策略标签 - label:level:LEVEL # 设置容器的安全等级标签 stop_grace_period：指定在容器无法处理 SIGTERM (或者任何 stop_signal 的信号)，等待多久后发送 SIGKILL 信号关闭容器。 12stop_grace_period: 1s # 等待 1 秒stop_grace_period: 1m30s # 等待 1 分 30 秒 默认的等待时间是 10 秒。 ------ stop_signal：设置停止容器的替代信号。默认情况下使用 SIGTERM 。以下示例，使用 SIGUSR1 替代信号 SIGTERM 来停止容器。 1stop_signal: SIGUSR1 sysctls：设置容器中的内核参数，可以使用数组或字典格式。 1234567sysctls: net.core.somaxconn: 1024 net.ipv4.tcp_syncookies: 0sysctls: - net.core.somaxconn=1024 - net.ipv4.tcp_syncookies=0 tmpfs：在容器内安装一个临时文件系统。可以是单个值或列表的多个值。 12345tmpfs: /runtmpfs: - /run - /tmp ulimits：覆盖容器默认的 ulimit。 12345ulimits: nproc: 65535 nofile: soft: 20000 hard: 40000 volumes：将主机的数据卷或着文件挂载到容器里。 1234567version: "3.7"services: db: image: postgres:latest volumes: - "/localhost/postgres.sock:/var/run/postgres/postgres.sock" - "/localhost/data:/var/lib/postgresql/data"]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker（三）Dockerfile]]></title>
    <url>%2F2018%2F08%2F16%2FDocker03%2F</url>
    <content type="text"><![CDATA[Dockerfile 是记录了镜像是如何被构建出来的配置文件, 可以被 docker 直接执行以创建一个镜像。文章介绍如何编写Dockerfile。 Quick Guide 编写Dockerfile 构建镜像 1.创建文件 123mkdir Dockerfilecd Dockerfilevi Dockerfile 2.编写镜像信息 分为四部分： 基础镜像信息 维护者信息 镜像操作指令 容器启动时执行指令。 Dockerfile中每一个指令都会建立一层， 最多127层镜像， 可以用&amp;&amp;将各个所需命令串联起来简化为了1层。 ‘#’ 为 Dockerfile 中的注释。 123456789101112131415161718192021222324252627282930313233# This my first nginx Dockerfile# Version 1.0# Base images 基于基础镜像上构建FROM centos#MAINTAINER 维护者信息MAINTAINER xiaoming #ENV 设置环境变量ENV PATH /usr/local/nginx/sbin:$PATH#ADD 文件放在当前目录下，拷过去会自动解压ADD nginx-1.8.0.tar.gz /usr/local/ ADD epel-release-latest-7.noarch.rpm /usr/local/ #RUN 执行以下命令 RUN rpm -ivh /usr/local/epel-release-latest-7.noarch.rpmRUN yum install -y wget lftp gcc gcc-c++ make openssl-devel pcre-devel pcre &amp;&amp; yum clean allRUN useradd -s /sbin/nologin -M www#WORKDIR 相当于cdWORKDIR /usr/local/nginx-1.8.0 RUN ./configure --prefix=/usr/local/nginx --user=www --group=www --with-http_ssl_module --with-pcre &amp;&amp; make &amp;&amp; make installRUN echo "daemon off;" &gt;&gt; /etc/nginx.conf#EXPOSE 映射端口EXPOSE 80#CMD 运行以下命令CMD ["nginx"] 3.构建镜像 123456docker build [options] PATH | URL# [OPTIONS]-t &lt;指定镜像的名字&gt;-f &lt;指定构建镜像的 Dockerfile 文件（Dockerfile 可不在当前路径下）&gt;PATH|URL # 指定构建镜像的上下文的路径，构建镜像的过程中，可以且只可以引用上下文中的任何文件 1docker build -t nginx:test . Dockerfile 常用命令 指令 说明 FROM 指定所创建镜像的基础镜像 MAINTAINER 指定维护者信息 RUN 运行命令 CMD 指定启动容器时默认执行的命令 LABEL 指定生成镜像的元数据标签信息 EXPOSE 声明镜像内服务所监听的端口 ENV 指定环境变量 ADD 赋值指定的路径下的内容到容器中的路径下，可以为URL；如果为tar文件，会自动解压到路径下 COPY 赋值本地主机的路径下的内容到容器中的路径下；一般情况下推荐使用COPY而不是ADD ENTRYPOINT 指定镜像的默认入口 VOLUME 创建数据挂载点 USER 指定运行容器时的用户名或UID WORKDIR 配置工作目录 ARG 指定镜像内使用的参数(例如版本号信息等) ONBUILD 配置当前所创建的镜像作为其他镜像的基础镜像时，所执行的创建操作的命令 STOPSIGNAL 容器退出的信号 HEALTHCHECK 如何进行健康检查 SHELL 指定使用SHELL时的默认SHELL类型 1.FROM:指定基础镜像，要在哪个镜像建立 123# 格式FROM &lt;image&gt; FROM &lt;image&gt;:&lt;tag&gt; 第一条指令必须为 FROM 指令。FROM命令会指定镜像基于哪个基础镜像创建，接下来的命令也会基于这个基础镜像（CentOS和Ubuntu有些命令可是不一样的）。FROM命令可以多次使用，表示会创建多个镜像。 2.MAINTAINER：指定维护者信息 12# 格式MAINTAINER &lt;name&gt; 3.ARG:指定一些镜像内使用的参数(例如版本号信息等)，这些参数在执行docker build命令时才以–build-arg=格式传入。 12# 格式ARG&lt;name&gt;[=&lt;default value&gt;] 4.RUN：在镜像中要执行的命令 123# 格式RUN &lt;command&gt;RUN ["executable", "param1", "param2"] 前者默认将在 shell 终端中运行命令，即 /bin/bash -c ；后者则使用 exec 执行。指定使用其它终端可以通过第二种方式实现，例如 RUN [“/bin/bash”, “-c”,”echo hello”] 。 每条RUN指令将在当前镜像的基础上执行指定命令，并提交为新的镜像。当命令较长时可以使用\换行。 123RUN apt-get update \ &amp;&amp; apt-get install -y libsnappy-dev zliblg-dev libbz2-dev \ &amp;&amp; rm -rf /var/cache/apt 5.WORKDIR：指定当前工作目录，相当于 cd 12# 格式WORKDIR /path/to/workdir 为后续的 RUN 、 CMD 、 ENTRYPOINT 指令配置工作目录。 可以使用多个 WORKDIR 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。 12345# 例如WORKDIR /aWORKDIR bWORKDIR cRUN pwd 6.EXPOSE：指定容器要打开的端口 12# 格式EXPOSE &lt;port&gt; [&lt;port&gt;...] 告诉 Docker 服务端容器暴露的端口号，供互联系统使用。在启动容器时需要通过 -P，Docker 主机会自动分配一个端口转发到指定的端口。 注意： 该命令只是起到声明租用，并不会自动完成端口映射。 在容器启动时需要使用-P(大写P)，Docker主机会自动分配一个宿主机未被使用的临时端口转发到指定的端口；使用-p(小写p)，则可以具体指定哪个宿主机的本地端口映射过来。 7.ENV：定义环境变量 12345# 格式ENV &lt;key&gt; &lt;value&gt; # 指定一个环境变量，会被后续 RUN 指令使用，并在容器运行时保持。# 例如ENV PATH /usr/local/nginx/sbin:$PATH 指令指定的环境变量在运行时可以被覆盖掉，如docker run –env = built_image。 8.COPY ：复制本地主机的 （为 Dockerfile 所在目录的相对路径）到容器中的 12# 格式COPY 9.ADD：相当于 COPY，但是比 COPY 功能更强大 12# 格式ADD &lt;src&gt; &lt;dest&gt; 该命令将复制指定的 到容器中的 。 其中 可以是Dockerfile所在目录的一个相对路径；也可以是一个 URL；还可以是一个 tar 文件，复制进容器会自动解压。 可以使镜像内的绝对路径，或者相当于工作目录(WORKDIR)的相对路径，支持正则表达式。 12# 例如ADD *.c /code/ 10.VOLUME：挂载目录 12# 格式USER daemon 指定运行容器时的用户名或 UID，后续的 RUN 也会使用指定用户。当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户，例如： RUN useradd -s /sbin/nologin -M www。 11.LABEL:用来生成用于生成镜像的元数据的标签信息 123456# 格式LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...# 例如LABEL version="1.0"LABEL description="This text illustrates \ that label-values can span multiple lines." 12.ENTRYPOINT:指定镜像的默认入口命令，该入口命令会在启动容器时作为根命令执行，所有传入值作为该命令的参数 123# 格式ENTRYPOINT ["executable", "param1", "param2"]ENTRYPOINT command param1 param2 #（shell中执行） 此时，CMD指令指定值将作为根命令的参数。 每个Dockerfile中只能有一个ENTRYPOINT，当指定多个时，只有最后一个有效。 在运行时可以被–entrypoint参数覆盖掉，如docker run –entrypoint。 13.CMD:指定启动容器时执行的命令 1234# 格式CMD ["executable","param1","param2"] 使用 exec 执行，推荐方式；CMD command param1 param2 在 /bin/bash 中执行，提供给需要交互的应用；CMD ["param1","param2"] 提供给 ENTRYPOINT 的默认参数； 每个 Dockerfile 只能有一条 CMD 命令。如果指定了多条命令，只有最后一条会被执行。如果用户启动容器时候指定了运行的命令，则会覆盖掉 CMD 指定的命令。 14.ONBUILD：在构建本镜像时不生效，在基于此镜像构建镜像时生效 12# 格式ONBUILD [INSTRUCTION] 配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。 15.STOPSIGNAL:指定所创建镜像启动的容器接收退出的信号值 12# 例如STOPSIGNAL singnal 16.HEALTHCHECK：配置所启动容器如何进行健康检查(如何判断是否健康)，自Docker 1.12开始支持 12345678# 格式HEALTHCHECK [OPTIONS] CMD command # 根据所执行命令返回值是否为0判断；HEALTHCHECK NONE # 禁止基础镜像中的健康检查。# [OPTION]参数--inerval=DURATION # (默认为：30s)：多久检查一次；--timeout=DURATION # (默认为：30s)：每次检查等待结果的超时时间；--retries=N # (默认为：3)：如果失败了，重试几次才最终确定失败。 17.SHELL：指定其他命令使用shell时的默认shell类型（默认值为 [“bin/sh”,”-c”]） 12# 格式SHELL ["executable","parameters"] 默认值为 [“bin/sh”,”-c”] 注意事项 对于Windows系统，建议在Dockerfile开头添加# escape=`来指定转移信息 ENTRYPOINT 和 CMD 的区别：ENTRYPOINT 不能被执行时的参数覆盖掉，CMD 可以被覆盖掉默认的参数。ENTRYPOINT 指定了该镜像启动时的入口默认参数，CMD 则指定了容器启动时的命令。 调试dockerfile，使用dockerfile需要好久的时间，建议进入容器手动先执行dockerfile命令实践。 编写.dockerignore文件(过滤Dockerfile所在目录中的其他文件) 容器只运行单个应用 将多个RUN指令合并为一个 基础镜像的标签不要用latest 每个RUN指令后删除多余文件 选择合适的基础镜像(alpine版本最好) 设置WORKDIR和CMD 使用ENTRYPOINT (可选) 在entrypoint脚本中使用exec COPY与ADD优先使用前者 合理调整COPY与RUN的顺序 设置默认的环境变量，映射端口和数据卷 使用LABEL设置镜像元数据 添加HEALTHCHECK 最小化镜像的层数。 多行参数时应该分类，在每个换行符\前都增加一个空格。 对构建缓存要有清楚的认识 More info: 官方文档]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker（二）Docker的运行]]></title>
    <url>%2F2018%2F07%2F16%2FDocker02%2F</url>
    <content type="text"><![CDATA[文章介绍Docker的如何运行和基本命令。 Quick GuideDocker的构成Docker有三个组件和三个基本元素: 三个组件分别是： Docker Client ：是用户界面，它支持用户与 Docker Daemon 之间通信。 Docker Daemon： 运行于主机上，处理服务请求。 Docker Registry：是中央registry，拥有Docker容器镜像备份的公有和私有访问权限。 三个基本要素分别是： Docker Containers： 负责应用程序的运行，包括操作系统、用户添加的文件以及元数据。 镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 Docker Images： 是一个只读模板，用来运行Docker容器。 就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。 DockerFile ：是文件指令集，用来说明如何自动创建Docker镜像。 Docker的技术支柱Docker使用以下操作系统的功能来提高容器技术效率： Namespaces 充当隔离的第一级。确保一个容器中运行一个进程而且不能看到或影响容器外的其它进程。 Control Groups是LXC的重要组成部分，具有资源核算与限制的关键功能。 UnionFS（文件系统）作为容器的构建块。为了支持Docker的轻量级以及速度快的特性，它创建了用户层。 使用Docker 运行程序1.创建镜像 1.1.Docker Client 发送给Docker Daemon命令:需要创建的镜像以及需要在容器内运行的命令 1docker build -t ubuntu:15.10 . 各个参数解析： docker: Docker 的二进制执行文件。 run: 与前面的 docker 组合来创建镜像 。 ubuntu:15.10 指定要创建的镜像名称:镜像标签 . 指定镜像构建过程中的上下文环境的目录 1.2.镜像创建完成，就可以将它们推送到中央Registry：Docker Registry，以供他人使用。Docker Index为镜像提供了两个级别的访问权限：公有访问和私有访问。公有仓库是可搜索和可重复使用的，而私有仓库只能给那些拥有访问权限的成员使用.你可以将镜像存储在私有仓库，Docker官网有私有仓库的套餐可以供你选择。 1234# 仓库地址在 /etc/docker 下的daemon.json文件下可以找到docker login # 登陆仓库docker tag ubuntu:15.10 &lt;仓库地址&gt;/ubuntu:15.10 # 修改镜像标签docker push &lt;仓库地址&gt;/ubuntu:15.10 # 镜像推送 2.运行容器运行容器源于我们在第一步中创建的镜像。当容器被启动后，一个读写层会被添加到镜像的顶层。当分配到合适的网络和IP地址后，需要的应用程序就可以在容器中运行了。 1docker run ubuntu:15.10 /bin/echo "Hello world" 各个参数解析： docker: Docker 的二进制执行文件。 run: 与前面的 docker 组合来运行一个容器。 ubuntu:15.10 指定要运行的镜像，Docker 首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。 /bin/echo “Hello world”: 在启动的容器里执行的命令 关于镜像、容器、仓库的基本命令 镜像 1.获取镜像 1docker search &lt;image&gt; # 在docker index中搜索image 2.获取镜像 12docker pull &lt;image&gt; # 从docker registry server 中下拉imagedocker pull &lt;server:port/image:tag&gt; # 获取image 3.查看镜像 12docker images： # 列出imagesdocker images -a # 列出所有的images（包含历史） 4.删除镜像 1docker rmi &lt;image ID&gt; # 删除一个或多个image 5.创建镜像 123docker commit -m "add new image" -a &lt;container_id&gt; &lt;new_image_name&gt; # 基于已有镜像的容器创建cat &lt;本地模板&gt; | Docker import - image:tag # 基于本地模板导入docker build -t &lt;image:tag&gt; &lt;docker_file_dir. # 基于dockerfile创建 6.存出镜像 1docker save -o &lt;image_file&gt; &lt;image:tag&gt; 7.载入镜像 1docker save -o &lt;image_file&gt; &lt;image:tag&gt; 8.上传镜像 1docker push &lt;user/image:tag&gt; 容器 1.创建容器 1docker create -it &lt;image:tag&gt; 2.创建并启动容器 1docker run -it &lt;image:tag&gt; /bin/bash 3.守护态运行 1ddocker run -d &lt;image:tag&gt; 4.查看容器信息 1234docker ps # 列出当前所有正在运行的containerdocker ps -l # 列出最近一次启动的containerdocker ps -a # 列出所有的container（包含历史，即运行过的container）docker ps -q # 列出最近一次运行的container ID 5.获取容器的输出信息 1docker logs -f &lt;image:tag&gt;或&lt;container_id&gt; 6.终止容器 1docker stop &lt;image:tag&gt;或&lt;container_id&gt; 7.启动容器 1docker start &lt;image:tag&gt;或&lt;container_id&gt; 8.重启容器 1docker restart &lt;image:tag&gt;或&lt;container_id&gt; 9.进入容器 123docker attach &lt;image:tag&gt;或&lt;container_id&gt;docker exec -it &lt;image:tag&gt;或&lt;container_id&gt; /bin/bash nsenter --target &lt;docker_pid&gt; --mount --uts --ipc --net --pid 10.删除容器 123docker rm &lt;container_id&gt; #：删除一个或多个containerdocker rm `docker ps -a -q` #：删除所有的containerdocker ps -a -q | xargs docker rm # 同上, 删除所有的container 11.导出容器 1docker export &lt;container_id&gt; &gt;test.tar 12.容器快照导入到本地镜像库 1cat &lt;container_snapshot&gt; | docker import - &lt;user/image:tag&gt; 仓库 1.登录 1docker login 2.更新镜像标签 1docker tag &lt;server:port/image:tag&gt; &lt;image:tag&gt; 3.创建私有仓库 1docker run -p 5000:5000 registry:&lt;registry_version&gt; 4.管理私有仓库镜像 1234docker tag &lt;image:tag&gt; &lt;私有仓库IP:端口/new_tag&gt; # 重新标记一个本地镜像为私有仓库的版本docker push &lt;私有仓库IP:端口/image:new_tag&gt;curl http://&lt;私有仓库IP:端口&gt;/v2/&lt;image&gt;/tags/list # 查看私有仓库中的镜像列表docker pull &lt;私有仓库IP:端口/image:new_tag&gt; # 拉取本地仓库中的镜像 More info: Docker教程]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker（一）Docker的基本概念]]></title>
    <url>%2F2018%2F06%2F16%2FDocker01%2F</url>
    <content type="text"><![CDATA[Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。文章介绍 Docker 的基本概念和部署安装。 Quick GuideLinux 容器资源利用率和环境部署的问题，早期使用虚拟机解决。但是虚拟机存在问题（资源占用多、冗余步骤多、启动慢），由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。 Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。 容器优势 启动快 容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。 资源占用少 容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。 体积小 容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。 DockerDocker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。 Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。 Docker 的用途Docker 的主要用途，目前有三大类。 提供一次性的环境。比如本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。 提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。 组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。 Docker 框架Docker 包括三个基本概念: 镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。 容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。 Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。Docker 容器通过 Docker 镜像来创建。 概念 说明 Docker 镜像(Images) Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。 Docker 容器(Container) 容器是独立运行的一个或一组应用，是镜像运行时的实体。 Docker 客户端(Client) Docker 客户端通过命令行或者其他工具使用 Docker SDK (https://docs.docker.com/develop/sdk/) 与 Docker 的守护进程通信。 Docker 主机(Host) 一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。 Docker Registry Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。Docker Hub(https://hub.docker.com) 官方维护一个公共仓库，提供了庞大的镜像集合，使用需要先注册一下。 Docker Machine Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。 Docker 部署安装Docker 是一个开源的商业产品，有两个版本：社区版（Community Edition，缩写为 CE）和企业版（Enterprise Edition，缩写为 EE）。企业版包含了一些收费服务，个人开发者一般用不到。Docker CE 的安装请参考官方文档。 Mac Windows Ubuntu Debian CentOS Fedora 其他 Linux 发行版 安装步骤 1.前提条件:Docker 运行在 CentOS 7 上，要求系统为64位且系统内核版本为 3.10 以上。 1uname -r 2.移除旧的版本 12345678910sudo yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-engine 3.安装必要的系统工具 1sudo yum install -y yum-utils device-mapper-persistent-data lvm2 4.添加软件源信息 1sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 5.更新 yum 缓存 1sudo yum makecache fast 6.安装 1sudo yum -y install docker-ce 7.启动 Docker 后台服务 1sudo systemctl start docker 8.测试运行 hello-world 1docker run hello-world 9.查看docker信息 12docker version # 查看docker的版本号，包括客户端、服务端、依赖的Go等docker info # 查看系统(docker)层面信息，包括管理的images, containers数等 Docker 资源汇总Docker 资源 Docker 官方主页: https://www.docker.com Docker 官方博客: https://blog.docker.com/ Docker 官方文档: https://docs.docker.com/ Docker Store: https://store.docker.com Docker Cloud: https://cloud.docker.com Docker Hub: https://hub.docker.com Docker 的源代码仓库: https://github.com/moby/moby Docker 发布版本历史: https://docs.docker.com/release-notes/ Docker 常见问题: https://docs.docker.com/engine/faq/ Docker 远端应用 API: https://docs.docker.com/develop/sdk/ Docker 国内镜像 阿里云的加速器：https://help.aliyun.com/document_detail/60750.html 网易加速器：http://hub-mirror.c.163.com 官方中国加速器：https://registry.docker-cn.com ustc 的镜像：https://docker.mirrors.ustc.edu.cn daocloud：https://www.daocloud.io/mirror#accelerator-doc（注册后使用） More info: Docker教程]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云计算（四）OpenStack]]></title>
    <url>%2F2018%2F05%2F16%2F%E4%BA%91%E8%AE%A1%E7%AE%9704%2F</url>
    <content type="text"><![CDATA[OpenStack 是当今最具影响力的云计算管理工具——通过命令或者基于 Web 的可视化控制面板来管理 IaaS 云端的资源池（服务器、存储和网络）。它最先由美国国家航空航天局（NASA）和 Rackspace 在 2010 年合作研发，现在参与的人员和组织汇集了来自 100 多个国家的超过 9500 名的个人和 850 多个世界上赫赫有名的企业，如 NASA、谷歌、惠普、Intel、IBM、微软等。本文章主要介绍OpenStack的基本知识。 Quick GuideOpenStack 采用 Python 语言开发，遵循 Apache 开源协议，因此相比 CloudStack 来说，更轻量化，效率更高。 OpenStack目前被广泛应用在各行各业 OpenStack 支持 KVM、Xen、Lvc、Docker 等虚拟机软件或容器，默认为 KVM 各个版本的发行时间表参考网 组件OpenStack 组件的主要作用是充当“中间人”，它不履行具体的实际任务，而由各种第三方软件来完成，比如虚拟机软件由 KVM 承担，网站任务由 Apache 承担，虚拟网络任务由 iptables、DNSmasq、Linux vSwitch、Linux 网桥承担或者统一由 OpenContrail 承担，结构化数据存储任务由 MySQL 或者 PostgreSQL 承担，中央存储任务由 Ceph 承担（也可采用其他产品）。当然，OpenStack 中也有实现具体功能的组件，比如 Swift 做中央存储，我们也可以选择相对发展多年并且被大量使用的第三方产品，如 Ceph。 分类 组件名称 功能 核心组件 Nova 管理虚拟机的整个生命周期:创建、运行、挂起、调度、关闭、销毁等。这是真正的执行部件。接受 DashBoard 发來的命令并完成具体的动作。但是 Nova 不是虛拟机软件，所以还需要虚拟机软件（如 KVM、Xen、Hyper-v 等）配合 核心组件 Neutron 管理网络资源，提供/一组应用编程接口(API)，用户可以调用它们来定义网络(如 VLAN )，并把定义好的网络附加给租户。Networking 是一个插件式结构，支持当前主流的网络设备和最新网铬技术 核心组件 Swift 是 NoSQL 数据库，类似 HBase，为虚拟机提供非结构化数据存储，它把相同的数据存储在多台计箅机上，以确保数据不会丢失。用户可通过 RESTful 和 HTTP 类型的 API 来和它通信。这是实际的存储项目，类似 Ceph，不过在 OpcnStack 具体实施时，人们更愿意采用 Ceph。 核心组件 Cinder 管理块设备，为虚拟机管理 SAN 设备源。但是它本身不是块设备源， 需要一个存储后端来提供实际的块设备源（如 iSCSI、FC等）。Cinder 相当于一个管家，当虚拟机需要块设备时，询问管家去哪里获取具体的块设备。它也是插件式的，安装在具体的 SAN 设备里。Cinder 支持的存储后端品牌参见 https://wiki.openstack.org/wiki/CinderSupportMatrix，驱动参见 https://github.com/openstack/cinder/tree/master/cinder/volume/drivers。 核心组件 Keystone 为其他服务提供身份验证、权限管理、令牌管理及服务名册管理。要使用云计算的所有用户事先需要在 Keystone 中建立账号和密码，并定义权限（注意:这里的“用户”不是指虚拟机里的系统账户，如 Windows 7 中的 Administrator )。另外，OpenStack 服务（如 Nova、Neutron、Swift、Cinder 等）也要在里面注册，并且登记具体的 API，Keystone 本身也要注册和登记 API 核心组件 Glance 存取虚拟机磁盘镜像文件，Compute 服务在启动虚拟机时需要从这里获取镜像文件。这个组件不同于上面的 Swift 和 Cinder，这两者提供的 存储是在虚拟机里使用的 可选组件 Horizon 提供了一个网页界面，用户登录后可以做这些操作：管理虚拟机、配置权限、分配 IP 地址、创建租户和用户等。本质上就是通过图形化的 操作界面控制其他服务（如 Compute、Networking 等)。当然，如果你熟悉命令，也可以直接采用命令来完成相应的任务 可选组件 Heat 如果要在成千上万个虚拟机里安装和配置同一个软件，该怎么办？采用 Orchestrates 是一个不错的主意，它向每个虚拟机里注人一个名叫 heat-cfntools 的客户端工具，然后就能同时操作很多虚拟机 可选组件 Sahana 使用户能够在 OpenStack 平台上（利用虚拟机）一键式创建和管理 Hadoop 集群，实现类似 AWS 的 EMR（Amazon Elastic MapReduce Service）功能。用户只需要提供简单的配置参数和模板，如版本信息（CDH 版本）、集群拓扑（几个 Slave、几个 Datanode）、节点配置信息（CPU、内存）等，Sahara 服务就能够在几分钟内根据提供的模板快速 部署 Hadoop、Spark 及 Storm 集群。Sahana 是一个大数据分析项目 可选组件 Ironic 把裸金属机器（与虚拟机相对）加人到资源池中 可选组件 Zaqar Zaqar 为 Web 和移动开发者提供多租户云消息和通知服务，开发人员可以通过 REST API 在其云应用的不同组件中通过不同的通信模式（如 生产者/消费者或发布者/订阅者）来传递消息 可选组件 Ceilometer 结合 Aodh、CloudKitty 两个组件，完成计费任务，如结算、消耗的 资源统计、性能监控等。OpenStack 之所以能管理公共云，一是因为 Ceilometer 的存在，二是因为引人了租户的概念 可选组件 Barbican 是 OpenStack 的密钥管理组件，其他组件可以调用 Barbican 对外暴露的 REST API 来存储和访问密钥 可选组件 Manila 为虚拟机提供文件共享服务，不过需要存储后端的配合 可选组件 其他组件：Congress（策略服务）、Designate（DNS 服务）、Freezer（备份及还原服务）、Magnum（容器支持）、Mistral（工作流服务）、Monasca（监控服务）、Searchlight（索引和搜索）、Senlin（集群服务）、Solum（APP集成开发平台）、Tacker（网络功能 虚拟化）、Trove（数据库服务） 部署部署 OpenStack 时应该遵循“逐步扩展部署法”: 最小系统具备基本的 IaaS 功能，能通过命令来进行管理，这一步只需安装 OpenStack 的 Keystone、Neutron、Nova 和 Glance 四个组件； 安装 Horizon 就成了小系统，这时可通过 Web 图形化界面来执行管理； 安装 Swift 和 Cinder 就成了准系统 给虚拟机附加磁盘块设备，并能满足大规模的存储需求；再加上计费组件 Ceilometer，就上升为一般系统，一般系统具备公有 IaaS 的功能。 一般系统跨到生产系统，需要完成的工作就特别多，其中性能和安全是两个不得不面对的棘手问题。 Iptables（设立门卫）、Selinux 或 Apparmor（加固系统）和 Snort（巡逻）都是为了强化安全,Keepalive监听服务器状态.]]></content>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云计算（三）搭建云计算环境]]></title>
    <url>%2F2018%2F04%2F15%2F%E4%BA%91%E8%AE%A1%E7%AE%9703%2F</url>
    <content type="text"><![CDATA[本文章主要介绍搭建云计算需要解决的问题。 Quick Guide 硬件资源 存储 采用SSD或者采用SATA+SSD的混合方式节约资源和降低成本。提供VM虚拟机运行环境的block device（块存储），以及提供KV方式的对象访问存储。 网络 对于公有云以及私有云的一些应用场景，需要能够提供网络的逻辑隔离（SDN）或物理隔离，以及对网络的访问灵活问题。需要构建虚拟化网络，对物理网络资源进行抽象并池化，以便于分割或合并资源来满足共享的目的。常用的方式是：bridge、vlan、gre、sdn（openflow、opendaylight）等等。 网络虚拟化发展 单个物理机的网络 多个物理机的网络 虚拟化 VM 使用Xen（XenServer、Oracle VM Server）、OpenVZ 、KVM(RHV)、Vmware、VirtualBox等虚拟技术进行虚拟化，虚拟化后可以安装开源操作系统（Linux 内核、FreeBSD、Illumos 内核 )，通过 OpenStack、CloudStack 、Eucalyptus和Oracle VM Manager 等等去管理分配资源 容器化：可以使应用服务化 对于各个应用场景来说，VM本身的启动需要占用大量的内存、cpu和存储资源，导致系统内存和cpu使用有一定的浪费，容器化是一种轻量级的实现，能够在资源初始化，资源利用率方面能够最大化。例如Linux-VServer、LXC、FreeBSD jail、Solaris Containers、Docker、Rocket/rkt 和openVZ/Odin等容器技术，Dokcer是通过Kubernetes管理。 管理和使用 远程桌面：VDI可以远程登陆虚拟主机 高可用：集群负载均衡和容灾 高可用问题是在分布式系统中必须要处理的问题，需要保证云管理系统的高可用性，存储介质的高可用性，网络的高可用性，虚拟机高可用问题等等。 集群 任务的拆分:尽量降低子任务之间的关联性，从而提高处理任务的并行度。 任务的调度:把拆分出来的子任务合理地调度给云端服务器并让它们协同完成,最能满足租户要求的调度方法就是合理的 负载均衡:多租户请求合理分配（LVS nignx） 容灾： 检测服务器的状态：Keepalived 主从热备 租户隔离 租户行为隔离 资源隔离 租户数据隔离，数据隔离比行为隔离更重要。 分离数据库 共享数据库但分离 Schema 共享数据库和 Schema 安全问题 防火墙：使用外网防火墙 网络隔离：网络进行多层划分，控制每层的入口 流量统一管理：API网关作为统一出入口 统一身份认证： 统一用户管理（Identification） ：租户的账号、密码等信息集中存储，统一管理 身份鉴别（Authentication）：当租户企图登录某个应用系统时，验证他的票据或者身份是否合法。 权限控制（Authorization）：规定允许登录系统的租户具备哪些操作权限。 操作日志登记（Accountability）：记录租户的操作行为，以便事后责任追溯。 具体实践]]></content>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云计算（二）云计算的角色]]></title>
    <url>%2F2018%2F03%2F15%2F%E4%BA%91%E8%AE%A1%E7%AE%9702%2F</url>
    <content type="text"><![CDATA[本文章主要介绍什么是云计算的角色。 Quick Guide 角色 定义 云服务消费者 租赁云服务产品的个人或单位组织 云服务提供商 提供云服务产品的个人或单位组织，如中国电信天翼云、阿里云、腾讯云等 云服务代理商 代理云服务提供商向消费者销售云计算服务并获取一定佣金的个人或者单位组织 云计算审计员 能对云计算安全性、云计算性能、云服务及信息系统的操作开展独立评估的第三方个人或者单位组织 云服务承运商 在云服务提供商和云服务消费者之间提供连接媒介，以便把云计算服务产品从云服务提供商那里转移到云服务消费者手中，如中国电信。但是广域网商和因特网商不属于云服务承运商 不同角色的交互关系： 云服务消费者从云服务提供商或者云服务代理商那里租赁云服务产品，在合同期内和云服务提供商保持一种供/需业务关系。 不同云服务类型的消费者使用云服务产品和流程也不同： 云服务提供商个人或者单位组织，他们负责搭建云端并对外提供云服务产品。支撑云服务的 IT 层可以由云服务提供商自己组建，也可以租赁其他人的云服务。 云服务提供商的五大任务包括服务部署、服务编排、云服务管理、安全保障和隐私保护 服务部署：参考上一章 云计算的形式 服务编排：指把各种系统组件合理地整合在一起，以便向云服务消费者提供云服务产品。分为三层，上层依赖直接下层。资源抽象与控制层利用下层的物理资源，向上层暴露资源池，而顶部的服务层利用下层的资源池向云服务消费者暴露服务接口，而云服务消费者不能直接操纵底层的物理资源。 顶部的服务层定义了云服务消费者访问计算资源的接口（简称访问接口）——IaaS、PaaS 和 SaaS。 中间层是资源抽象与控制层，包括两类系统组件： 12341）抽象组件主要用于对物理计算资源进行虚拟化，虚拟化之后的资源就可以放入资源池中，以便将来供云服务消费者弹性租赁。抽象组件包括虚拟机管理平台（Hypervisor）、虚拟机软件（VM）、软件定义存储（SDS）、软件定义网络（SDN）等，其中虚拟机技术是最常见的资源抽象组件。无论如何，抽象组件必须能确保高效、安全和可靠地运用底层的物理资源。2）控制组件:主要负责资源分配、访问控制和监控资源使用等。总之，本层的主要功能是把物理资源池化并有效管理被池化后的资源。 底层是物理资源层，包含所有的物理计算资源——物理服务器（主要包含 CPU、内存计算资源）、网络设备（路由器、防火墙、交换机、网卡等）、存储设备（如硬盘、存储阵列），以及其他物理的计算设施；也包含基础设施资源，如加热器、空调、通风设备、供电设备等。 云服务管理:云服务管理是指云服务提供商必须履行的一套流程和任务，以便圆满地把云服务交付给消费者。 业务支持这是与客户有关的活动和服务，具体包括如下表所示。 名称 说明 租户管理 管理租户账号、激活/禁用/终止账号、管理用户资料、解决租户提出的问题、处理投诉等。 合同管理 管理服务合同、洽谈/签订/关闭/终止合同等。 云服务产品管理 建立和管理云服务产品目录，以便用户浏览和选择等。 费用结算 生成发票并送交客户，回收款项，尽量做到现收现付。 报表与审计 监视用户消耗资源状况，产生有关报表，履行事后监督和审计。 价格管理 给云服务产品建立价格点和价格分层，监视竞争对手的报价并及时调整产品价格以确保竞争力。云服务提供商通常会给大客户提供价格折扣或者信用消费（先消费后付款）。 * 交付与配置 名称 说明 快速交付 能快速响应用户的弹性需求，最好是自动化响应。 资源变更 包括替换故障设备、升级设备、添加新设备，从而扩充资源容量，以及重新配置现有的设备。 资源监控 发现和监视虚拟资源，监视云端操作和事件，并且产生性能报表。 计量 定义付费的计量方法，比如根据某类资源（如存储、CPU、内存、网络带宽等）的使用量和时间长短计费，也有按照每使用一次计费的，还有的是较复杂的公式。 服务水平协议（SLA）管理 具体涵盖 SLA 定义、SLA 实施监督和 SLA 执行评价，目的是保证服务质量。 * 可移植性与互操作性 安全保障 3 种云服务模式蕴含的安全问题 4 种部署模型蕴含的安全问题 安全职责共担 隐私保护 云服务审计员云计算审计员能对云计算利益相关者开展独立检查并发布评估结果，审计的核心任务就是通过对客观证据的审查来评估是否符合预设的标准。针对云服务提供商的审计主要包括安全审计、隐私保护审计和性能审计等。 安全审计云计算审计员评估云服务提供商是否具备足够的且准备妥当的安全控制措施以及是否严格遵守切实可行的安全流程。例如，云计算审计员审查云服务提供商是否遵守了 ISO 27001 安全标准。 隐私保护审计隐私保护审计主要检查云服务提供商是否保护了个人信息（PI）和个人身份信息（PII）。 性能审计云服务提供商必须满足在服务水平协议（SLA）中列举的服务质量（QoS）的要求，但是云服务消费者往往抱怨其利益受到损害，而云服务提供商也常常表示无辜，只有通过第三方独立开展性能审计才能消除供/需双方的分歧。 云服务代理商1）服务中介云服务代理商处于云服务提供商和云服务消费者之间，他是云服务提供商的客户，又充当云服务消费者的云服务提供商。云服务代理商尽可能地改善一些云服务产品并给消费者提供增值服务，这些改善措施包括但不限于强化安全、完善性能报告、优化身份管理、做好本地化（语言、本地人的习惯、本地法律法规等）以及增强用户的交互体验等。2）服务聚合云服务代理商把多个服务整合成一个或几个新的服务，以满足用户复杂的需求，同时提供数据集成，使得云服务消费者和多个云服务提供商之间的数据移动是安全的。示意图如图 2 所示。3）服务套利“套利”意为快速买卖以赚取差价。这里的服务套利类似于服务聚合，但是被聚合的服务是不固定的，云服务代理商可随时在多个云服务提供商的产品中筛选最好的服务。比如，云服务代理商可以使用信用评分措施来衡量和挑选分数最高的云服务提供商。服务聚合 云服务承运商云服务承运商负责在云服务提供商和云服务消费者之间建立连接媒介，以便把云计算服务产品从云服务提供商那里转移到云服务消费者手中。 云服务的分发工作通常由网络和电信运营商或者专门的传输代理机构完成。传输代理机构是指提供诸如大容量磁盘这种物理的传输存储媒介的业务机构。为了保证服务质量，云服务提供商会和云服务承运商签订服务水平协议（SLA），还可能要求云服务承运商提供专线，以保证云服务供需双方的连接安全。]]></content>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云计算（一）云计算的基本概念]]></title>
    <url>%2F2018%2F02%2F15%2F%E4%BA%91%E8%AE%A1%E7%AE%9701%2F</url>
    <content type="text"><![CDATA[本文章主要介绍什么是云计算。 Quick Guide传统it架构典型的 IT 系统如下图所示 注：IT 就是信息（Information）与技术（Technology），其中 I 是目的，T 是手段，T 是用来加工处理 I 的。 随着应用复杂的复杂化（不断增长的需求需要支持更多的用户、更强的计算能力和更加稳定安全等）： 硬件成本增加 软件成本增加 人力成本增加 所以企业就需要承担不断增大的成本。 云计算早期概念，云计算（cloud computing）是分布式计算的一种，指的是通过网络“云”将巨大的数据计算处理程序分解成无数个小程序，然后通过多部服务器组成的系统进行处理和分析这些小程序得到结果并返回给用户。 现阶段所说的已经不单单是一种分布式计算，而是通过虚拟化把硬件资源变成一个大虚拟资源池，再按需分配成各个小资源池，把软件部署到小资源池上，形成服务化，这样软硬件资源都都可以共享和重复利用。一定程度上优化了物理资源，用户不再需要昂贵、存储空间大的主机，可以选择相对廉价的PC组成云，一方面减少费用，另一方面计算性能不逊于大型主机。也可以节约人力成本。 云计算的优缺点 优点: 提高IT设备使用率，并降低设备量，利于企业之间或者个人之间共享信息，打破信息孤岛。 降低了消费者信息技术成本：前期投入和日常使用成本得到大幅度降低，同时也降低了因各种IT事故导致的损失。 提高了数据的安全性 提高了应用系统的可靠性 提高了用户体验：当今网络无处不在，云计算消费者可以随时随地采用任何云终端接入云端并使用云中的计算资源，真正实现移动办公。 降低软件使用门槛，可以让个人和中小企业使用大型昂贵软件，高性能计算机 从复杂的 IT 技术泥潭中摆脱出来，专注于自己的核心业务和市场。 能快速响应消费者对计算资源的弹性需求，从而能及时满足企业的业务变化。在传统 IT 系统下，一项新业务对 IT 资源的扩容要求，往往在数月或者一年后才能得到满足，这使得市场人员和管理层往往难以接受，因为市场是瞬息万变的。 缺点: 严重依赖网络。 12没有网络的地方，或者网络不稳定的地方，消费者可能根本无法使用云服务或用户体验很差。但这并不是云计算固有的缺陷，随着网络普及越来越广、网速越来越快，甚至是城市无线 Wi-Fi 全覆盖、国家无线 Wi-Fi 全覆盖的到来，将使网络不再是问题。 针对这个问题，现在有一些胖云终端产品，它会把一些常见的应用程序驻留在本地，同时缓存数据，当网络良好时，数据自动与云端同步。 数据可能泄密的环节增多。 1云端、灾备中心、离线备份介质、网络、云终端、账号和密码，这些都有可能成为信息的泄密点。但是云计算使得数据信息遭到非人为因素破坏的概率大大降低了，比如在传统IT系统中，存储设备损坏、机房火灾、地震、雷劈、洪水等都会破坏数据，而在云计算环境则没有这些隐患。总之，云计算消除了一些数据泄密和破坏点，但是又带来了一些新的不安全因素。 相对于传统的分散计算，云计算把计算资源集中在一起，因而风险也被集中在一起。 1云端成了单点故障，如果云端发生事故，则影响面将非常巨大。目前常见的应对措施是数据冗余存储、建立灾备中心、建立双活数据中心等。 用户对数据和技术的掌控灵活度下降。 云计算的形式根据面对的使用的人群、使用的方式和部署形式，分为四种。 公有云公有云就是 第三方的公有云供应商 为用户（个人或企业）提供可通过互联网访问的虚拟环境中的服务器空间。然后用户可以通过购买云服务器、数据存储和其他与云相关的服务等公有云服务来访问这些服务器。 优点: 成本更低 — 无需购买硬件或软件，仅对使用的服务按量付费。 无需维护 — 维护由服务提供商提供。 近乎无限制的缩放性 — 提供按需资源，可满足业务需求。 高可靠性 — 具备众多服务器，确保免受故障影响。 缺点: 安全性差 数据私密性差 使用场景:公有云部署通常用于提供基于 Web 的电子邮件、网上办公应用、存储以及测试和开发环境。 私有云私有云是为一个企业或组织提供专用的云环境。私有云可以由企业或组织内部的IT团队在该组织的防火墙后面进行内部操作，因此组织可以更好地控制其计算资源。私有云主要由企业使用，因此它也被视为一种企业云。私有云可在物理上位于组织的现场数据中心，也可由第三方服务提供商托管。 本地私有云 托管私有云 优点: 灵活性更高 — 组织可自定义云环境以满足特定业务需求。 安全性更高 — 资源不与其他组织共享，从而可实现更高控制性和安全性级别。 缩放性更高 — 私有云仍然具有公有云的缩放性和效率。 完全支持自定义 缺点: 成本高 需要自己维护 使用场景:私有云的使用对象通常为政府机构、金融机构以及其他具备业务关键性运营且希望对环境拥有更大控制权的中型到大型组织。 混合云混合云通过安全连接（如VPN连接或租用线路）组合一个或多个公有云和私有云环境，从而允许在不同云环境之间共享数据和应用程序。当在私有云上运行的应用程序遇到使用高峰时，它们可以自动“突发”到公有云环境以获得额外的按需容量。由于额外的需求将在公有云上，因此无需担心提前配置硬件以满足高峰需求。连接公有云和私有云有两种方法：VPN和点对点专用连接。 优势 控制和安全性 — 组织可针对敏感资产维持私有基础结构。 灵活性 — 需要时可利用公有云中的其他资源。 成本效益低 — 具备扩展至公有云的能力，因此可仅在需要时支付额外的计算能力。 弹性伸缩 — 无需费时费力即可转换至云，因为可根据时间按工作负荷逐步迁移。 近乎无限制的缩放性 — 提供按需资源，可满足业务需求。 使用场景:混合云的使用对象通常由大流量的互联网业务，同时部分业务有合规需求或者需要充分利用现有IT资产的企业或组织。 社群云社群云，也称社区云，是由几个组织共享的云端基础设施，它们支持特定的社群，有共同的关切事项，例如使命任务、安全需求、策略与法规遵循考量等。管理者可能是组织本身，也能是第三方；管理位置可能在组织内部，也可能在组织外部。 本地社区云 托管社区云 使用场景:社群云的使用对象通常是多个有密切关系的组织一起联合使用。 云计算的服务根据使用对象所需要的服务类型不一样，可以划分成三种，如下图所示： IaaS基础设施即服务（Infrastructure as a Service，IaaS） 云服务提供商把 IT 系统的基础设施层作为服务出租出去，由消费者自己安装操作系统、中间件、数据库和应用程序 IaaS 云端的基本架构模型逻辑上分为三层： 第一层（云管理器） 1云管理器是云端对外的总入口，在这里验证用户身份，管理用户权限，向合法用户发放票据（然后用户持此票据使用计算资源）、分配资源并管理用户租赁的资源。 第二层（集群管理器） 123每一个集群负责管理本集群内部的高速互联在一起的计算机，一个集群内的计算机可能有成百上千台。集群管理器接受上层的资源查询请求，然后向下层的计算机管理器发送查询请求，最后汇总并判断是部分满足还是全部满足上层请求的资源，再反馈给上层。如果接下来收到上层分配资源的命令，那么集群管理器指导下层的计算机管理器进行资源分配并配置虚拟网络，以便能让用户后续访问。另外，本层 PLS 中存储了本集群内的全部虚拟机镜像文件，这样一台虚拟机就能在集群内任意一台计算机上运行，并轻松实现虚拟机热迁移。 第三层（计算机管理器） 1每台计算机上都有一个计算机管理器，它一方面与上层的集群管理器打交道，另一方面与本机上的虚拟机软件打交道。它把本机的状态（如正在运行的虚拟机数、可用的资源数等）反馈给上层，当收到上层的命令时，计算机管理器就指导本机的虚拟机软件执行相应命令。这些命令包括启动、关闭、重启、挂起、迁移和重配置虚拟机，以及设置虚拟网络等。 基本架构模型如下图所示： PaaS平台即服务（Platform as a Service，PaaS） 云服务提供商把 IT 系统中的平台软件层作为服务出租出去，消费者自己开发或者安装程序，并运行程序。 PaaS 云服务的消费者主要包括以下人员： 程序开发人员：写代码、编译、调试、运行、部署、代码版本控制等，一揽子解决。 软件部署人员：把软件部署到 PaaS 云端，便于管理不同版本之间的冲突。 应用软件管理员：便于配置、调优和监视程序运行性能。 应用程序最终用户/程序测试人员：这时 PaaS 云服务相当于 SaaS 云服务。 SaaS软件即服务（Software as a Service，SaaS） 云服务提供商把 IT 系统中的应用软件层作为服务出租出去，消费者不用自己安装应用软件，直接使用即可，这进一步降低了云服务消费者的技术门槛。]]></content>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动化测试（四）自动化测试方案的扩展和展望]]></title>
    <url>%2F2018%2F01%2F15%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%9504%2F</url>
    <content type="text"><![CDATA[本文章介绍自动化测试方案的扩展和展望。 Quick Guide功能 需求管理 创建和跟踪需求 文档管理 用例文档管理 业务文档 公共资料 问题单管理 自动化管理和运行 创建用例 支持多种来源导入用例模板，然后根据用例版面自动填充用例 复制已有用例进行修改 可以复用已有用例 运行用例 支持主流框架运行 支持页面发起测试并展示结果，支持用例调试与问题定位 支持任务包含用例集合，通过任务定时调度，生成报告发送责任人 用例支持环境变量切换运行不同环境 执行结果入库，进行同接口纵向对比统计和分析 自定义API 业务API支持在线调用 常用工具计算API 数据统计 需求量和消耗时间 问题数和线上问题 功能模块的关联关系 项目 功能特性 需求 关联问题单 用例文档 自动化用例 业务文档 公共文档 环境信息 常用工具和流程 架构 发展趋势 通过接口或者业务定义自动生成用例 支持专项测试 通过项目的数据分析,判断项目风险程度]]></content>
      <tags>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动化测试（三）自动化测试方案的优化]]></title>
    <url>%2F2017%2F12%2F15%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%9503%2F</url>
    <content type="text"><![CDATA[本文章介绍自动化测试方案的优化。 Quick Guide用例选择的优化 用例级别划分：p0+p1:p2:p3 数量比例 = 2:7:1 p0: 冒烟用例 保证流程基本走通 p1: 基本功能测试 p2: 复杂功能测试 p3: 异常场景 优先覆盖p0和p1 用例层级 单元测试:场景覆盖百分百 API:正常调用和健壮性场景覆盖 WEB:所有页面和用户常见操作 用例优化：20%用例覆盖80%场景 用例执行的优化快构建快 执行快 自动化任务划分 根据执行时间拆分:执行时间 1min内 1~5min 超过5min 根据用例级别拆分:冒烟测试和全量测试 并发和分布执行 定位快 日志要包含关键信息: 函数执行前后要有开始和完成日志 数值计算要有结果日志 日志类别划分: debug:详情运行日志 info :重要运行日志 warn:警告信息 error:错误信息 多 多套环境:环境变量参数化,让用例可以在多套环境分别执行 开发环境 测试环境 类生产环境 提高用例的自动化率 减少用例:区分用例难度,实现对应策略解决 没有时间实现 实现难度大 暂时无法实现 防止自动化用例堆积 完成功能测试,需要完成p0和p1用例 划分责任人去实现 稳:用例稳定性 增加重试机制 增加等待机制灵活和准确 提高校验的容错性 提高用例方案的稳定性 ui用例:可以要求开发固定页面元素id,减少元素定位不稳定 与项目开发结合持续集成 持续交付 持续部署 持续集成—&gt;持续交付—&gt;持续部署: 提交代码 —-&gt; 代码静态检查—-&gt; 代码规范审核—-&gt; 单元测试—-&gt; 构建版本包 (完成持续集成) 失败 —-&gt; 回滚代码 —-&gt; 发邮件给提交代码人员 版本包部署开发环境 —-&gt; 进行冒烟测试—-&gt; 进行全量测试 版本包部署测试环境 —-&gt; 进行冒烟测试—-&gt; 进行全量测试 版本包部署uat环境 —-&gt; 进行冒烟测试—-&gt; 进行全量测试 失败 —-&gt; 发邮件给提交开发和测试人员 版本包部署线上(完成持续交付)—-&gt; 进行冒烟测试—-&gt; 进行全量测试(完成持续部署)]]></content>
      <tags>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动化测试（二）自动化测试方案设计]]></title>
    <url>%2F2017%2F11%2F15%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%9502%2F</url>
    <content type="text"><![CDATA[本文章介绍自动化测试方案设计。 Quick Guide方案选择自动化测试框架的类型 单的录制／回放：由工具录制并记录操作的过程和数据形成脚本，通过回放来重复人工操作的过程。在这种模式下数据和脚本混在一起，几乎一个测试用例对应一个脚本，维护成本很高。而且即使界面的简单变化也需要重新录制，脚本 可重复使用的效率低。 数据驱动 （data driven） 的自动化测试：从数据文件读取输入数据，通过变量的参数化，将测试数据传入测试脚本，不同的数据文件对应不同的测试用例。在这种模式下数据和脚本分离，脚本的利用率、可维护性大大提高，但受界面变化的影响仍然很大。 关键字驱动（keyword driven） 的自动化测试：关键字驱动测试是数据驱动测试的一种改进类型，它将测试逻辑按照关键字进行分解，形成数据文件，关键字对应封装的业务逻辑。主要关键字包括三类：被操作对象（Item）、操作（Operation）和值（value）， 用面向对象形式可将其表现为Item.Operation（Value）。 关键字驱动的主要思想是：脚本与数据分离、界面元素名与测试内部对象名分离、测试描述与具体实现细节分离。 行为驱动测试框架：支持自然语言作为测试用例描述的自动化测试框架。 考虑的因素 根据团队技术基础 如果团队有编码基础，选择跟开发技术栈一致 没有，选择简单易学工具或者编程语言（python/js） 业务的场景应用 如果偏向后端测试且业务简单，都是接口，可以考虑直接用接口工具（jmeter/postman）实现 如果web或者移动端，就需要测试框架能支持selenium/appium 如果业务复杂，尽量使用能编码的框架 业务的生命周期 方案设计分层设计： 高内聚低耦合 高内聚：就是每个模块尽可能独立完成自己的功能，不依赖于模块外部的代码； 低耦合：就是模块与模块之间接口的复杂程度，比如在类内部尽可能减少方法之间的调用，否则一个方法的变动会影响调用它的另一个方法。 操作组件 —&gt;功能点—–&gt;业务流程： 封装各个模块的底层API,构建上下游mock和fake, 通过调用单一个模块进行 功能点的验证 通过模块组合实现对业务流程的验证。 页面PO设计 以每个页面为单独一个类,页面中的控件为属性，控件的操作作为方法 组合不同方法去完成用户操作 脚本分离设计 封装基础函数、基本的业务逻辑、验证点 对象、操作、测试数据、业务逻辑相互剥离、灵活调用 结构化管理 用例目录结构化和命名规范 Project/Resource/Method/Request命名。 TestSuit/TestCase/TestStep命名，呈现特性树，方便通过每个特性的用例数和功能点 信息一体化：基本信息的编写（比如用例场景、用例维护人员、自动化用例）和项目文档（业务API、需求需求文档、环境信息和常用命令）能在一个地方统一跳转过去 对象、操作组件、基础函数、测试数据 结构化 参数化 环境参数化 脚本参数化 用例 功能特性1 测试数据 输入数据 验证结果 测试脚本 相关资料文档 功能特性2 公共库 业务逻辑 第三方库 自定义库 公共文档 环境变量 方案执行有效的执行体系 批量、定制执行、自动运行 异常处理机制（重试或者跳过） 业务数据还原初始状态 版本管理 结果体系 针以每条用例，输出用例执行结果 针对每个检查点，输出详细的检查点执行结果 输出执行日志]]></content>
      <tags>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动化测试（一）自动化测试的基本概念]]></title>
    <url>%2F2017%2F10%2F15%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%9501%2F</url>
    <content type="text"><![CDATA[自动化测试：指通过自动化测试工具或者轮子模拟手工测试并验证其结果完成整个测试过程。本文章介绍自动化测试的基本概念。 Quick Guide为什么要进行自动化测试 自动化测试节约人力和时间成本：版本迭代的回归测试 有些测试项目手工很难实现：例如性能测试 项目质量流程和持续集成的需要 自动化测试的优缺点 优点 避免测试人员因重复劳动产生厌倦 提高测试效率 保证每次测试地一致性和可重复性 更好的利用无人值守时间 进行一些手工无法进行的测试 缺点 维护成本相对比较高 测试时间不一定能缩短 没有手工测试发现缺陷多 UI 层面显示问题不容易发现 什么样的项目适合做自动化测试 功能变动少 周期长 项目测试资源足够 自动化测试 掌握一门开发语言: 与开发技术栈一致 推荐：java/python/go 熟悉被测系统 web测试 ：js+css+html 移动端测试：Android 和iOS开发基础 C/S测试：TCP、IP协议 掌握一套自动化测试框架 python Robot Framework：关键字驱动测试（高级封装 类配置化） 优点 需要的基础低，易学易写 支持多重封装，可以使用python封装方法 拥有庞大的生态系统，丰富的第三方扩展库 缺点 用例庞大，用例管理加载时间很久 业务逻辑比较复杂和特殊，封装成本较大 控制语句只有if/for，不支持多层嵌套 应用 接口：HTTP library (livetest)、HTTP library (Requests)等。 web： SeleniumLibrary，Selenium2Library，Selenium2Library for Java、watir-robot 等。 Windows GUI：AutoItLibrary 移动端：Android library、iOS library、AppiumLibrary 等。 数据库测试：Database Library (Java)、Database Library (Python)、MongoDB library 等。 文件对比测试：Diff Library。 用例管理：wxPython、 RIDE 并发测试：pabot 分布式测试：selenium grid UnitTest：Python自带的一个单元测试框架 优点 开发人员不需要安装任何其他模块。 Unittest是xUnit的衍生产品，其工作原理与其他xUnit框架类似。 没有强大 Python背景的人也容易使用。 您可以以更简单的方式运行单个测试用例。 您需要做的就是在终端上指定名称。 输出也很简洁，使得框架在执行测试用例时更加灵活。 测试报告在几毫秒内生成。 缺点 通常，snake_case用于命名python代码。 但是由于这个框架受到Junit的启发，传统的camelCase命名方法仍然存在。 这可能很混乱。 要求一定的python基础 需要较多的代码 应用 接口：requests web：selenium window GUI：pywinauto window进程：win32api 移动端 GUI：appium 数据库:hbase（thrift hbase-thrift）、mysql（pymysql）、redis 、hive（sasl thrift thrift-sasl pyhive）、implala Pytest：基于unittest的扩展框架，比unittest更简洁高效 优点 pytest可以直接运行unittest模式的测试用例 能够支持简单的单元测试和复杂的功能测试，支持xfail pytest具有很多第三方插件，并且可以自定义扩展 缺点 要求一定的python基础 应用 测试报告： pytest-html web：pytest-selenium 失败用例重试： pytest-rerunfailures 多CPU分发：pytest-xdist Behave：与SpecFlow和Cucumber非常相似，常被用于执行自动化测试。 优点 系统行为由半正式语言和域词汇表表达，以保持组织中的行为一致。 正在协调处理具有类似功能的不同模块的开发团队。 构建块总是可以执行各种测试用例。 细节中有推理和思考，从而产生更好的产品规格。 由于规范的格式相似，利益相关者或管理者对QAs和Devs的输出有更好的清晰度。 缺点 只适用于黑盒测试。 Lettuce：基于Cucumber和Python的行为驱动类自动化工具 优点 好吧，就像任何其他BDD测试框架一样，Lettuce使开发人员能够创建多个场景并用简单的自然语言描述这些功能。 Dev和QA团队得到了适当的协调，因为规格格式相似。 对于黑盒测试，Lettuce对于运行行为驱动的测试用例非常有用。 缺点 只适用于黑盒测试。 java JUnit 优点 庞大的社区 缺点 无法执行依赖性测试 TestNG 优点 JUnit升级版 缺点 用户需要一些时间来设置TestNG JBehave：一种通过Selenium WebDriver来针对BDD开展Java测试的框架。 Serenity：种能被用于行为驱动测试的开源库。该框架可帮助您编写出各种结构良好、且易于维护的验收标准。它在一定程度上扩展了JUnit和WebDriver的功能。 Selenide：由Selenium提供的Selenide，可用作为Java应用程序编写稳定、精确且具有友好UI的测试用例。 go GoConvey GoCheck GoMock GoMonkey GoMocket]]></content>
      <tags>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部署Prometheus]]></title>
    <url>%2F2017%2F10%2F15%2F%E9%83%A8%E7%BD%B2Prometheus%2F</url>
    <content type="text"><![CDATA[Prometheus是一个开源的服务监控系统，它通过HTTP协议从远程的机器收集数据并存储在本地的时序数据库上。本文章介绍如何在Centos7.5下面部署一套监控系统（Prometheus+Node_Exporter+Grafana）。 Quick Guide安装Prometheus 1.下载安装 123wget https://github.com/prometheus/prometheus/releases/download/v2.7.1/prometheus-2.7.1.linux-amd64.tar.gztar -C /usr/local/ -zxvf prometheus-2.7.1.linux-amd64.tar.gzcd /usr/local/prometheus-2.7.1.linux-amd64/ 2.设置用户 12345678910# 添加用户groupadd prometheususeradd -g prometheus -s /sbin/nologin prometheus# 赋权限chown -R prometheus:prometheus /usr/local/prometheus-2.7.1.linux-amd64/# 创建prometheus运行数据目录mkdir -p /var/lib/prometheuschown -R prometheus:prometheus /var/lib/prometheus/ 3.配置systemd成服务，用 systemd 来开机启动 123456# 创建配置文件touch /usr/lib/systemd/system/prometheus.servicechown prometheus:prometheus /usr/lib/systemd/system/prometheus.service# 复制下面内容到配置文件vim /usr/lib/systemd/system/prometheus.service 123456789101112131415[Unit]Description=PrometheusDocumentation=https://prometheus.io/After=network.target[Service]# Type设置为notify时，服务会不断重启Type=simpleUser=prometheus# --storage.tsdb.path是可选项，默认数据目录在运行目录的./dada目录中ExecStart=/usr/local/prometheus-2.7.1.linux-amd64/prometheus --config.file=/usr/local/prometheus-2.7.1.linux-amd64/prometheus.yml --storage.tsdb.path=/var/lib/prometheusRestart=on-failure[Install]WantedBy=multi-user.target 123# 设置开机启动systemctl enable prometheussystemctl start prometheus 4.设置iptables 12# 新增下面规则vim /etc/sysconfig/iptables 12# 规则-A INPUT -p tcp -m state --state NEW -m tcp --dport 9090 -j ACCEPT 12# 重启 iptablesservice iptables restart 5.查看服务状态 12345# 查看版本./prometheus --version# 查看状态systemctl status prometheus 6.使用浏览器访问http://&lt;service_ip:9090&gt; 安装Node_ExporterPrometheus Server并不直接服务监控特定的目标，其主要任务负责数据的收集，存储并且对外提供数据查询支持。因此需要在被监控主机上安装Exporter,Prometheus周期性的从Exporter暴露的HTTP服务地址（通常存放采样数据的地址是/metrics)）拉取监控样本数据。 1.部署 12345678# 下载cd /usr/local/src/wget https://github.com/prometheus/node_exporter/releases/download/v0.17.0/node_exporter-0.17.0.linux-amd64.tar.gz# 部署tar -zxvf node_exporter-0.17.0.linux-amd64.tar.gz -C /usr/local/cd /usr/local/mv node_exporter-0.17.0.linux-amd64/ node_exporter/ 2.新增用户 123groupadd prometheususeradd -g prometheus -s /sbin/nologin prometheuschown -R prometheus:prometheus /usr/local/node_exporter/ 3.设置开机启动 12# 创建配置文件，把下面配置复制进去vim /usr/lib/systemd/system/node_exporter.service 12345678910111213[Unit]Description=node_exporterDocumentation=https://prometheus.io/After=network.target[Service]Type=simpleUser=prometheusExecStart=/usr/local/node_exporter/node_exporterRestart=on-failure[Install]WantedBy=multi-user.target 123# 设置开机启动systemctl enable node_exportersystemctl start node_exporter 4.设置iptables 12# 新增下面规则vim /etc/sysconfig/iptables 12# 规则-A INPUT -p tcp -m state --state NEW -m tcp --dport 9100 -j ACCEPT 12# 重启 iptablesservice iptables restart 5.使用浏览器访问http://&lt;monitor_ip:9100&gt; 配置Prometheus 修改配置 12# 新增配置到配置文件vim /usr/local/prometheus-2.7.1.linux-amd64/prometheus.yml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 全局配置global: scrape_interval: 15s # 设置抓取时间间隔为15s，默认是1m evaluation_interval: 15s # 设置rules评估时间间隔为15s，默认是1m # scrape_timeout is set to the global default (10s).# 告警管理配置alerting: alertmanagers: + static_configs: + targets: # - alertmanager:9093# 加载rules，并根据设置的时间间隔定期评估，暂未使用，默认配置rule_files: # - "first_rules.yml" # - "second_rules.yml"# 抓取(pull)，即监控目标配置# 默认只有主机本身的监控配置scrape_configs: # 监控目标的label（这里的监控目标只是一个metric，而不是指某特定主机，可以在特定主机取多个监控目标），在抓取的每条时间序列表中都会添加此label - job_name: 'prometheus' # metrics_path defaults to '/metrics' # scheme defaults to 'http'. # 新增：可覆盖全局配置设置的抓取间隔，由15秒重写成5秒。 scrape_interval: 5s # 静态指定监控目标，暂不涉及使用一些服务发现机制发现目标 static_configs: - targets: ['localhost:9090'] # 以下都为新增：(opentional)再添加一个label，标识了监控目标的主机 labels: instance: prometheus - job_name: 'linux' scrape_interval: 10s static_configs: # 采用node_exporter默认开放的端口 - targets: ['10.1.2.3:9100'] labels: instance: node1 2.重启服务 1systemctl start prometheus 3.使用浏览器访问http://&lt;monitor_ip:9100&gt;,点击status的targets 部署Grafana为了监控数据展示更好看,我们安装Grafana.它是用于可视化大型测量数据的开源程序，能Dashboard中显示了你不同metric数据源中的数据。 1.部署 123cd /usr/local/src/wget https://dl.grafana.com/oss/release/grafana-6.0.0-1.x86_64.rpm sudo yum localinstall grafana-6.0.0-1.x86_64.rpm 2.配置文件 配置文件位于/etc/grafana/grafana.ini，这里暂时保持默认配置即可。 3.设置开机启动 12systemctl enable grafana-serversystemctl start grafana-server 4.设置iptables 12# 新增下面规则vim /etc/sysconfig/iptables 12# 规则-A INPUT -p tcp -m state --state NEW -m tcp --dport 3000 -j ACCEPT 12# 重启 iptablesservice iptables restart 5.添加数据源 使用浏览器访问http://&lt;server_ip&gt;:3000，默认账号/密码：admin/admin 在登陆首页，点击”Add data source”按钮，选择Prometheus, 取消Default的勾选,URL选择一下默认配置,其他不变,然后点击Save&amp;Test 在”Dashboards”页签下”import”自带的模版 6.下载模板导入dashboard(可选) 选择左上角图标+–&gt;import 填写url或者id,例如https://grafana.com/dashboards/405,点击Upload会自动下载模板 数据源选择”prometheus”，即添加的数据源name，点击”Import”按钮 7.查看dashboard 选择Dashboard–&gt;Home 列表中可见有已添加的两个dashboard，选择1个即可，如下： More info: Grafana Github Prometheus Github]]></content>
      <tags>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux系统监控工具]]></title>
    <url>%2F2017%2F09%2F15%2FLinux%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[多数 Linux 发行版都附带了监控工具。这些工具提供了获取系统活动的相关指标,可以用来查找问题的可能原因。文章介绍使用监控工具的基本命令。 Quick Guide基本Top – 进程活动监控命令 1.命令格式： 1top [参数] 2.命令功能：显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等 3.命令参数： 123456789-b 批处理-c 显示完整的治命令-I 忽略失效过程-s 保密模式-S 累积模式-i&lt;时间&gt; 设置间隔时间-u&lt;用户名&gt; 指定用户名-p&lt;进程号&gt; 指定进程-n&lt;次数&gt; 循环显示的次数 4.实例 显示进程信息:top 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061top - 10:47:44 up 91 days, 20:45, 1 user, load average: 0.08, 0.04, 0.05Tasks: 85 total, 1 running, 84 sleeping, 0 stopped, 0 zombie%Cpu(s): 1.3 us, 2.0 sy, 0.0 ni, 62.0 id, 34.7 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem : 1882892 total, 70220 free, 228056 used, 1584616 buff/cacheKiB Swap: 1049596 total, 908028 free, 141568 used. 1419140 avail Mem PID USER PR NI VIRT RES SHR S %MEM TIME+ COMMAND 27 root 20 0 0 0 0 S 0.0 3:12.62 kswapd0 # 统计信息区:# 第一行:任务队列信息# 10:47:44 — 当前系统时间# up 91 days, 20:45 — 系统持续运行多久# 1 user — 当前有2个用户登录系统# load average: 0.08, 0.04, 0.05 — 每隔5秒钟检查一次活跃的进程数,后面的三个数分别是1分钟、5分钟、15分钟的负载情况。# 第二行:Tasks — 任务（进程）# 85 total - 系统现有进程# 1 running - 处于运行中的进程数# 84 sleeping - 处于休眠的进程数# 0 stopped - 处于停止的进程数# 0 zombie - 处于僵尸的进程数# 第三行:cpu状态信息# 1.3 us — 用户空间占用CPU的百分比# 2.0 sy — 内核空间占用CPU的百分比# 0.0 ni — 改变过优先级的进程占用CPU的百分比# 62.0 id — 空闲CPU百分比# 34.7 wa — IO等待占用CPU的百分比# 0.0 hi — 硬中断（Hardware IRQ）占用CPU的百分比# 0.0 si — 软中断（Software Interrupts）占用CPU的百分比# 0.0 st — 虚拟机占用百分比# 第四行:内存状态# 1882892 total — 物理内存总量# 70220 free — 使用中的内存总量# 228056 used — 空闲内存总量# 1584616 buff/cache — 缓存的内存量# 第五行:swap交换分区信息# 1049596 total — 交换区总量# 908028 free — 空闲交换区总量# 141568 used — 使用的交换区总量# 1419140 avail Mem — 可用于进程下一次分配的物理内存数量# 第六行:空行# 第七行以下:各进程（任务）的状态监控# PID — 进程id# USER — 进程所有者# PR — 进程优先级# NI — nice值。负值表示高优先级，正值表示低优先级# VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES# RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA# SHR — 共享内存大小，单位kb# S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程# %CPU — 上次更新到现在的CPU时间占用百分比# %MEM — 进程使用的物理内存百分比# TIME+ — 进程使用的CPU时间总计，单位1/100秒# COMMAND — 进程名称（命令名/命令行） 显示完整命令:top -c 以批处理模式显示程序信息:top -b 以累积模式显示程序信息:top -S 设置信息更新次数:top -n &lt;更新次数&gt; 设置信息更新时间:top -d &lt;间隔时间s&gt; 显示指定的进程信息:top -p 显示指定的进程信息:top -p 显示指定的进程信息:top -p 5.使用技巧 多U多核CPU监控：在top基本视图中，按键盘数字“1”，可监控每个逻辑CPU的状况 高亮显示当前运行进程：敲击键盘“b”（打开/关闭加亮效果） 进程字段排序： 敲击键盘“x”（打开/关闭排序列的加亮效果） 通过”shift + &gt;”或”shift + &lt;”可以向右或左改变排序列 6.交互命令在top 命令执行过程中可以使用的一些交互命令。这些命令都是单字母的，如果在命令行中使用了s 选项，其中一些命令可能会被屏蔽。 交互命令 用法 m 是否显示内存信息 A 根据各种系统资源的利用率对进程进行排序，有助于快速识别系统中性能不佳的任务。 f或者F 进入 top 的交互式配置屏幕，用于根据特定的需求而设置 top 的显示。 o或者O 交互式地调整 top 每一列的顺序。 z 切换彩色或黑白模式 h 显示帮助画面，给出一些简短的命令总结说明 k 终止一个进程。 i 忽略闲置和僵死进程。这是一个开关式命令。 q 退出程序 r 重新安排一个进程的优先级别 S 切换到累计模式 s 改变两次刷新之间的延迟时间（单位为s），如果有小数，就换算成m s。输入0值则系统将不断刷新，默认值是5 s l 切换显示平均负载和启动时间信息 t 切换显示进程和CPU状态信息 c 切换显示命令名称和完整命令行 M 根据驻留内存大小进行排序 P 根据CPU使用百分比大小进行排序 T 根据时间/累计时间进行排序 W 将当前设置写入~/.toprc文件中 VmStat - 虚拟内存统计 1.命令格式： 1234567vmstat [-a] [-n] [-t] [-S unit] [delay [ count]]vmstat [-s] [-n] [-S unit]vmstat [-m] [-n] [delay [ count]]vmstat [-d] [-n] [delay [ count]]vmstat [-p disk partition] [-n] [delay [ count]]vmstat [-f]vmstat [-V] 2.命令功能：用来获得有关进程、虚存、页面交换空间及 CPU活动的信息。 3.命令参数： 1234567891011-a：显示活跃和非活跃内存-f：显示从系统启动至今的fork数量 。-m：显示slabinfo-n：只在开始时显示一次各字段名称。-s：显示内存相关统计信息及多种系统活动数量。delay：刷新时间间隔。如果不指定，只显示一条结果。count：刷新次数。如果不指定刷新次数，但指定了刷新时间间隔，这时刷新次数为无穷。-d：显示磁盘相关统计信息。-p：显示指定磁盘分区统计信息-S：使用指定单位显示。参数有 k 、K 、m 、M ，分别代表1000、1024、1000000、1048576字节（byte）。默认单位为K（1024 bytes）-V：显示vmstat版本信息。 4.实例 参数说明：vmstat 123 procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----r b swpd free buff cache si so bi bo in cs us sy id wa st2 0 141824 75964 112312 1470536 0 0 62 22 3 2 0 0 99 0 0 Procs（进程）参数 含义 说明 r 等待执行的任务数 展示了正在执行和等待cpu资源的任务个数。当这个值超过了cpu个数，就会出现cpu瓶颈。 b 等待IO的进程数量 Memory(内存)参数 含义 说明 swpd 正在使用虚拟的内存大小，单位k free 空闲内存大小 buff 已用的buff大小，对块设备的读写进行缓冲 cache 已用的cache大小，文件系统的cache inact 非活跃内存大小，即被标明可回收的内存，区别于free和active active 活跃的内存大小 Swap参数 含义 说明 si 每秒从交换区写入内存的大小（单位：kb/s） so 每秒从内存写到交换区的大小 IO参数 含义 说明 bi 每秒读取的块数（读磁盘） bo 每秒写入的块数（写磁盘） system参数 含义 说明 in 每秒中断数，包括时钟中断 值越大，会看到由内核消耗的cpu时间会越多 cs 每秒上下文切换数 这两个值越大，会看到由内核消耗的cpu时间会越多 CPU（以百分比表示）参数 含义 说明 Us 用户进程执行消耗cpu时间(user time) us的值比较高时，说明用户进程消耗的cpu时间多，但是如果长期超过50%的使用，那么我们就该考虑优化程序算法或其他措施了 Sy 系统进程消耗cpu时间(system time) sys的值过高时，说明系统内核消耗的cpu资源多，这个不是良性的表现，我们应该检查原因。 Id 空闲时间(包括IO等待时间) wa 等待IO时间 Wa过高时，说明io等待比较严重，这可能是由于磁盘大量随机访问造成的，也有可能是磁盘的带宽出现瓶颈。 显示活跃和非活跃内存：vmstat –a 查看内存使用的详细信息：vmstat -s 查看磁盘的读/写：vmstat -d Lsof - 列出打开的文件 1.命令格式： 1lsof [选项] [绝对路径的文件名] 2.命令功能：用于以列表的形式显示所有打开的文件和进程。打开的文件包括磁盘文件、网络套接字、管道、设备和进程 3.命令参数： 123456789-a 将结果进行“与”运算（而不是“或”运算）-l 在输出显示用户 id 而不是用户名-t 仅获取进程ID-i 显示所有连接 -h 获取lsof使用帮助-u 显示指定用户打开了什么 -U 获取 UNIX 套接口地址-p 查看指定进程ID已打开的内容-F 格式化输出结果，用于其他命令。可以通过多种方式格式化，如-F pcfn（用户进程ID、命令名、文件描述符、文件名，并以空终止） 4.实例 列出活跃进程的所有打开文件:lsof 123456789101112COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEhttpd 6279 root txt REG 8,2 344112 415135 /usr/sbin/httpd# COMMAND - 进程名称# PID - 进程标识符# USER: - 进程所有者# FD - 文件描述符，应用程序通过文件描述符识别到该文件。如cwd、txt等# TYPE - 文件类型，REG、DIR、CHR、BLK、UNIX、FIFO、IPV4# DEVICE: - 指定磁盘名称# SIZE - 文件大小# NODE - 索引节点（文件在磁盘上的标识）# NAME - 打开文件的确切名称 获取网络信息: 显示所有连接:lsof -i 仅获取 IPv6 流量:lsof -i 6 仅显示TCP连接:lsof -iTCP 显示指定到指定主机的连接:lsof -i@&lt;host_ip&gt; 显示基于主机与端口的连接:lsof -i@&lt;host_ip:port&gt; 找出监听端口:lsof -i -sTCP:LISTEN 找出已建立的连接:lsof -i -sTCP:ESTABLISHED 显示某个端口范围的打开的连接:lsof -i@:= 获取用户信息 显示指定用户打开了什么：lsof -u 显示除指定用户以外的其他所有用户所做的事情:lsof -u ^ 杀死指定用户所做的一切事情:kill -9 ‘lsof -t -u ‘ 查看指定的命令正在使用的文件和网络连接:lsof -c 查看指定进程ID已打开的内容:lsof -p Tcpdump - 网络分组分析器 1.命令格式： 123 tcpdump [ -adeflnNOpqStvx ] [ -c 数量 ] [ -F 文件名 ] [ -i 网络接口 ] [ -r 文件名] [ -s snaplen ] [ -T 类型 ] [ -w 文件名 ] [表达式 ] 2.命令功能：最广泛使用的网络包分析器或者包监控程序之一，它用于捕捉或者过滤网络上指定接口上接收或者传输的TCP/IP包。它还有一个选项用于把捕捉到的包保存到文件里，以便以后进行分析。 3.命令参数： 123456789101112131415161718192021222324252627282930313233343536-A 以ASCII格式打印出所有分组，并将链路层的头最小化。 -c 在收到指定的数量的分组后，tcpdump就会停止。 -C 在将一个原始分组写入文件之前，检查文件当前的大小是否超过了参数file_size 中指定的大小。如果超过了指定大小，则关闭当前文件，然后在打开一个新的文件。参数 file_size 的单位是兆字节（是1,000,000字节，而不是1,048,576字节）。 -d 将匹配信息包的代码以人们能够理解的汇编格式给出。 -dd 将匹配信息包的代码以C语言程序段的格式给出。 -ddd 将匹配信息包的代码以十进制的形式给出。 -D 打印出系统中所有可以用tcpdump截包的网络接口。 -e 在输出行打印出数据链路层的头部信息。 -E 用spi@ipaddr algo:secret解密那些以addr作为地址，并且包含了安全参数索引值spi的IPsec ESP分组。 -f 将外部的Internet地址以数字的形式打印出来。 -F 从指定的文件中读取表达式，忽略命令行中给出的表达式。 -i 指定监听的网络接口。 -l 使标准输出变为缓冲行形式，可以把数据导出到文件。 -L 列出网络接口的已知数据链路。 -m 从文件module中导入SMI MIB模块定义。该参数可以被使用多次，以导入多个MIB模块。 -M 如果tcp报文中存在TCP-MD5选项，则需要用secret作为共享的验证码用于验证TCP-MD5选选项摘要（详情可参考RFC 2385）。 -b 在数据-链路层上选择协议，包括ip、arp、rarp、ipx都是这一层的。 -n 不把网络地址转换成名字。 -nn 不进行端口名称的转换。 -N 不输出主机名中的域名部分。例如，‘nic.ddn.mil‘只输出’nic‘。 -t 在输出的每一行不打印时间戳。 -O 不运行分组分组匹配（packet-matching）代码优化程序。 -P 不将网络接口设置成混杂模式。 -q 快速输出。只输出较少的协议信息。 -r 从指定的文件中读取包(这些包一般通过-w选项产生)。 -S 将tcp的序列号以绝对值形式输出，而不是相对值。 -s 从每个分组中读取最开始的snaplen个字节，而不是默认的68个字节。 -T 将监听到的包直接解释为指定的类型的报文，常见的类型有rpc远程过程调用）和snmp（简单网络管理协议；）。 -t 不在每一行中输出时间戳。 -tt 在每一行中输出非格式化的时间戳。 -ttt 输出本行和前面一行之间的时间差。 -tttt 在每一行中输出由date处理的默认格式的时间戳。 -u 输出未解码的NFS句柄。 -v 输出一个稍微详细的信息，例如在ip包中可以包括ttl和服务类型的信息。 -vv 输出详细的报文信息。 -w 直接将分组写入文件中，而不是不分析并打印出来。 4.实例 监视第一个网络接口上所有流过的数据包:tcpdump 监视指定主机的数据包:tcpdump host &lt;host_ip&gt; 监视指定网络接口的数据包:tcpdump -i &lt;网卡&gt; 监视主机hostname发送的所有数据:tcpdump -i &lt;网卡&gt; src host 监视指定主机和端口的数据包:tcpdump port and host &lt;host_ip&gt; Netstat - 网络统计 1.命令格式： 1netstat [参数] 2.命令功能：用于监视传入和传出网络数据包统计信息以及接口统计信息。 3.命令参数： 1234567891011-a (all)显示所有选项，netstat默认不显示LISTEN相关-t (tcp)仅显示tcp相关选项-u (udp)仅显示udp相关选项-n 拒绝显示别名，能显示数字的全部转化成数字。(重要)-l 仅列出有在 Listen (监听) 的服務状态-p 显示建立相关链接的程序名(macOS中表示协议 -p protocol)-r 显示路由信息，路由表-e 显示扩展信息，例如uid等-s 按各个协议进行统计 (重要)-c 每隔一个固定时间，执行该netstat命令。 4.实例 netstat1234567891011121314151617181920212223242526272829Active Internet connections (w/o servers)Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 VM_0_4_centos:51354 169.254.0.55:lsi-bobcat ESTABLISHED# 第一行 # Ative Internet connections - 有源TCP连接# 第二行 # Proto - 协议# Recv-Q - 接收队列# Send-Q - 发送队列# Local Address - 本机的地址与端口# Foreign Address - 外部的地址与端口# State - 套接口当前的状态：LISTENING，ESTABLISHED，TIME_WAITActive UNIX domain sockets (w/o servers)Proto RefCnt Flags Type State I-Node Pathunix 3 [ ] STREAM CONNECTED 12869199 /usr/local/yd.socket.client# 第一行# Active UNIX domain sockets - 有源Unix域套接# 第二行# Proto - 显示连接使用的协议# RefCnt - 表示连接到本套接口上的进程数量# Types - 套接口的类型# State - 套接口当前的状态# I-Node - 索引节点# Path - 连接到套接口的其它进程使用的路径名 列出所有端口 123列出所有端口: netstat -a列出所有tcp端口: netstat -at列出所有udp端口: netstat -au 列出所有处于监听状态的 Sockets 1234只显示监听端口: netstat -l只列出所有监听tcp端口: netstat -lt只列出所有监听udp端口: netstat -lu只列出所有监听UNIX端口: netstat -lx 显示每个协议的统计信息 12显示所有端口的统计信息 netstat -s显示TCP或UDP端口的统计信息 netstat -st 或 -su 显示 PID 和进程名称:netstat -p 不显示主机，端口和用户名:netstat -an 持续输出 netstat 信息：netstat -t -c 2 显示核心路由信息：netstat -rn 找出程序运行的端口：netstat -apn 显示网络接口列表：netstat -ie 其他工具Htop - Linux进程监控 1.命令格式： 1htop [参数] 2.命令功能：强化版本的top 3.命令参数： 123-s 选项 : 按指定的列排序-u 选项 : 显示指定的用户的进程信息列表。-d 选项 : 设置刷新的延迟时间。例如 htop -d 100 命令会使输出在1秒后才会刷新（参数 -d 的单位是10微秒）。 4.实例 显示进程信息：htop 按 PID 列的大小排序来显示:htop -s 显示指定的用户的进程信息列表:htop -u &lt;user_name&gt; 5.交互命令 交互命令 交互命令 作用 h, ? F1 查看htop使用说明 S F2 htop 设定 / F3 搜索进程 \ F4 增量进程过滤器 t F5 显示树形结构 &lt;, &gt; F6 选择排序方式 [ F7 可减少nice值可以提高对应进程的优先级 ] F8 可增加nice值，降低对应进程的优先级 k F9 可对进程传递信号 q F10 结束htop u 只显示一个给定的用户的过程 U 取消标记所有的进程 H 显示或隐藏用户线程 K 显示或隐藏内核线程 F 跟踪进程 P 按CPU 使用排序 M 按内存使用排序 T 按Time+ 使用排序 l 显示进程打开的文件 I 倒转排序顺序 s 选择某进程，按s:用strace追踪进程的系统调用 Sar - 系统活动情况报告 1.命令格式： 1234sar [options] [-A] [-o file] t [n]# t为采样间隔，n为采样次数，默认值是1；# -o file表示将命令结果以二进制格式存放在文件中，file 是文件名。 2.命令功能：可以从多方面对系统的活动进行报告，包括：文件的读写情况、 系统调用的使用情况、磁盘I/O、CPU效率、内存使用状况、进程活动及IPC有关的活动等。本文主要以CentOS 6.3 x64系统为例，介绍sar命令 3.命令参数： 1234567891011-A - 所有报告的总和-u - 输出CPU使用情况的统计信息-v - 输出inode、文件和其他内核表的统计信息-d - 输出每一个块设备的活动信息-r - 输出内存和交换空间的统计信息-b - 显示I/O和传送速率的统计信息-a - 文件读写情况-c - 输出进程统计信息，每秒创建的进程数-R - 输出内存页面的统计信息-y - 终端设备活动情况-w - 输出系统交换活动信息 4.实例 查看内存使用情况：sar -r 查看内存页面交换发生状况：sar -W 查看带宽信息：sar -n DEV IPTraf - 实时IP局域网监控 1.命令格式： 1iptraf-ng [options] 2.命令功能：收集TCP，UDP，IP，ICMP，非IP，IP校验和错误，接口活动等通用和详细的接口统计信息。]]></content>
      <tags>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能工具wrk]]></title>
    <url>%2F2017%2F08%2F15%2F%E6%80%A7%E8%83%BD%E5%B7%A5%E5%85%B7wrk%2F</url>
    <content type="text"><![CDATA[wrk是一款开源的性能测试工具,支持使用lua脚本,底层封装了epoll(linux)和kqueue(bsd)。文章介绍使用wrk进行压力测试。 Quick Guide安装 Unbuntu/Debian下的安装 1234567Unbuntu/Debian下的安装sudo apt-get install build-essential libssl-dev git -ygit clone https://github.com/wg/wrk.git wrkcd wrkmake# 把生成的wrk移到一个PATH目录下面, 比如sudo cp wrk /usr/local/bin Unbuntu/Debian下的安装 12345678sudo yum groupinstall 'Development Tools'sudo yum install openssl-develsudo yum install gitgit clone https://github.com/wg/wrk.git wrkcd wrkmake# 把生成的wrk移到一个PATH目录下面, 比如sudo cp wrk /usr/local/bin 命令行参数12345678910111213141516使用方法: wrk &lt;选项&gt; &lt;被测HTTP服务的URL&gt; Options: -c, --connections &lt;N&gt; 跟服务器建立并保持的TCP连接数量 -d, --duration &lt;T&gt; 压测时间 -t, --threads &lt;N&gt; 使用多少个线程进行压测-s, --script &lt;S&gt; 指定Lua脚本路径 -H, --header &lt;H&gt; 为每一个HTTP请求添加HTTP头 --latency 在压测结束后，打印延迟统计信息 --timeout &lt;T&gt; 超时时间 -v, --version 打印正在使用的wrk的详细版本信息 &lt;N&gt;代表数字参数，支持国际单位 (1k, 1M, 1G)&lt;T&gt;代表时间参数，支持时间单位 (2s, 2m, 2h)# 例: 10并发 100连接数 持续访问30swrk -t10 -c100 -d30s http://127.0.0.1:8888 Latency：响应时间 Req/Sec：每个线程每秒钟的完成的请求数 Avg：平均 Max：最大 Stdev：标准差 +/- Stdev： 正负一个标准差占比 Lua脚本个性化wrk支持在三个阶段对压测进行个性化，分别是启动阶段、运行阶段和结束阶段。每个测试线程，都拥有独立的Lua运行环境。 1.启动阶段 1234567# 在脚本文件中实现setup方法，wrk就会在测试线程已经初始化但还没有启动的时候调用该方法。wrk会为每一个测试线程调用一次setup方法，并传入代表测试线程的对象thread作为参数。setup方法中可操作该thread对象，获取信息、存储信息、甚至关闭该线程。function setup(thread)-- thread提供了1个属性，3个方法-- thread.addr 设置请求需要打到的ip-- thread:get(name) 获取线程全局变量-- thread:set(name, value) 设置线程全局变量-- thread:stop() 终止线程 2.运行阶段 1234567891011function init(args)-- 每个线程仅调用1次，args 用于获取命令行中传入的参数, 例如 --env=prefunction delay()-- 每次请求调用1次，发送下一个请求之前的延迟, 单位为msfunction request()-- 每次请求调用1次，返回http请求function response(status, headers, body)-- 每次请求调用1次，返回http响应，如果没有定义该方法，那么wrk不会解析headers和body 3.结束阶段 12345678910111213141516171819202122# 该方法在整个测试过程中只会调用一次，可从参数给定的对象中，获取压测结果，生成定制化的测试报告。function done(summary, latency, requests)latency.min -- minimum value seenlatency.max -- maximum value seenlatency.mean -- average value seenlatency.stdev -- standard deviationlatency:percentile(99.0) -- 99th percentile valuelatency(i) -- raw value and countsummary = &#123; duration = N, -- run duration in microseconds requests = N, -- total completed requests bytes = N, -- total bytes received errors = &#123; connect = N, -- total socket connection errors read = N, -- total socket read errors write = N, -- total socket write errors status = N, -- total HTTP status codes &gt; 399 timeout = N -- total request timeouts &#125;&#125; 4.样例 123456789101112131415161718192021222324252627282930313233local counter = 1 local threads = &#123;&#125; function setup(thread) thread:set("id", counter) table.insert(threads, thread) counter = counter + 1 end function init(args) requests = 0 responses = 0 local msg = "thread %d created" print(msg:format(id)) end function request() requests = requests + 1 return wrk.request() end function response(status, headers, body) responses = responses + 1 end function done(summary, latency, requests) for index, thread in ipairs(threads) do local id = thread:get("id") local requests = thread:get("requests") local responses = thread:get("responses") local msg = "thread %d made %d requests and got %d responses" print(msg:format(id, requests, responses)) end end 5.自定义脚本中可访问的变量和方法 wrk: 全局变量，修改后会影响所有请求 12345678910wrk = &#123; scheme = "http", host = "localhost", port = nil, method = "GET", path = "/", headers = &#123;&#125;, body = nil, thread = &lt;userdata&gt;, &#125; wrk.fomat:根据参数和全局变量wrk，生成整个request的string 12345function wrk.format(method, path, headers, body)-- method: http方法, 如GET/POST/DELETE 等-- path: url的路径, 如 /index, /index?a=b&amp;c=d-- headers: 一个header的table-- body: 一个http body, 字符串类型 wrk.lookup:获取域名的IP和端口，返回table，例如：返回 {127.0.0.1:80} 123function wrk.lookup(host, service)-- host:一个主机名或者地址串(IPv4的点分十进制串或者IPv6的16进制串)-- service：服务名可以是十进制的端口号，也可以是已定义的服务名称，如ftp、http等 wrk.connect:判断addr是否能连接，例如：127.0.0.1:80，返回 true 或 false 1function wrk.connect(addr) Lua样例 压测支持HTTP pipeline的服务 123456789101112init = function(args) local r = &#123;&#125; r[1] = wrk.format(nil, "/?foo") r[2] = wrk.format(nil, "/?bar") r[3] = wrk.format(nil, "/?baz") req = table.concat(r)endrequest = function() return reqend 认证之后获取token以进行压测 1234567891011121314token = nilpath = "/authenticate"request = function() return wrk.format("GET", path)endresponse = function(status, headers, body) if not token and status == 200 then token = headers["X-Token"] path = "/resource" wrk.headers["X-Token"] = token endend 获取cookie以进行压测 12345678910111213function getCookie(cookies, name) local start = string.find(cookies, name .. "=") if start == nil then return nil end return string.sub(cookies, start + #name + 1, string.find(cookies, ";", start) - 1) end response = function(status, headers, body) local token = getCookie(headers["Set-Cookie"], "token") if token ~= nil then wrk.headers["Cookie"] = "token=" .. token end end 发送json 123456789101112request = function() local headers = &#123; &#125; headers['Content-Type'] = "application/json" body = &#123; mobile=&#123;"1533899828"&#125;, params=&#123;code=math.random(1000,9999)&#125; &#125; local cjson = require("cjson") body_str = cjson.encode(body) return wrk.format('POST', nil, headers, body_str)end More info: wrk GitHub]]></content>
      <tags>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能工具Locust]]></title>
    <url>%2F2017%2F07%2F15%2F%E6%80%A7%E8%83%BD%E5%B7%A5%E5%85%B7Locust%2F</url>
    <content type="text"><![CDATA[Locust是一款开源的分布式负载测试工具。是用Python编写，易于使用，完全基于事件，即一个locust节点也可以在一个进程中支持数千并发用户，不使用回调，通过gevent使用轻量级过程（即在自己的进程内运行）。本文章介绍在Windows7如何安装和使用Locust。 Quick Guide安装 1.使用pip安装 1pip install locust 2.验证安装 1locust -V 基本操作 1.创建一个demo 123456789101112131415161718192021222324252627from locust import HttpLocust, TaskSet, taskclass WebsiteTasks(TaskSet): # 继承了TaskSet类，用于定义测试任务的 def on_start(self): # 进行初始化,只执行一次 payload = &#123; "username": "test_user", "password": "123456", &#125; header = &#123; "User-Agent":"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36", &#125; self.client.post("/login",data=payload,headers=header) # self.client属性的调用和使用方法和requests完全一致 @task(5) # 通过@task()装饰的方法为一个事务，方法的参数用于指定该行为的执行权重，参数越大每次被虚拟用户执行的概率越高，默认为1 def index(self): # 测试任务 self.client.get("/") @task(1) def about(self): self.client.get("/about/")class WebsiteUser(HttpLocust): # 继承了HttpLocust类，为每个模拟用户的发送http请求和设置测试参数 host = "https://github.com/" # 被测系统的host，在终端中启动locust时没有指定--host参数时才会用到 task_set = WebsiteTasks # TaskSet类，该类定义用户任务信息，必填。这里就是:WebsiteTasks类名,因为该类继承TaskSet； min_wait = 5000 # 每个用户执行两个任务间隔时间的上下限（毫秒）,具体数值在上下限中随机取值，若不指定默认间隔时间固定为1秒 max_wait = 15000 weight = 10 # 同时运行多个Locust类时，用于控制不同类型的任务执行权重 2.执行流程图 3.使用下面命令启动,通过浏览器访问：http://localhost:8089(Locust启动网络监控器，默认为端口号为:8089） 12rem 执行性能脚本locust -f &lt;性能测试脚本文件.py&gt; --host=&lt;被测试应用的URL地址,不填写就读取继承（HttpLocust）的类中定义的host值&gt; 4.监控性能 Type： 请求的类型，例如GET/POST。 Name：请求的路径。 Request：当前请求的数量。 Fails：当前请求失败的数量。 Median：中间值，单位毫秒，一半的服务器响应时间低于该值，而另一半高于该值。 Average：平均值，单位毫秒，所有请求的平均响应时间。 Min：请求的最小服务器响应时间，单位毫秒。 Max：请求的最大服务器响应时间，单位毫秒。 Average Size：平均每个请求的大小，单位字节。 Current RPS：每秒钟请求的个数。 5.no-web模式运行启动 1locust -f &lt;性能测试脚本文件.py&gt; --no-web -c&lt;虚拟用户数&gt; -r&lt;每秒启动虚拟用户数&gt; -t &lt;运行时间&gt; --csv=&lt;测试结果文件&gt; 6.其他方式定义task 1234567891011from locust import TaskSetdef test_job1(obj): obj.client.get('/test1')def test_job2(obj): obj.client.get('/test2')class UserBehavior(TaskSet): tasks = &#123;test_job1:1, test_job2:3&#125; # tasks = [(test_job1,1), (test_job1,3)] # 两种方式等价 参数化 1.循环取数据，数据可重复使用 1234567891011121314151617from locust import TaskSet, task, HttpLocustclass UserBehavior(TaskSet): def on_start(self): self.index = 0 @task def test_visit(self): url = self.locust.share_data[self.index] print('visit url: %s' % url) self.index = (self.index + 1) % len(self.locust.share_data) self.client.get(url)class WebsiteUser(HttpLocust): host = 'http://debugtalk.com' task_set = UserBehavior share_data = ['url1', 'url2', 'url3', 'url4', 'url5'] min_wait = 1000 max_wait = 3000 2.保证并发测试数据唯一性，不循环取数据 12345678910111213141516171819202122232425262728293031323334353637from locust import TaskSet, task, HttpLocustimport queueclass UserBehavior(TaskSet): @task def test_register(self): try: data = self.locust.user_data_queue.get() except queue.Empty: print('account data run out, test ended') exit(0) print('register with user: &#123;0&#125;, pwd: &#123;1&#125;' .format(data['username'], data['password'])) payload = &#123; 'username': data['username'], 'password': data['password'] &#125; self.client.post('/register', data=payload) self.locust.user_data_queue.put_nowait(data)class WebsiteUser(HttpLocust): host = 'http://debugtalk.com' task_set = UserBehavior user_data_queue = queue.Queue() for index in range(100): data = &#123; "username": "test%04d" % index, "password": "pwd%04d" % index, "email": "test%04d@debugtalk.test" % index, "phone": "186%08d" % index, &#125; user_data_queue.put_nowait(data) min_wait = 1000 max_wait = 3000 3.保证并发测试数据唯一性，循环取数据 12345678910111213141516171819202122232425262728293031323334353637from locust import TaskSet, task, HttpLocustimport queueclass UserBehavior(TaskSet): @task def test_register(self): try: data = self.locust.user_data_queue.get() except queue.Empty: print('account data run out, test ended') exit(0) print('register with user: &#123;0&#125;, pwd: &#123;1&#125;' .format(data['username'], data['password'])) payload = &#123; 'username': data['username'], 'password': data['password'] &#125; self.client.post('/register', data=payload) self.locust.user_data_queue.put_nowait(data)class WebsiteUser(HttpLocust): host = 'http://debugtalk.com' task_set = UserBehavior user_data_queue = queue.Queue() for index in range(100): data = &#123; "username": "test%04d" % index, "password": "pwd%04d" % index, "email": "test%04d@debugtalk.test" % index, "phone": "186%08d" % index, &#125; user_data_queue.put_nowait(data) min_wait = 1000 max_wait = 3000 断言python自带的断言assert失败后代码就不会向下走，且失败后不会被Locust报表统计进去。不写参数catch_response=False断言无效，将catch_response=True才生效。 12345678910111213141516171819from locust import HttpLocust, TaskSet, taskclass UserTask(TaskSet): @task def job(self): with self.client.get('/', catch_response = True) as response: if response.status_code == 200: response.success() else: response.failure('Failed!')class User(HttpLocust): task_set = UserTask min_wait = 1000 max_wait = 3000 host = "https://www.baidu.com" 分布式压测 1.把主机中代码复制到多个从机中,主机负责收集测试数据，从机进行施压测试 2.启动主机 1locust -f &lt;性能测试脚本文件.py&gt; --no-web -c&lt;虚拟用户数&gt; -r&lt;每秒启动虚拟用户数&gt; -t &lt;运行时间&gt; --csv=&lt;测试结果文件&gt; --master 3.启动从机 1locust -f &lt;性能测试脚本文件.py&gt; --slave --master-host=&lt;主机ip&gt; More info: 官网]]></content>
      <tags>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能工具ab]]></title>
    <url>%2F2017%2F06%2F15%2F%E6%80%A7%E8%83%BD%E5%B7%A5%E5%85%B7ab%2F</url>
    <content type="text"><![CDATA[ab(apachebench)是apache自带的压力测试工具。ab非常实用，它不仅可以对apache服务器进行网站访问压力测试，也可以对或其它类型的服务器进行压力测试。文章介绍centos7.5环境下使用wrk进行压力测试。 Quick Guide安装12345# 安装yum -y install httpd-tools# 查看版本ab -V 参数说明123456789101112131415161718192021222324252627282930313233343536格式：ab [options] [http://]hostname[:port]/path# 参数说明：-n requests Number of requests to perform （要执行的请求校验次数。默认请求一次）-c concurrency Number of multiple requests to make （并发数，同一时间有多少请求发出去，默认是1）-t timelimit Seconds to max. wait for responses （校验花费的最大时间，内部设置-n 50000 次。默认不开启）-b windowsize Size of TCP send/receive buffer, in bytes （发送和接收的buffer大小，单位是 bytes）-p postfile File containing data to POST. Remember also to set -T（包含POST数据文件）-u putfile File containing data to PUT. Remember also to set -T （包含PUT数据文件）-T content-type Content-type header for POSTing, eg. （头信息content-type，如 -T "application/x-www-form-urlencoded" ） 'application/x-www-form-urlencoded' Default is 'text/plain'-v verbosity How much troubleshooting info to print （设置输出等级， 4 输出头信息，3 输出响应码(404,200) 2 输出警告和信息）-w Print out results in HTML tables （以HTML表的格式输出结果。默认时，它是白色背景的两列宽度的一张表。）-i Use HEAD instead of GET （执行HEAD请求，而不是GET）-x attributes String to insert as table attributes-y attributes String to insert as tr attributes-z attributes String to insert as td or th attributes-C attribute Add cookie, eg. -C "c1=1234,c2=2,c3=3". (repeatable) （对请求附加一个Cookie）提示：可以借助session实现原理传递 JSESSIONID参数， 实现保持会话的功能，如 -C ” c1=1234,c2=2,c3=3, JSESSIONID=FF056CD16DA9D71CB131C1D56F0319F8″ 。-H attribute Add Arbitrary header line, eg. 'Accept-Encoding: gzip' Inserted after all normal header lines. (repeatable)-A attribute Add Basic WWW Authentication, the attributes are a colon separated username and password.-P attribute Add Basic Proxy Authentication, the attributes -P proxy-auth-username:password 对一个中转代理提供BASIC认证信任。用户名和密码由一个:隔开，并以base64编码形式发送。无论服务器是否需要(即, 是否发送了401认证需求代码)，此字符串都会被发送。 are a colon separated username and password.-X proxy:port Proxyserver and port number to use-V Print version number and exit-k Use HTTP KeepAlive feature-d Do not show percentiles served table.-S Do not show confidence estimators and warnings.-g filename Output collected data to gnuplot format file. 写所有有用的信息到TSV（Tab separate values）文件，可以轻松导入Excel等里面，label在文件第一行）-e filename Output CSV file with percentages served 写一个逗号分隔的CSV文件，包含每个百分比(from 1% to 100%)服务器执行的时间(毫秒)，这个文件一般比'gunplot'有用-r Don't exit on socket receive errors. （在socket错误的时候不退出）-h Display usage information (this message)-Z ciphersuite Specify SSL/TLS cipher suite (See openssl ciphers)-f protocol Specify SSL/TLS protocol (SSL2, SSL3, TLS1, or ALL) （指定 SSL/TLS 协议 (SSL2, SSL3, TLS1, or ALL).） 简单实例 并发10，请求100 1ab -n100 -c10 http://www.baidu.com/ 结果以html的形式输出 1ab -n100 -c10 -w http://www.baidu.com/ 测试结果说明123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051ab -n 100 -c 10 https://www.baidu.com/index.htmlThis is ApacheBench, Version 2.3 &lt;$Revision: 1706008 $&gt;Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/Licensed to The Apache Software Foundation, http://www.apache.org/# 以上为apache的版本信息，与本次测试无关Benchmarking www.baidu.com (be patient).....done# 以上内容显示测试完成度，本次测试发起请求数量较少，完成较快，无中间过程显示。在请求数量很多时会分行显示当前完成数量。Server Software: bfe/1.0.8.14 # 被测试的服务器所用的软件信息Server Hostname: www.baidu.com # 被测主机名Server Port: 443 #被测主机的服务端口号，一般http请求的默认端口号是80，https默认使用443端口SSL/TLS Protocol: TLSv1.2,ECDHE-RSA-AES128-GCM-SHA256,2048,128 #加密协议Document Path: /index.html # 请求的具体文件Document Length: 227 bytes # 请求的文件index.html大小Concurrency Level: 10 # 并发数Time taken for tests: 1.093 seconds # 本次测试总共花费的时间Complete requests: 100 # 本次测试总共发起的请求数量Failed requests: 0 # 失败的请求数量。因网络原因或服务器性能原因，发起的请求并不一定全部成功，通过该数值和Complete requests相除可以计算请求的失败率，作为测试结果的重要参考。Total transferred: 103314 bytes # 总共传输的数据量，指的是ab从被测服务器接收到的总数据量，包括index.html的文本内容和请求头信息。HTML transferred: 22700 bytes #从服务器接收到的index.html文件的总大小，等于Document Length＊Complete requests＝227 bytes＊100＝22700 bytesRequests per second: 91.50 [#/sec] (mean) #平均(mean)每秒完成的请求数：QPS，这是一个平均值，等于Complete requests/Time taken for tests=100/1.093=91.50Time per request: 109.287 [ms] (mean) # 从用户角度看，完成一个请求所需要的时间（因用户数量不止一个，服务器完成10个请求，平均每个用户才接收到一个完整的返回，所以该值是下一项数值的10倍。）Time per request: 10.929 [ms] (mean, across all concurrent requests) # 服务器完成一个请求的时间。Transfer rate: 92.32 [Kbytes/sec] received # 网络传输速度。对于大文件的请求测试，这个值很容易成为系统瓶颈所在。要确定该值是不是瓶颈，需要了解客户端和被测服务器之间的网络情况，包括网络带宽和网卡速度等信息。Connection Times (ms) min mean[+/-sd] median maxConnect: 11 17 14.2 15 153Processing: 4 6 2.4 5 23Waiting: 4 6 2.1 5 23Total: 16 23 14.6 21 158# 这几行组成的表格主要是针对响应时间也就是第一个Time per request进行细分和统计。一个请求的响应时间可以分成网络链接（Connect），系统处理（Processing）和等待（Waiting）三个部分。表中min表示最小值;mean表示平均值;[+/-sd]表示标准差（Standard Deviation）,表示数据的离散程度，数值越大表示数据越分散，系统响应时间越不稳定;median表示中位数;max表示最大值了。Percentage of the requests served within a certain time (ms) 50% 21 66% 22 75% 23 80% 23 90% 25 95% 32 98% 52 99% 158 100% 158 (longest request)# 这个表表示有百分之多少的请求都是在多少ms内完成的 More info: 官网]]></content>
      <tags>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能测试（三）性能测试的执行与分析]]></title>
    <url>%2F2017%2F05%2F15%2F%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%9503%2F</url>
    <content type="text"><![CDATA[本文章介绍性能测试的执行与分析。 Quick Guide性能测试执行 人工边执行边分析 无人值守执行性能测试：利用业务或者系统空闲时间测试 注意事项 如果在线上或者uat，要考虑对业务的影响，跟开发及时沟通测试场景，尽量业务或者系统空闲时间测试 记录性能指标(数值和图片)：图片还是必须的记录，测试周期长可能存在记录错误或者争论 监控请求是否正常,分析失败原因 测试总体曲线是否呈现波峰或者随着请求量增大趋于水平 结果分析与调优结果分析 测试结果是否满足性能指标 满足，开始写性能报告；不满足，是否受到哪方面限制或者其他因素，跟需求方确实是否需要调优，调优进行下一节初步分析，然后跟架构师和开发确定方案。 注意事项 1.测试曲线远离预想 可能是被测系统接受的tps不同于实际执行机发出，在被测机器增加日志打印之类方式去统计接受到的需求 触发特殊的系统机制 2.请求出现较高的错误率 查看返回的错误信息 检查网络是否稳定 检查中间组件异常 检查数据库是否重启 集群检查每个节点是否正常 3.集群测试平均性能小于单机 负债均衡组件分发速度是否受到限制，处理太慢 分发规则是否对每一台单机发送的请求量大体一致 系统瓶颈分析整体思路：从前到后，从表象到内部: 1.首先排除压力机自身的问题，如CPU、内存，网络，脚本编写等 2.监控中间件的访问日志，观察响应时间，大体确定耗时处于哪一段 3.排查网络问题，监控压力机到后端服务器的网络，以及各服务器间的网络，是否达到网络上限 4.监控服务端所有机器的操作系统负载，如CPU、内存、磁盘、网络是否达到瓶颈 5.监控应用服务器的日志，查看是否存在ERROR日志，比如TimeOut或其他类型报错 6.监控各中间件的连接数，如nginx、tomcat、mysql等，是否达到上限 7.监控应用程序线程状态，使用jstack或jvisualvm查看是否有死锁、阻塞等情况 8.监控应用程序的jvm，使用jstat或者jmap查看GC情况，是否内存泄漏等 9.使用jprofiler监控应用程序，可以查看耗时比较长的代码方法 10.监控数据库，是否存在慢查询，一般数据库CPU高都是因为SQL语句效率低造成的 在sql语句前加上explain，可以分析这条sql语句的执行情况 explain select * from t_order_loop_refund where name = ‘小明’； Type列可能的值Const：表中只有一个匹配行，用到primary key或unique key Eq_ref：唯一性索引扫描，key的所有部分被连接联接查询使用，且key是unique或primary key ref：非唯一性索引扫描，或只使用了联合索引的最左前缀 Range：索引范围扫描，在索引列上进行给定范围内的检索，如between，in（1,100） Index：遍历索引... All：全表扫描 Prossible key：使用哪个索引能找到行 Keys：sql语句使用的索引 rows：mysql 根据索引选择情况，估算查找数据所需读取的行数 联合索引 连接数 数据库架构优化 读写分离，主从配置 硬件调优 11.检查数据库执行计划，是否有全表扫描，以及索引不生效的情况 12.检查系统外部依赖情况，如果外部依赖系统性能差，也会造成本系统性能低 13.对于不好定位的问题，可以考虑采用模块隔离法来确定问题 优化方案 sql 在 where 及 order by 涉及的列上建立索引，避免全表扫描，索引不要太多，一个表一般不要超过4个索引 避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描 查询语句中不要使用 *，减少内存使用 尽量减少子查询，使用关联查询（left join,right join,inner join）替代 减少使用IN或者NOT IN ,使用exists，not exists或者关联查询语句替代 or 的查询尽量用 union或者union all 代替(在确认没有重复数据或者不用剔除重复数据时，union all会更好) 合理的增加冗余的字段（减少表的联接查询） 建表的时候能使用数字类型的字段就使用数字类型（type,status…），数字类型的字段作为条件查询比字符串的快 代码 使用对象池减少对重复对象的创建； 调整对后端的连接 增加本地缓存 如果不涉及事务的情况下，考虑使用Nosql进行存储 一次请求合并多次操作 由串行修改为并行操作 同步修改为异步 测试报告与总结 测试计划 业务流程 测试环境 测试场景：把测试场景罗列，并放上对于性能结果和资源占用率的图片 结果与分析：把测试性能指标与实际结果罗列对比，说明存在哪些问题 结论：问题和是否满足标准 风险点：存在哪些风险需要考虑，怎么去规避]]></content>
      <tags>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能测试（二）性能测试方案设计]]></title>
    <url>%2F2017%2F04%2F15%2F%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%9502%2F</url>
    <content type="text"><![CDATA[本文章介绍性能测试方案设计。 Quick Guide性能需求分析 系统信息调研：架构、平台、协议等 业务信息调研：基本业务、关键业务，用户行为 性能需求评估：明确是否需要做性能测试 业务角度：对内或者对外，使用人数多少，需求是否必要 系统角度 ： 系统架构：系统框架是否更换 数据库要求 系统特殊要求：秒杀或者对延时要求比较高 确定测试范围 压力测试 负载测试 性能测试 确定性能测试点 测试指标 关键业务 分析用户使用场景，掌握用户需求 提炼用户关注度较强的功能 分析用户操作频繁的功能 分析系统中可能的大数据量操作【文件读写，图片浏览，事务队列，事务机制】 分析系统关键功能【后台服务，缓存，调用的功能组件】 分析用户组合航警，操作比例以及操作时延 日请求量 逻辑复杂度 营推广活动 确定性能指标和通过标准 性能指标：具体结合业务，例如页面就存在页面加载时间 通过标准 线上数据高峰期间的峰值和平均流量 未来的规划和期望 性能测试准备1.测试环境准备系统运行环境 ：与线上保持一致 线上或者uat环境 数据请求打标签,区分测试数据与真实数据 增加测试挡板 优点:不需要搭建环境和监控 缺点:只能选择流量空闲期,不能进行过高的压测,测试时候要及时跟开发沟通(线上异常警告) 搭建环境 组网模型: 需要评估测试组网与生产组网差异，至少满足最低配置要求 组网类型：单机/双机/单机集群/双机集群/各种组合类型 硬件: cpu/内存/磁盘读写/网卡 软件：操作系统类型/服务/数据库/文件库/第三方组件 消息交互：同步/异步 执行机环境 网络与用户保持一致 组网：单机（4U8G）一般只能支持2000tps左右），场景超过需要更高的配置 调优 网络设置 测试软件 系统对软件的限制 2. 测试场景设计根据性能需求分析来设计符合用户使用习惯的场景 测试范围：根据需求分析确定的范围，确定测试场景范围 测试功能点： 具体业务场景 请求数据量：受到测试范围影响，如果算性能测试，就需要随着请求数据量变化下（从低到高）系统的性能指标 单次场景的请求持续时间 测试环境配置 单机 集群 测试指标 tps 请求平均耗时 请求最大耗时 成功率 测试结果 实际tps 请求平均耗时 请求最大耗时 请求的成功率 资源占用情况 3.性能工具准备 ：与开发技术栈一致负载工具 ApacheBench: Apache 服务器自带的一个web压力测试工具，简称ab 下载 使用 教程 Wrk:一款针对 Http 协议的基准测试开源工具,支持lua脚本 源码 安装 使用 教程 Apache JMeter(常用): Java 编写的应用程序，支持插件和jar包. 下载 使用 Locust :一个开源负载测试工具。使用 Python 代码定义用户行为，也可以仿真百万个用户。 源码 安装:pip安装 使用 [教程](https://honglamp.com/2019/03/15/%E6%80%A7%E8%83%BD%E5%B7%A5%E5%85%B7Locust/） LoadRunner(付费专业):HP公司提供的一款性能测试工具，通过模拟成千上万个用户实施并发操作，测试系统的性能，并且提供详细的测试结果分析，协助用户查找问题。 相关资料 Spirent(付费专业):自带硬件的大流量网络测试仪 监控工具 Linux系统监控工具 教程 Node_Exporter+Prometheus+Grafana 教程 4.测试脚本准备5.测试数据准备 系统初始数据： 分析系统上线后数据量/历史数据 计算出系统每个阶段数据容量，数据类型，数据比例 根据不同阶段分别进行数据预制 测试新增数据： 业务场景确定后根据具体业务场景定义输入和输出数据 结合具体的呼叫模型进行数据预制 注意事项 模拟与真实场景、真实组网和真实数据之间的差异性 测试过程中的执行模型问题（缓存） 测试执行过程中的资源监控问题 行业或者同行标准 否则结果与现实存在很大差距，测试结果不准确]]></content>
      <tags>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能测试（一）性能测试的基本概念]]></title>
    <url>%2F2017%2F03%2F15%2F%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%9501%2F</url>
    <content type="text"><![CDATA[性能测试：指通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。本文章介绍性能测试的基本概念。 Quick Guide性能要求 用户 响应速度 稳定性 开发 架构是否合理 数据库设计 代码 系统管理员 资源利用率（合适的比例） 可扩展性 系统容量（可容纳的用户请求） 稳定性 性能测试应用场景 能力验证 关注在给定的软硬件条件下，系统能否具有预期的能力表现 规划能力 关注如何使系统具有我们要求的性能能力 性能调优 主要用于对系统性能进行调优 缺陷发现 发现缺陷或问题重现、定位手段 性能基准比较 比较每次迭代中的性能表现变化，判断迭代是否达到了目标 性能测试类型 基准测试：在给系统施加较低压力时，查看系统的运行状况并记录相关数做为基础参考。 并发测试：测试多个用户同时访问同一个应用、同一个模块或者数据记录时是否存在死锁或者其他性能问题。 负载测试：是指对系统不断地增加压力或增加一定压力下的持续时间，直到系统的某项或多项性能指标达到安全临界值，例如某种资源已经达到饱和状态等。 压力测试：压力测试是评估系统处于或超过预期负载时系统的运行情况，关注点在于系统在峰值负载或超出最大载荷情况下的处理能力。 稳定性测试：在给系统加载一定业务压力的情况下，使系统运行一段时间，以此检测系统是否稳定。 性能测试基本概念 并发数 并发用户数：某一物理时刻同时向系统提交请求的用户数，提交的请求可能是同一个场景或功能，也可以是不同场景或功能。 在线用户数：某段时间内访问系统的用户数，这些用户并不一定同时向系统提交请求 系统用户数：系统注册的总用户数据 吞吐量(TPS) ： 单位时间内系统处理的客户端请求的数量(完成一个业务事务的过程) 响应时间 ：从用户发送一个请求到用户接收到服务器返回的响应数据这段时间就是响应时间 资源利用率 ：指的是对不同系统资源的使用程度，通常以占用最大值的百分比来衡量 CPU：就像人的大脑，主要负责相关事情的判断以及实际处理的机制 内存：大脑中的记忆块区，将眼睛，皮肤等收集到的信息记录起来的地方，以供cpu进行判断，但是是临时的，访问速度快，如果关机或断电这里的数据会消失。 磁盘IO：大脑中的记忆区块，将重要的数据保存起来（永久保存，关机或断电不会丢失，速度慢），以便将来再次使用这些数据。 网络： 结论模拟用户的真实、峰值和异常的请求量（单位时间的请求数量*单位请求内容大小）去访问系统，监控其性能情况（TPS、响应时间和资源利用率）并获取。]]></content>
      <tags>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可靠性测试（一）可靠性测试的基本概念]]></title>
    <url>%2F2017%2F02%2F15%2F%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%B5%8B%E8%AF%9501%2F</url>
    <content type="text"><![CDATA[软件是一种逻辑实体，具有抽象性，没有明显的制造过程，虽然没有磨损、老化的问题，但为了适应硬件、环境以及需求的变化而进行修改，这些修改常常会引入错误，导致软件失效率升高，软件质量降低。因此大量的软件系统其可靠性得不到保证，几乎没有不存在错误的软件系统。本文章主要介绍如何进行软件的可靠性测试。 Quick Guide定义软件的可靠性：在各种异常情况下，产品的容错性和恢复能力。 测试类型 外界输入，引起内部故障 异常值输入：属于功能测试，一种使用系统不允许用户输入的数值（即异常值）作为测试输入的可靠性测试方法。 稳定性和压力测试：属于性能测试 环境因素 故障注入： 把系统放在有问题的环境中进行测试的一种可靠性测试法 测试环境 组网方式跟生产一样：不同组件之间和同一组件内部 各个组件不可缺少 测试场景设计 从用户的业务环境中，筛选出哪些故障、错误或问题 常用环境因素考虑 网络：弱网、断网 硬件（硬盘）：硬盘占满、内存占满、机器重启 软件：内存泄漏、内核故障、文件丢失 组网方式： 单点故障 集群故障 影响级别 造成重大损失， 造成较大损失 造成较小损失 不造成损失 测试步骤 验证功能是否正常 注入故障 验证功能是否受到影响 恢复故障 验证功能是否恢复 结果和分析通过测试结果进行分析，生成可靠性评估报告]]></content>
      <tags>
        <tag>可靠性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript（四）ECMAScript]]></title>
    <url>%2F2017%2F01%2F15%2FJavaScript04%2F</url>
    <content type="text"><![CDATA[ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会,英文名称是European Computer Manufacturers Association）通过ECMA-262标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，所以它可以理解为是JavaScript的一个标准，但实际上后两者是ECMA-262标准的实现和扩展。 本文章主要介绍 ECMAScript 的基本概念。 Quick Guide一、结构一个完整的 JavaScript 是由以下 3 个不同部分组成的： 核心（ECMAScript）： 是一个重要的标准, 描述了语法和基本对象。 语法 类型 语句 关键字 保留字 运算符 对象 文档对象模型（DOM）： HTML 和 XML 的应用程序接口（API）。DOM 将把整个页面规划成由节点层级构成的文档。HTML 或 XML 页面的每个部分都是一个节点的衍生物。 DOM 视图 - 描述跟踪文档的各种视图（即 CSS 样式化之前和 CSS 样式化之后的文档） DOM 事件 - 描述事件的接口 DOM 样式 - 描述处理基于 CSS 样式的接口 DOM 遍历和范围 - 描述遍历和操作文档树的接口 浏览器对象模型（BOM）： 对浏览器窗口进行访问和操作 Window 对象 Navigator 对象 Screen 对象 History 对象 Location 对象 二、ECMAScript的变量与类型注意事项： 区分大小写 变量是弱类型的 每行结尾的分号可有可无 注释与 Java、C 和 PHP 语言的注释相同 单行注释以双斜杠开头（//） 多行注释以单斜杠和星号开头（/），以星号和单斜杠结尾（/） 括号表示代码块 ECMAScript 的解释程序遇到未声明过的标识符时，用该变量名创建一个全局变量，并将其初始化为指定的值。 2.1.变量声明使用 var 运算符声明变量。 12345// 声明变量var test = "hi";var test = "hi", age = 25;// 变量并不一定要初始化var test; 2.2.命名变量 第一个字符必须是字母、下划线（_）或美元符号（$） 余下的字符可以是下划线、美元符号或任何字母或数字字符 123456// Camel 标记法:首字母是小写的，接下来的字母都以大写字符开头var myTestValue = 0, mySecondValue = "hi";// Pascal 标记法:首字母是大写的，接下来的字母都以大写字符开头。var MyTestValue = 0, MySecondValue = "hi";// 匈牙利类型标记法:在以 Pascal 标记法命名的变量前附加一个小写字母（或小写字母序列），说明该变量的类型。var iMyTestValue = 0, sMySecondValue = "hi"; 2.3.关键字 关键字标识了 ECMAScript 语句的开头和/或结尾。根据规定，关键字是保留的，不能用作变量名或函数名。 12345678910111213141516171819202122232425breakcasecatchcontinuedefaultdeletedoelsefinallyforfunctionifininstanceofnewreturnswitchthisthrowtrytypeofvarvoidwhilewith 2.4.保留字 保留字在某种意思上是为将来的关键字而保留的单词。因此保留字不能被用作变量名或函数名。 12345678910111213141516171819202122232425262728293031abstractbooleanbytecharclassconstdebuggerdoubleenumexportextendsfinalfloatgotoimplementsimportintinterfacelongnativepackageprivateprotectedpublicshortstaticsupersynchronizedthrowstransientvolatile 2.5.原始值原始值：存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。 Undefined： 当声明的变量未初始化时，该变量的默认值 Null： 表示尚未存在的对象 Boolean： true 和 false Number ： 32 位的整数 64 位的浮点数 八进制和十六进制 特殊 ： Number.MAX_VALUE 、Number.MIN_VALUE ；Number.POSITIVE_INFINITY（ 生成的数大于Number.Max_VALUE ）和Number.NEGATIVE_INFINITY （ 生成的数值小于 Number.MIN_VALUE ）； NaN （ 类型 String、Boolean 转换失败 ） String 型 ：由双引号（”）或单引号（’）声明的。字符字面量 123456789101112131415// 类型检查var sTemp = "test string";alert (typeof sTemp); //输出 "string"alert (typeof 86); //输出 "number"// 所有整数都可以表示为八进制或十六进制的字面量，但所有数学运算返回的都是十进制结果。var iNum = 070; //070 等于十进制的 56var iNum = 0x1f; //0x1f 等于十进制的 31// 对于浮点字面量的有趣之处在于，用它进行计算前，真正存储的是字符串。var fNum = 5.0;// 科学计数法var fNum = 5.618e7var sColor1 = "red";var sColor2 = 'red'; 2.6.引用值引用值：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处。通常叫做类（class）。 1var o = new Object(); 属性 constructor：对创建对象的函数的引用（指针）。对于 Object 对象，该指针指向原始的 Object() 函数。 Prototype：对该对象的对象原型的引用。对于所有的对象，它默认返回 Object 对象的一个实例。 方法 hasOwnProperty(property)：判断对象是否有某个特定的属性。必须用字符串指定该属性。 IsPrototypeOf(object)：判断该对象是否为另一个对象的原型。 PropertyIsEnumerable：判断给定的属性是否可以用 for…in 语句进行枚举。 ToString()：返回对象的原始字符串表示。 ValueOf()：返回最适合该对象的原始值。 类型 Boolean 对象 ：用于提供将布尔值转换成字符串 Number 对象 ：用于提供将布尔值转换成数字 toFixed() 方法 ：返回的是具有指定位数小数的数字的字符串 toExponential() 方法：返回的是用科学计数法表示的数字的字符串形式。 toPrecision() 方法：返回数字的预定形式或指数形式 String 对象 length 属性：符串中的字符个数 charAt(position)：获取字符串中的单个字符 charCodeAt(position) ：获取字符串中的单个字符 concat()：把一个或多个字符串连接到 String 对象的原始值上 indexOf()：从字符串的开头（位置 0）开始检索字符串，返回位置值 lastIndexOf()：从字符串的结尾开始检索子串，返回位置值 localeCompare()：对字符串进行对比，入参大于对象返回1，等于返回0，小于返回-1 slice() ：截取字符串 substring()：截取字符串，会把负数作为0，把较小的数字作为起始位，较大的数字作为终止位。 toLowerCase()：小写 toLocaleLowerCase()：特定区域小写，建议是使用 toUpperCase()：大写 toLocaleUpperCase()：特定区域大写，建议是使用 2.7.类型转换12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 转换成字符串var bFound = false;alert(bFound.toString()); //输出 "false"var iNum = 10;alert(iNum.toString(2)); //输出 "1010"alert(iNum.toString(8)); //输出 "12"alert(iNum.toString(16)); //输出 "A"// 转换成整数var iNum1 = parseInt("12345red"); //返回 12345var iNum1 = parseInt("0xA"); //返回 10var iNum1 = parseInt("56.9"); //返回 56var iNum1 = parseInt("red"); //返回 NaN// 转换成浮点型var fNum1 = parseFloat("12345red"); //返回 12345var fNum2 = parseFloat("0xA"); //返回 NaNvar fNum3 = parseFloat("11.2"); //返回 11.2var fNum4 = parseFloat("11.22.33"); //返回 11.22var fNum5 = parseFloat("0102"); //返回 102var fNum1 = parseFloat("red"); //返回 NaN// 强转// 转换成布尔型var b1 = Boolean(""); //false - 空字符串var b2 = Boolean("hello"); //true - 非空字符串var b1 = Boolean(50); //true - 非零数字var b1 = Boolean(null); //false - nullvar b1 = Boolean(0); //false - 零var b1 = Boolean(new object()); //true - 对象// 转换成数字var iNum1 = Number(false) //0var iNum1 = Number(true) //1var iNum1 = Number(undefined) //NaNvar iNum1 = Number(null) //0var iNum1 = Number("1.2") //1.2var iNum1 = Number("12") //12var iNum1 = Number("1.2.3") //NaNvar iNum1 = Number(new object()) //NaNvar iNum1 = Number(50) //50// 转换成字符串var s1 = String(null); //"null"var oNull = null;var s2 = oNull.toString(); //会引发错误 2.8.类型转换123// instanceof 判断类型var oStringObject = new String("hello world");alert(oStringObject instanceof String); //输出 "true" 三、ECMAScript的运算符一元运算符一元运算符只有一个参数，即要操作的对象或值。 delete:运算符删除对以前定义的对象属性或方法的引用。 12345var o = new Object;o.name = "David";alert(o.name); //输出 "David"delete o.name;alert(o.name); //输出 "undefined" void: 对任何值返回 undefined , 该运算符通常用于避免输出不应该输出的值 1&lt;a href="javascript:void(window.open('about:blank'))"&gt;Click me&lt;/a&gt; 前增量/前减量运算符: 注意增量和减量运算符都发生在计算表达式之前 1234567var iNum = 10;++iNum;alert(iNum); //输出 "11"--iNum;alert(iNum); //输出 "10"alert(--iNum); //输出 "9"alert(iNum); //输出 "9" 后增量/后减量运算符:在计算过包含它们的表达式后才进行增量或减量运算的。 1234567var iNum = 10;iNum++;alert(iNum); //输出 "11"iNum--;alert(iNum); //输出 "10"alert(iNum--); //输出 "10"alert(iNum); //输出 "9" 一元加法和一元减法：对数字无任何影响，会把字符串转换成数字 12345678910var sNum = "20";alert(typeof sNum); //输出 "string"var iNum = +sNum;alert(typeof iNum); //输出 "number"var sNum = "20";alert(typeof sNum); //输出 "string"var iNum = -sNum;alert(iNum); //输出 "-20"alert(typeof iNum); //输出 "number" 位运算符在数字底层（即表示数字的 32 个数位）进行操作的。 ECMAScript 整数有两种类型，即有符号整数（允许用正数和负数）和无符号整数（只允许用正数）。 注意：所有整数字面量都默认存储为有符号整数。只有 ECMAScript 的位运算符才能创建无符号整数。 NOT：由否定号（~）表示 把运算数转换成 32 位数字 把二进制数转换成它的二进制反码 把二进制数转换成浮点数 AND：由和号（&amp;）表示 OR：由符号（|）表示 XOR： 由符号（^）表示，当只有一个数位存放的是 1 时，它才返回 1。 左移运算：由两个小于号表示（&lt;&lt;），数字中的所有数位向左移动指定的数量。 有符号右移运算：由两个大于号表示（&gt;&gt;），把 32 位数字中的所有数位整体右移，同时保留该数的符号（正号或负号）。负数（正数求反+1；带符号位移，左侧空位补1，-1求反，补充符号信息） 无符号右移运算：由三个大于号（&gt;&gt;&gt;）表示，它将无符号 32 位数的所有数位整体右移。 逻辑运算符逻辑运算符有三种： NOT：！表示 AND：&amp;&amp; 表示 OR：|| 表示 参数类型 结果 Undefined false Null false Boolean 结果等于输入的参数（不转换） Number 如果参数为 +0, -0 或 NaN，则结果为 false；否则为 true。 String 如果参数为空字符串，则结果为 false；否则为 true。 Object true 乘性运算符 乘法运算符：由星号（*）表示，用于两数相乘。 除法运算符：由斜杠（/）表示，用第二个运算数除第一个运算数： 取模（余数）运算符：由百分号（%）表示 如果被除数是 无穷大的数，或除数是 0，结果为 NaN。 无穷大的数 被 无穷大的数 除，结果为 NaN。 如果除数是无穷大的数，结果为被除数。 如果被除数为 0，结果为 0。 加性运算符 加法运算符：由加号（+）表示 某个运算数是 NaN，那么结果为 NaN。 -Infinity 加 -Infinity，结果为 -Infinity。 Infinity 加 -Infinity，结果为 NaN。 +0 加 +0，结果为 +0。 -0 加 +0，结果为 +0。 -0 加 -0，结果为 -0。 如果两个运算数都是字符串，把第二个字符串连接到第一个上。 如果只有一个运算数是字符串，把另一个运算数转换成字符串，结果是两个字符串连接成的字符串。 减法运算符：由加号（-）表示 某个运算数是 NaN，那么结果为 NaN。 Infinity 减 Infinity，结果为 NaN。 -Infinity 减 -Infinity，结果为 NaN。 Infinity 减 -Infinity，结果为 Infinity。 -Infinity 减 Infinity，结果为 -Infinity。 +0 减 +0，结果为 +0。 -0 减 -0，结果为 -0。 +0 减 -0，结果为 +0。 某个运算符不是数字，那么结果为 NaN。 关系运算符关系运算符小于、大于、小于等于和大于等于执行的是两个数的比较运算，每个关系运算符都返回一个布尔值。 字符串相互比较：从左到右开始比较 字符串的ASCII大小 字符串和数字比较：把字符串转换成数字再比较大小，如果非数字字符串会转换为NaN，包含NaN结果为false 等性运算符等号和非等号用于处理原始值，全等号和非全等号用于处理对象。 等号：由双等号（==）表示，当且仅当两个运算数相等时，它返回 true。 非等号：由感叹号加等号（!=）表示，当且仅当两个运算数不相等时，它返回 true。 为确定两个运算数是否相等，这两个运算符都会进行类型转换。执行类型转换的规则如下： 如果一个运算数是 Boolean 值，在检查相等性之前，把它转换成数字值。false 转换成 0，true 为 1。 如果一个运算数是字符串，另一个是数字，在检查相等性之前，要尝试把字符串转换成数字。 如果一个运算数是对象，另一个是字符串，在检查相等性之前，要尝试把对象转换成字符串。 如果一个运算数是对象，另一个是数字，在检查相等性之前，要尝试把对象转换成数字 在比较时，该运算符还遵守下列规则： 值 null 和 undefined 相等。 在检查相等性时，不能把 null 和 undefined 转换成其他值。 如果某个运算数是 NaN，等号将返回 false，非等号将返回 true。 如果两个运算数都是对象，那么比较的是它们的引用值。如果两个运算数指向同一对象，那么等号返回 true，否则两个运算数不等。 全等号：由三个等号表示（===），只有在无需类型转换运算数就相等的情况下，才返回 true。 非全等号：由感叹号加两个等号（!==）表示，只有在无需类型转换运算数不相等的情况下，才返回 true。 条件运算符1variable = boolean_expression ? true_value : false_value; 该表达式主要是根据 boolean_expression 的计算结果有条件地为变量赋值。如果 Boolean_expression 为 true，就把 true_value 赋给变量；如果它是 false，就把 false_value 赋给变量。 赋值运算符赋值运算符由等号（=）实现，只是把等号右边的值赋予等号左边的变量。 简单赋值 (=) 乘法/赋值（*=） 除法/赋值（/=） 取模/赋值（%=） 加法/赋值（+=） 减法/赋值（-=） 左移/赋值（&lt;&lt;=） 有符号右移/赋值（&gt;&gt;=） 无符号右移/赋值（&gt;&gt;&gt;=） 逗号运算符用逗号运算符可以在一条语句中执行多个运算。 1var iNum1 = 1, iNum = 2, iNum3 = 3; 四、ECMAScript的语句if 语句1234// 如果条件计算结果为 true，则执行 statement1；如果条件计算结果为 false，则执行 statement2。if (condition) statement1 else statement2;// 如果 condition1 计算结果为 true，则执行 statement1；如果 condition1 计算结果为 false且 condition2条件为 true，则执行 statement2,否则执行 statement3。if (condition1) statement1 else if (condition2) statement2 else statement3; condition 可以是任何表达式，计算的结果甚至不必是真正的 boolean 值，ECMAScript 会把它转换成 boolean 值。 迭代语句迭代语句又叫循环语句，声明一组要反复执行的命令，直到满足某些条件为止。 do-while 语句:后测试循环，即退出条件在执行循环内部的代码之后计算。这意味着在计算表达式之前，至少会执行循环主体一次。 1do &#123;statement&#125; while (expression); while 语句:前测试循环。这意味着退出条件是在执行循环内部的代码之前计算的。因此，循环主体可能根本不被执行。 1while (expression) statement for 语句:前测试循环，而且在进入循环之前，能够初始化变量，并定义循环后要执行的代码。 1for (initialization; expression; post-loop-expression) statement 注意：post-loop-expression 之后不能写分号，否则无法运行。 for 语句是严格的迭代语句，用于枚举对象的属性。 1for (property in expression) statement 标签语句 用下列语句给语句加标签，以便以后调用： 1label : statement 配合 break 或 continue 语句使用。 break 和 continue 语句 break 语句: 可以立即退出循环，阻止再次反复执行任何代码。 continue 语句: 只是退出当前循环，根据控制表达式还允许继续进行下一次循环。 break 语句和 continue 语句都可以与有标签的语句联合使用，返回代码中的特定位置。 123456789101112131415161718192021222324252627var iNum = 0;outermost:for (var i=0; i&lt;10; i++) &#123; for (var j=0; j&lt;10; j++) &#123; if (i == 5 &amp;&amp; j == 5) &#123; break outermost; &#125; iNum++; &#125;&#125;alert(iNum); //输出 "55"iNum = 0;outermost:for (var i=0; i&lt;10; i++) &#123; for (var j=0; j&lt;10; j++) &#123; if (i == 5 &amp;&amp; j == 5) &#123; continue outermost; &#125; iNum++; &#125;&#125;alert(iNum); //输出 "95" with 语句 with 语句:用于设置代码在特定对象中的作用域。 12345with (expression) statementvar sMessage = "hello";with(sMessage) &#123; alert(toUpperCase()); //输出 "HELLO"&#125; 提示：with 语句是运行缓慢的代码块，尤其是在已设置了属性值时。大多数情况下，如果可能，最好避免使用它。 switch 语句 switch 语句是 if 语句的兄弟语句。 12345678910111213switch (expression) case value: statement; break; case value: statement; break; case value: statement; break; case value: statement; break;... case value: statement; break; default: statement; 五、ECMAScript 函数 函数的基本语法是这样的： 123function functionName(arg0, arg1, ... argN) &#123; statements // 可以return 返回值&#125; 调用函数:通过其名字加上括号中的参数进行调用，如果有多个参数。 1functionName(arg0, arg1, ... argN) 特殊对象 arguments，开发者无需明确指出参数名，就能访问它们。 123456789101112131415161718192021// 例如，在函数 sayHi() 中，第一个参数是 message。用 arguments[0] 也可以访问这个值，即第一个参数的值（第一个参数位于位置 0，第二个参数位于位置 1，依此类推）。function sayHi() &#123; if (arguments[0] == "bye") &#123; return; &#125; // 检测参数个数 alert(arguments.length); alert(arguments[0]);&#125;// 用 arguments 对象判断传递给函数的参数个数，即可模拟函数重载：function doAdd() &#123; if(arguments.length == 1) &#123; alert(arguments[0] + 5); &#125; else if(arguments.length == 2) &#123; alert(arguments[0] + arguments[1]); &#125;&#125;doAdd(10); //输出 "15"doAdd(40, 20); //输出 "60" Function 对象（类） 1234var function_name = new function(arg1, arg2, ..., argN, function_body)// 输入参数个数function_name.length 闭包，指的是词法表示包括不被计算的变量的函数，也就是说，函数可以使用函数之外定义的变量。 1234567891011121314151617// 简单var sMessage = "hello world";function sayHelloWorld() &#123; alert(sMessage);&#125;sayHelloWorld();var iBaseNum = 10;function addNum(iNum1, iNum2) &#123; function doAdd() &#123; return iNum1 + iNum2 + iBaseNum; &#125; return doAdd();&#125; 六、对象面向对象术语 对象： 属性的无序集合，每个属性存放一个原始值、对象或函数 类： 对象的抽象化。不仅要定义对象的接口（interface）（开发者访问的属性和方法），还要定义对象的内部工作（使属性和方法发挥作用的代码）。 实例： 使用类创建对象时，生成的对象叫作类的实例（instance） 基本能力： 封装 - 把相关的信息（无论数据或方法）存储在对象中的能力 聚集 - 把一个对象存储在另一个对象内的能力 继承 - 由另一个类（或多个类）得来类的属性和方法的能力 多态 - 编写能以多种方法运行的函数或方法的能力 对象的构成：对象由特性（attribute）构成，特性可以是原始值，也可以是引用值。如果特性存放的是函数，它将被看作对象的方法（method），否则该特性被看作对象的属性（property）。 对象应用对象的创建和销毁都在 JavaScript 执行过程中发生，理解这种范式的含义对理解整个语言至关重要。 声明和实例化 12var oObject = new Object();var oStringObject = new String(); 对象废除ECMAScript 拥有垃圾回收程序（garbage collection routine）,把对象的所有引用都设置为 null，可以强制性地废除对象。 123var oObject = new Object;// do something with the object hereoObject = null; 早绑定和晚绑定所谓绑定（binding），即把对象的接口与对象实例结合在一起的方法。 早绑定（early binding 静态语言）是指在实例化对象之前定义它的属性和方法，这样编译器或解释程序就能够提前转换机器代码。 晚绑定（late binding 动态语言）指的是编译器或解释程序在运行前，不知道对象的类型。 对象类型 本地对象( 引用类型 ):独立于宿主环境的 ECMAScript 实现提供的对象 Object Function Array String Boolean Number Date RegExp Error EvalError RangeError ReferenceError SyntaxError TypeError URIError 内置对象:由 ECMAScript 实现提供的、独立于宿主环境的所有对象 Global Math 宿主对象 BOM DOM 对象作用域ECMAScript 只有公用作用域,由于缺少私有作用域，开发者确定了一个规约，说明哪些属性和方法应该被看做私有的。这种规约规定在属性前后加下划线. 1obj._color_ = "blue"; 12345678// 关键字 this 总是指向调用该方法的对象var oCar = new Object;oCar.color = "red";oCar.showColor = function() &#123; alert(this.color);&#125;;oCar.showColor(); //输出 "red" 定义类或对象 工厂方式 1234567891011121314// 创造了能创建并返回特定类型的对象的工厂函数（factory function）。function createCar() &#123;var oTempCar = new Object;oTempCar.color = "blue";oTempCar.doors = 4;oTempCar.mpg = 25;oTempCar.showColor = function() &#123;alert(this.color);&#125;;return oTempCar;&#125;var oCar1 = createCar();var oCar2 = createCar(); 构造函数方式 123456789101112// 名字的首字母大写，以使它与首字母通常是小写的变量名分开,使用 this 关键字。使用 new 运算符构造函数时，在执行第一行代码前先创建一个对象，只有用 this 才能访问该对象。function Car(sColor,iDoors,iMpg) &#123;this.color = sColor;this.doors = iDoors;this.mpg = iMpg;this.showColor = function() &#123;alert(this.color);&#125;;&#125;var oCar1 = new Car("red",4,23);var oCar2 = new Car("blue",3,25); 原型方式 12345678910111213141516171819// 用空构造函数来设置类名。然后所有的属性和方法都被直接赋予 prototype 属性function Car() &#123;&#125;Car.prototype.color = "blue";Car.prototype.doors = 4;Car.prototype.mpg = 25;Car.prototype.showColor = function() &#123; alert(this.color);&#125;;var oCar1 = new Car();var oCar2 = new Car();//不同的实例修改属性值相互影响oCar1.drivers.push("Bill");alert(oCar1.drivers); //输出 "Mike,John,Bill"alert(oCar2.drivers); //输出 "Mike,John,Bill" 混合的构造函数/原型方式 12345678910111213141516171819// 所有的非函数属性都在构造函数中创建，意味着又能够用构造函数的参数赋予属性默认值了。function Car(sColor,iDoors,iMpg) &#123;this.color = sColor;this.doors = iDoors;this.mpg = iMpg;this.drivers = new Array("Mike","John");&#125;Car.prototype.showColor = function() &#123;alert(this.color);&#125;;var oCar1 = new Car("red",4,23);var oCar2 = new Car("blue",3,25);oCar1.drivers.push("Bill");alert(oCar1.drivers); //输出 "Mike,John,Bill"alert(oCar2.drivers); //输出 "Mike,John" 动态原型方法 1234567891011121314function Car(sColor,iDoors,iMpg) &#123; this.color = sColor; this.doors = iDoors; this.mpg = iMpg; this.drivers = new Array("Mike","John"); if (typeof Car._initialized == "undefined") &#123; Car.prototype.showColor = function() &#123; alert(this.color); &#125;; Car._initialized = true; &#125;&#125; 混合工厂方式 123456789101112function Car() &#123;var oTempCar = new Object;oTempCar.color = "blue";oTempCar.doors = 4;oTempCar.mpg = 25;oTempCar.showColor = function() &#123;alert(this.color);&#125;;return oTempCar;&#125;var car = new Car(); 修改对象 创建新方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 通过已有的方法创建新方法Number.prototype.toHexString = function() &#123; return this.toString(16);&#125;;var iNum = 15;alert(iNum.toHexString()); //输出 "F"// 重命名已有方法Array.prototype.enqueue = function(vItem) &#123; this.push(vItem);&#125;;Array.prototype.dequeue = function() &#123; return this.shift();&#125;;// 添加与已有方法无关的方法Array.prototype.indexOf = function (vItem) &#123; for (var i=0; i&lt;this.length; i++) &#123; if (vItem == this[i]) &#123; return i; &#125; &#125; return -1;&#125;var aColors = new Array("red","green","blue");alert(aColors.indexOf("green")); //输出 "1"// 为本地对象添加新方法Object.prototype.showValue = function () &#123; alert(this.valueOf());&#125;;var str = "hello";var iNum = 25;str.showValue(); //输出 "hello"iNum.showValue(); //输出 "25"// 重定义已有方法Function.prototype.toString = function() &#123; return "Function code hidden";&#125;function sayHi() &#123; alert("hi");&#125;alert(sayHi.toString()); //输出 "Function code hidden" 七、继承机制实例对象冒充1234567891011121314151617// 构造函数使用 this 关键字给所有属性和方法赋值（即采用类声明的构造函数方式）。function ClassA(sColor) &#123; this.color = sColor; this.sayColor = function () &#123; alert(this.color); &#125;;&#125;function ClassB(sColor, sName) &#123; this.newMethod = ClassA; this.newMethod(sColor); delete this.newMethod; this.name = sName; this.sayName = function () &#123; alert(this.name); &#125;;&#125; call()123456789101112// 与经典的对象冒充方法最相似的方法。它的第一个参数用作 this 的对象。其他参数都直接传递给函数自身。function ClassB(sColor, sName) &#123; //this.newMethod = ClassA; //this.newMethod(color); //delete this.newMethod; ClassA.call(this, sColor); this.name = sName; this.sayName = function () &#123; alert(this.name); &#125;;&#125; apply()123456789101112// 有两个参数，用作 this 的对象和要传递给函数的参数的数组function ClassB(sColor, sName) &#123; //this.newMethod = ClassA; //this.newMethod(color); //delete this.newMethod; ClassA.apply(this, new Array(sColor)); // 或 ClassA.apply(this, arguments); this.name = sName; this.sayName = function () &#123; alert(this.name); &#125;;&#125; 原型链1234567891011121314151617181920212223242526function ClassA() &#123;&#125;ClassA.prototype.color = "blue";ClassA.prototype.sayColor = function () &#123; alert(this.color);&#125;;function ClassB() &#123;&#125;ClassB.prototype = new ClassA();ClassB.prototype.name = "";ClassB.prototype.sayName = function () &#123; alert(this.name);&#125;;var objA = new ClassA();var objB = new ClassB();objA.color = "blue";objB.color = "red";objB.name = "John";objA.sayColor();objB.sayColor();objB.sayName(); 混合方式1234567891011121314151617181920212223function ClassA(sColor) &#123; this.color = sColor;&#125;ClassA.prototype.sayColor = function () &#123; alert(this.color);&#125;;function ClassB(sColor, sName) &#123; ClassA.call(this, sColor); this.name = sName;&#125;ClassB.prototype = new ClassA();ClassB.prototype.sayName = function () &#123; alert(this.name);&#125;;var objA = new ClassA("blue");var objB = new ClassB("red", "John");objA.sayColor(); //输出 "blue"objB.sayColor(); //输出 "red"objB.sayName(); //输出 "John" More info: ECMAScript]]></content>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript（三）JavaScript的基本知识(下)]]></title>
    <url>%2F2016%2F12%2F15%2FJavaScript03%2F</url>
    <content type="text"><![CDATA[本文章主要介绍 JavaScript 的相关知识。 Quick Guide一、execCommand函数命令execCommand方法是执行一个对当前文档，当前选择或者给出范围的命令。处理Html数据时常用 1document.execCommand(sCommand[,交互方式, 动态参数]) sCommand为指令参数（如下例中的”2D-Position”） 交互方式参数如果是true的话将显示对话框，如果为false的话，则不显示对话框 动态参数一般为一可用值或属性值（如下例中的”true”）。 1document.execCommand("2D-Position","false","true"); 1.1.指令参数及意义12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576772D-Position 允许通过拖曳移动绝对定位的对象。AbsolutePosition 设定元素的 position 属性为“absolute”(绝对)。BackColor 设置或获取当前选中区的背景颜色。BlockDirLTR 目前尚未支持。BlockDirRTL 目前尚未支持。Bold 切换当前选中区的粗体显示与否。BrowseMode 目前尚未支持。Copy 将当前选中区复制到剪贴板。CreateBookmark 创建一个书签锚或获取当前选中区或插入点的书签锚的名称。CreateLink 在当前选中区上插入超级链接，或显示一个对话框允许用户指定要为当前选中区插入的超级链接的 URL。Cut 将当前选中区复制到剪贴板并删除之。Delete 删除当前选中区。DirLTR 目前尚未支持。DirRTL 目前尚未支持。EditMode 目前尚未支持。FontName 设置或获取当前选中区的字体。FontSize 设置或获取当前选中区的字体大小。ForeColor 设置或获取当前选中区的前景(文本)颜色。FormatBlock 设置当前块格式化标签。Indent 增加选中文本的缩进。InlineDirLTR 目前尚未支持。InlineDirRTL 目前尚未支持。InsertButton 用按钮控件覆盖当前选中区。InsertFieldset 用方框覆盖当前选中区。InsertHorizontalRule 用水平线覆盖当前选中区。InsertIFrame 用内嵌框架覆盖当前选中区。InsertImage 用图像覆盖当前选中区。InsertInputButton 用按钮控件覆盖当前选中区。InsertInputCheckbox 用复选框控件覆盖当前选中区。InsertInputFileUpload 用文件上载控件覆盖当前选中区。InsertInputHidden 插入隐藏控件覆盖当前选中区。InsertInputImage 用图像控件覆盖当前选中区。InsertInputPassword 用密码控件覆盖当前选中区。InsertInputRadio 用单选钮控件覆盖当前选中区。InsertInputReset 用重置控件覆盖当前选中区。InsertInputSubmit 用提交控件覆盖当前选中区。InsertInputText 用文本控件覆盖当前选中区。InsertMarquee 用空字幕覆盖当前选中区。InsertOrderedList 切换当前选中区是编号列表还是常规格式化块。InsertParagraph 用换行覆盖当前选中区。InsertSelectDropdown 用下拉框控件覆盖当前选中区。InsertSelectListbox 用列表框控件覆盖当前选中区。InsertTextArea 用多行文本输入控件覆盖当前选中区。InsertUnorderedList 切换当前选中区是项目符号列表还是常规格式化块。Italic 切换当前选中区斜体显示与否。JustifyCenter 将当前选中区在所在格式化块置中。JustifyFull 目前尚未支持。JustifyLeft 将当前选中区所在格式化块左对齐。JustifyNone 目前尚未支持。JustifyRight 将当前选中区所在格式化块右对齐。LiveResize 迫使 MSHTML 编辑器在缩放或移动过程中持续更新元素外观，而不是只在移动或缩放完成后更新。MultipleSelection 允许当用户按住 Shift 或 Ctrl 键时一次选中多于一个站点可选元素。Open 目前尚未支持。Outdent 减少选中区所在格式化块的缩进。OverWrite 切换文本状态的插入和覆盖。Paste 用剪贴板内容覆盖当前选中区。PlayImage 目前尚未支持。Print 打开打印对话框以便用户可以打印当前页。Redo 目前尚未支持。Refresh 刷新当前文档。RemoveFormat 从当前选中区中删除格式化标签。RemoveParaFormat 目前尚未支持。SaveAs 将当前 Web 页面保存为文件。SelectAll 选中整个文档。SizeToControl 目前尚未支持。SizeToControlHeight 目前尚未支持。SizeToControlWidth 目前尚未支持。Stop 目前尚未支持。StopImage 目前尚未支持。StrikeThrough 目前尚未支持。Subscript 目前尚未支持。Superscript 目前尚未支持。UnBookmark 从当前选中区中删除全部书签。Underline 切换当前选中区的下划线显示与否。Undo 目前尚未支持。Unlink 从当前选中区中删除全部超级链接。Unselect 清除当前选中区的选中状态。 二、库2.1.jQueryjQuery 是目前最受欢迎的 JavaScript 框架。它使用 CSS 选择器来访问和操作网页上的 HTML 元素（DOM 对象）。jQuery 同时提供 companion UI（用户界面）和插件。 123456789101112// JavaScript function myFunction()&#123; var obj=document.getElementById("h01"); obj.innerHTML="Hello jQuery";&#125;onload=myFunction;//jQuery function myFunction()&#123; $("#h01").html("Hello jQuery");&#125;$(document).ready(myFunction); 2.2.PrototypePrototype 提供的函数可使 HTML DOM 编程更容易。 123456789101112// JavaScript function myFunction()&#123; var obj=document.getElementById("h01"); obj.innerHTML="Hello Prototype";&#125;onload=myFunction;//Prototype function myFunction()&#123; $("h01").insert("Hello Prototype!");&#125;Event.observe(window,"load",myFunction); 2.3.MooTools虽然Mootools跟Prototype几乎拥有一样的语法，但是它提供了比Prototype多的功能，而且更强大，拥有实用而清晰的文档和示例帮助你轻松入门。 二、调试2.1.开启调试 Chrome 浏览器 打开浏览器。 在菜单中选择工具。 在工具中选择开发者工具。 最后，选择 Console。 Firefox 浏览器 打开浏览器。 访问页面:http://www.getfirebug.com。 按照说明 :安装 Firebug。 Internet Explorer 浏览器。 打开浏览器。 在菜单中选择工具。 在工具中选择开发者工具。 最后，选择 Console。 Opera 打开浏览器。 Opera 的内置调试工具为 Dragonfly，详细说明可访问页面:http://www.opera.com/dragonfly/。 Safari 打开浏览器。 访问页面:http://extentions.apple.com。 按说明操作：install Firebug Lite。 2.2.调试方法 console.log() 方法 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;My First Web Page&lt;/h1&gt;&lt;script&gt;a = 5;b = 6;c = a + b;console.log(c);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 设置断点 debugger 123var x = 15 * 5;debugger;document.getElementbyId("demo").innerHTML = x; //开启 debugger ，代码在第三行前停止执行。 三、代码规范规范的代码可以更易于阅读与维护。 3.1.变量名 推荐使用驼峰法来命名(camelCase): 变量名应该区分大小写，允许包含字母、数字、美元符号($)和下划线，但第一个字符不允许是数字，不允许包含空格和其他标点符号； 变量命名长度应该尽可能的短，并抓住要点，尽量在变量名中体现出值的类型； 变量名的命名应该是有意义的； 变量名不能为JavaScript中的关键词、保留字全名； 变量名命名方法常见的有匈牙利命名法、驼峰命名法和帕斯卡命名法。 1234567firstName = "John";lastName = "Doe";price = 19.90;tax = 0.20;fullPrice = price + (price * tax); 3.2.空格与运算符 通常运算符 ( = + - * / ) 前后需要添加空格: 12var x = y + z;var values = ["Volvo", "Saab", "Fiat"]; 通常使用 4 个空格符号来缩进代码块：123function toCelsius(fahrenheit) &#123; return (5 / 9) * (fahrenheit - 32);&#125; 3.3.语句规则 一条简单语句通常以分号作为结束符。 12345678var values = ["Volvo", "Saab", "Fiat"];var person = &#123; firstName: "John", lastName: "Doe", age: 50, eyeColor: "blue"&#125;; 复杂语句的通用规则: 将左花括号放在第一行的结尾。 左花括号前添加一空格。 将右花括号独立放在一行。 不要忘记以分号结束一个复杂的声明。 123function toCelsius(fahrenheit) &#123; return (5 / 9) * (fahrenheit - 32);&#125; 每行代码字符小于 80 3.5.对象规则对象定义的规则: 将左花括号与类名放在同一行。 冒号与属性值间有个空格。 字符串使用双引号，数字不需要。 最后一个属性-值对后面不要添加逗号。 将右花括号独立放在一行，并以分号作为结束符号。 123456var person = &#123; firstName: "John", lastName: "Doe", age: 50, eyeColor: "blue"&#125;; 3.6.命名规则 变量和函数为驼峰法（ camelCase） 全局变量为大写 (UPPERCASE ) 常量 (如 PI) 为大写 (UPPERCASE ) 使用简洁的格式载入 JavaScript 文件 ( type 属性不是必须的): 1&lt;script src="myscript.js"&gt; HTML 与 JavaScript 尽量使用相同的命名规则。 使用小写文件名 四、性能 不要使用 with() 语句 因为 with() 语句将会在作用域链的开始添加额外的变量。 额外的变量意味着，当任何变量需要被访问的时候，JavaScript引擎都需要先扫描with()语句产生的变量，然后才是局部变量，最后是全局变量。 因此with()语句同时给局部变量和全局变量的性能带来负面影响，最终使我们优化JavaScript性能的计划破产。 避免全局查找 用”” + 1来将数字转换成字符串，虽然看起来比较丑一点，但事实上这个效率是最高的 1(&quot;&quot; +) &gt; String() &gt; .toString() &gt; new String() 通过模板元素clone，替代createElement 避免低效率的脚本位置 123456789101112131415161718192021222324252627&lt;!--低效率--&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Source Example&lt;/title&gt; &lt;script type="text/javascript" src="script1.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="script2.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="script3.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" type="text/css" href="styles.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Hello world!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--推荐--&gt;&lt;head&gt; &lt;title&gt;Source Example&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="styles.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Hello world!&lt;/p&gt; &lt;!-- Example of efficient script positioning --&gt; &lt;script type="text/javascript" src="script1.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="script2.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="script3.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 小心使用闭包 在循环时将控制条件和控制变量合并起来 1234567// 错误for ( var x = 0; x &lt; 10; x++ ) &#123;&#125;;//正确var x = 9;do &#123; &#125; while( x-- ); 使用 XMLHttpRequest(XHR)对象 优点:下载不立即执行的 JavaScript 代码。由于代码返回在&lt;script>标签之外（换句话说不受&lt;script>标签约束），它下载后不会自动执行，这使得您可以推迟执行，直到一切都准备好了。另一个优点是，同样的代码在所有现代浏览器中都不会引发异常。 缺点：JavaScript 文件必须与页面放置在同一个域内，不能从 CDN 下载（CDN 指”内容投递网络 Content Delivery Network）”，所以大型网页通常不采用 XHR 脚本注入技术。 最小化访问NodeList的次数可以极大的改进脚本的性能 避免与null进行比较 尊重对象的所有权 避免循环引用 123456789101112131415161718192021222324252627282930313233// 错误:init在执行的时候，当前上下文我们叫做context。这个时候，context引用了el，el引用了function，function引用了context。这时候形成了一个循环引用。function init() &#123; var el = document.getElementById('MyElement'); el.onclick = function () &#123; //…… &#125;&#125;init();//正确:置空dom对象function init() &#123; var el = document.getElementById('MyElement'); el.onclick = function () &#123; //…… &#125; try &#123; return el; &#125; finally &#123; el = null; &#125;&#125;init();//正确:构造新的contextfunction elClickHandler() &#123;//……&#125;function init() &#123; var el = document.getElementById('MyElement'); el.onclick = elClickHandler;&#125;init(); 通过javascript创建的dom对象，必须append到页面中 字符串连接避免使用+= 使用直接量 12345678910111213141516var aTest = new Array(); //替换为var aTest = [];var aTest = new Object; //替换为var aTest = &#123;&#125;;var reg = new RegExp(); //替换为var reg = /../;//如果要创建具有一些特性的一般对象，也可以使用字面量，如下：var oFruit = new O;oFruit.color = "red";oFruit.name = "apple";//前面的代码可用对象字面量来改写成这样：var oFruit = &#123; color: "red", name: "apple" &#125;; 尽量少使用eval函数 不要给setTimeout或者setInterval传递字符串参数 缩短否定检测 12345678910111213if(oTest != '#ff0000')&#123; //do something&#125;if(oTest != null)&#123;//do something&#125;if(oTest != false)&#123; //do something&#125;//虽然这些都正确，但用逻辑非操作符来操作也有同样的效果：if(!oTest)&#123;//do something&#125; 释放javascript对象 尽量使用原生方法 switch语句相对if较快 位运算较快 巧用||和&amp;&amp;布尔运算符 1234567function eventHandler(e) &#123; if (!e) e = window.event;&#125;//可以替换为：function eventHandler(e) &#123; e = e || window.event;&#125; 五、注意事项 每条语句末尾须加分号 使用+号时需谨慎 使用return语句需要注意不要用()括号来括住返回值，如果返回表达式，则表达式应与return关键字在同一行，以避免压缩时，压缩工具自动加分号而造成返回与开发人员不一致的结果 在比较是否相等的情况下，最好使用全等运行符，也就是使用===和!==操作符会相对于==和!=会好点。==和!=操作符会进行类型强制转换 不要使用生偏语法，写让人迷惑的代码，虽然计算机能够正确识别并运行，但是晦涩难懂的代码不方便以后维护 函数返回统一类型 总是检查数据类型 在HTML中使用双引号，在JavaScript中使用单引号，但为了兼容各个浏览器，也为了解析时不会出错，定义JSON对象时，最好使用双引号 用JSLint运行JavaScript验证器来确保没有语法错误或者是代码没有潜在的问题。 部署之前推荐使用压缩工具将JS文件压缩。 文件编码统一用UTF-8。 JavaScript 程序应该尽量放在 .js 的文件中。 More info: JavaScript教程]]></content>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript（二）JavaScript的基本知识(中)]]></title>
    <url>%2F2016%2F11%2F15%2FJavaScript02%2F</url>
    <content type="text"><![CDATA[本文章主要介绍 JavaScript 的高级语法。 Quick Guide一、HTML DOM通过 HTML DOM，可访问 JavaScript HTML 文档的所有元素。 JavaScript 能够改变页面中的所有 HTML 元素 JavaScript 能够改变页面中的所有 HTML 属性 JavaScript 能够改变页面中的所有 CSS 样式 JavaScript 能够对页面中的所有事件做出反应 1.1.查找 HTML 元素 通过 id 找到 HTML 元素 1var x=document.getElementById("intro"); 通过标签名找到 HTML 元素 12var x=document.getElementById("main");var y=x.getElementsByTagName("p"); 通过类名找到 HTML 元素 1var x=document.getElementsByClassName("intro"); 1.2.改变 HTML 内容 改变 HTML 输出流 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;script&gt;document.write(Date());&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 改变 HTML 输出流 1234567891011&lt;html&gt;&lt;body&gt;&lt;p id="p1"&gt;Hello World!&lt;/p&gt;&lt;script&gt;document.getElementById("p1").innerHTML="New text!";&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 改变 HTML 输出流 1document.getElementById(id).attribute=new value 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;img id="image" src="smiley.gif"&gt;&lt;script&gt;document.getElementById("image").src="landscape.jpg";&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.2.改变 改变 CSS1document.getElementById(id).style.property=new style 12345678910111213&lt;html&gt;&lt;body&gt;&lt;p id="p2"&gt;Hello World!&lt;/p&gt;&lt;script&gt;document.getElementById("p2").style.color="blue";&lt;/script&gt;&lt;p&gt;The paragraph above was changed by a script.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 1.3.事件触发改变在事件发生时执行 JavaScript，比如当用户在 HTML 元素上点击时。 当用户点击鼠标时 当网页已加载时 当图像已加载时 当鼠标移动到元素上时 当输入字段被改变时 当提交 HTML 表单时 当用户触发按键时 1onclick=JavaScript 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1 onclick="this.innerHTML='Ooops!'"&gt;点击文本!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&lt;button onclick="displayDate()"&gt;点我&lt;/button&gt;document.getElementById("myBtn").onclick=function()&#123;displayDate()&#125;;&lt;body onload="checkCookies()"&gt;&lt;input type="text" id="fname" onchange="upperCase()"&gt; HTML 事件属性 1&lt;button onclick="displayDate()"&gt;点我&lt;/button&gt; 使用 HTML DOM 来分配事件 1document.getElementById("myBtn").onclick=function()&#123;displayDate()&#125;; onload 和 onunload 事件:在用户进入或离开页面时被触发。 1&lt;body onload="checkCookies()"&gt; onchange 事件 1&lt;input type="text" id="fname" onchange="upperCase()"&gt; 1.4.事件监听器给页面的某些元素添加事件的监听器，当元素触发相应事件的时候监听器就会捕捉到这个事件并执行相应的代码。 addEventListener() 用于向指定元素添加事件句柄。 添加的事件句柄不会覆盖已存在的事件句柄。 1element.addEventListener(event, function, useCapture); 第一个参数是事件的类型 (如 “click” 或 “mousedown”). 第二个参数是事件触发后调用的函数。 第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的。 在冒泡中，内部元素的事件会先被触发，然后再触发外部元素，即： &lt;p> 元素的点击事件先触发，然后会触发 &lt;div> 元素的点击事件。 在捕获中，外部元素的事件会先被触发，然后才会触发内部元素的事件，即： &lt;div> 元素的点击事件先触发 ，然后再触发 &lt;p> 元素的点击事件。 123456789101112131415// 向原元素添加事件句柄element.addEventListener("click", function()&#123; alert("Hello World!"); &#125;);//向同一个元素中添加多个事件句柄element.addEventListener("click", myFunction);element.addEventListener("click", mySecondFunction);element.addEventListener("mouseout", myThirdFunction);//向 Window 对象添加事件句柄window.addEventListener("resize", function()&#123; document.getElementById("demo").innerHTML = sometext;&#125;);//传递参数element.addEventListener("click", function()&#123; myFunction(p1, p2); &#125;); removeEventListener() 方法:移除由 addEventListener() 方法添加的事件句柄 注意： IE 8 及更早 IE 版本，Opera 7.0及其更早版本不支持 addEventListener() 和 removeEventListener() 方法。 12element.attachEvent(event, function);element.detachEvent(event, function); 1element.removeEventListener("mousemove", myFunction); 1.5.添加或删除 HTML 元素 创建新的 HTML 元素 12345678910111213&lt;div id="div1"&gt;&lt;p id="p1"&gt;This is a paragraph.&lt;/p&gt;&lt;p id="p2"&gt;This is another paragraph.&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var para=document.createElement("p");var node=document.createTextNode("This is new.");para.appendChild(node);var element=document.getElementById("div1");element.appendChild(para);&lt;/script&gt; -删除已有的 HTML 元素 123456789&lt;div id="div1"&gt;&lt;p id="p1"&gt;This is a paragraph.&lt;/p&gt;&lt;p id="p2"&gt;This is another paragraph.&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var parent=document.getElementById("div1");var child=document.getElementById("p1");parent.removeChild(child);&lt;/script&gt; 二、表单2.1.获取表单元素 select:下拉列表元素 1234567891011121314&lt;div&gt;&lt;label for="os"&gt;Operating System&lt;/label&gt;&lt;select name="os" id="os"&gt; &lt;option&gt;Choose&lt;/option&gt; &lt;optgroup label="Windows"&gt; &lt;option value="7 Home Basic"&gt;7 Home Basic&lt;/option&gt; &lt;option value="7 Home Premium"&gt;7 Home Premium&lt;/option&gt; &lt;option value="7 Professional"&gt;7 Professional&lt;/option&gt; &lt;option value="7 Ultimate"&gt;7 Ultimate&lt;/option&gt; &lt;option value="Vista"&gt;Vista&lt;/option&gt; &lt;option value="XP"&gt;XP&lt;/option&gt; &lt;/optgroup&gt;&lt;select&gt;&lt;/div&gt; 1234567891011// 取到用户选择的值var data = document.getElementById('selectMenu').value;// 可以设置为多选&lt;select name="categories" id="categories" multiple&gt;var selected = [];for (var i = 0, count = elem.options.length; i &lt; count; i++) &#123; if (elem.options[i].selected) &#123; selected.push(elem.options[i].value); &#125;&#125; checkbox:多选框控件，每个选择框只有选中和不选中两种状态。 123456789101112&lt;input type="checkbox" name="toggle" id="toggle" value="toggle"&gt;&lt;!--checked属性返回一个布尔值，表示用户是否选中。--&gt;var which = document.getElementById('someCheckbox').checked;&lt;!--checked属性是可写的。--&gt;which.checked = true;&lt;!--value属性可以获取单选框的值。--&gt;if (which.checked) &#123; var value = document.getElementById('someCheckbox').value;&#125; radio:单选框控件，同一组选择框同时只能选中一个，选中元素的checked属性为true。 123456789101112131415&lt;input type="radio" name="gender" value="Male"&gt; Male &lt;/input&gt;&lt;input type="radio" name="gender" value="Female"&gt; Female &lt;/input&gt;&lt;script&gt;var radios = document.getElementsByName('gender');var selected;for (var i = 0; i &lt; radios.length; i++) &#123; if (radios[i].checked) &#123; selected = radios[i].value; break; &#125;&#125;if (selected) &#123; // 用户选中了某个选项&#125;&lt;/script&gt; 2.2.表单的验证所谓“表单验证”，指的是检查用户提供的数据是否符合要求。 必填（或必选）项目 1234567function validateForm() &#123; var x=document.forms["myForm"]["fname"].value; if (x==null || x=="")&#123; alert("First name must be filled out"); return false; &#125; &#125; E-mail 验证 123456789function validateForm()&#123; var x=document.forms["myForm"]["email"].value; var atpos=x.indexOf("@"); var dotpos=x.lastIndexOf("."); if (atpos&lt;1 || dotpos&lt;atpos+2 || dotpos+2&gt;=x.length)&#123; alert("Not a valid e-mail address"); return false; &#125; &#125; 数字验证 12345&lt;form name="myForm" action="demo_form.asp" onsubmit="return validateForm();" method="post"&gt;&lt;strong&gt;请输入1到10之间的数字：&lt;/strong&gt;&lt;input id="number"&gt;&lt;button type="button" onclick="myFunction()"&gt;提交&lt;/button&gt;&lt;/form&gt; 三、正则表达式正则表达式（英语：Regular Expression，在代码中常简写为regex、regexp或RE）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式。 1var patt = /w3cschool/i /w3cschool/i 是一个正则表达式。 w3cschool 是一个模式 (用于检索)。 i 是一个修饰符 (搜索不区分大小写)。 3.1.方法支持正则表达式的 String 对象的方法 search() 方法:用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子字符串的起始位置。 12var str = "Visit w3cschool"; var n = str.search(/w3cschool/i); //输出结果为：6 replace() 方法: 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子字符串。 12var str = "Visit Microsoft!";var res = str.replace("Microsoft", "w3cschool"); match:替换与正则表达式匹配的子串。 12var str="The rain in SPAIN stays mainly in the plain";var n=str.match(/ain/g); //输出结果为：[ain,ain,ain] split:把字符串分割为字符串数组。 12var str="How are you doing today?";var n=str.split(" "); //输出结果为：[How,are,you,doing,today?] 对象方法 test():用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false。 12var patt = /e/;patt.test("The best things in life are free!"); // 输出结果:true exec():用于检索字符串中的正则表达式的匹配。 1/e/.exec("The best things in life are free!"); // 输出结果:e compile():既可以改变检索模式，也可以添加或删除第二个参数。 1234var patt1=new RegExp("e");document.write(patt1.test("The best things in life are free")); // truepatt1.compile("d");document.write(patt1.test("The best things in life are free")); // false 3.2.正则表达式修饰符修饰符 可以在全局搜索中不区分大小写: 修饰符 描述 i 执行对大小写不敏感的匹配。 g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 m 执行多行匹配。 3.3.正则表达式模式方括号用于查找某个范围内的字符： 表达式 描述 [abc] 查找方括号之间的任何字符。 [^abc] 查找任何不在方括号之间的字符。 [0-9] 查找任何从 0 至 9 的数字。 [a-z] 查找任何从小写 a 到小写 z 的字符。 [A-Z] 查找任何从大写 A 到大写 Z 的字符。 [A-z] 查找任何从大写 A 到小写 z 的字符。 [adgk] 查找给定集合内的任何字符。 [^adgk] 查找给定集合外的任何字符。 (red\ blue\ green) 查找任何指定的选项。 元字符（Metacharacter）是拥有特殊含义的字符： 元字符 描述 . 查找单个字符，除了换行和行结束符。 \w 查找单词字符。 \W 查找非单词字符。 \d 查找数字。 \D 查找非数字字符。 \s 查找空白字符。 \S 查找非空白字符。 \b 匹配单词边界。 \B 匹配非单词边界。 \0 查找 NUL 字符。 \n 查找换行符。 \f 查找换页符。 \r 查找回车符。 \t 查找制表符。 \v 查找垂直制表符。 \xxx 查找以八进制数 xxx 规定的字符。 \xdd 查找以十六进制数 dd 规定的字符。 \uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符。 量词 描述 n+ 匹配任何包含至少一个 n 的字符串。 n* 匹配任何包含零个或多个 n 的字符串。 n? 匹配任何包含零个或一个 n 的字符串。 n{X} 匹配包含 X 个 n 的序列的字符串。 n{X,Y} 匹配包含 X 至 Y 个 n 的序列的字符串。 n{X,} 匹配包含至少 X 个 n 的序列的字符串。 n$ 匹配任何结尾为 n 的字符串。 ^n 匹配任何开头为 n 的字符串。 ?=n 匹配任何其后紧接指定字符串 n 的字符串。 ?!n 匹配任何其后没有紧接指定字符串 n 的字符串。 四、JSONJSON 英文全称 JavaScript Object NotationJSON 是一种轻量级的数据交换格式。JSON 是用于存储和传输数据的格式。JSON 通常用于服务端向网页传递数据 。 4.1.JSON 语法规则 数据为 键/值 对。 数据由逗号分隔。 大括号保存对象 方括号保存数组 12345"employees":[ &#123;"firstName":"John", "lastName":"Doe"&#125;, &#123;"firstName":"Anna", "lastName":"Smith"&#125;, &#123;"firstName":"Peter", "lastName":"Jones"&#125; ] 4.2.JSON 字符串转换为 JavaScript 对象1var obj = JSON.parse(text); 五、对象对象只是一种特殊的数据。对象拥有属性和方法。JavaScript 提供多个内建对象，比如 String、Date、Array 等等。 对象只是带有属性和方法的特殊数据类型。 布尔型可以是一个对象。 数字型可以是一个对象。 字符串也可以是一个对象 日期是一个对象 数学和正则表达式也是对象 数组是一个对象 甚至函数也可以是对象 5.1.对象的属性和方法 访问对象的属性 1objectName.propertyName 12var message="Hello World!";var x=message.length; 访问对象的方法 123456objectName.methodName() for (variable in object) &#123; //code to be executed &#125; 12var message="Hello world!";var x=message.toUpperCase(); 5.2.创建 JavaScript 对象 定义并创建对象的实例 12345person=new Object();person.firstname="John";person.lastname="Doe";person.age=50;person.eyecolor="blue"; 使用函数来定义对象，然后创建新的对象实例 1234567function person(firstname,lastname,age,eyecolor)&#123; this.firstname=firstname; this.lastname=lastname; this.age=age; this.eyecolor=eyecolor;&#125; 5.3.给 JavaScript 增加属性和方法12345678910111213141516171819202122//把属性添加到 JavaScript 对象person.firstname="John";person.lastname="Doe";person.age=30;person.eyecolor="blue";x=person.firstname;// 把方法添加到 JavaScript 对象 function person(firstname,lastname,age,eyecolor) &#123; this.firstname=firstname; this.lastname=lastname; this.age=age; this.eyecolor=eyecolor; this.changeName=changeName; function changeName(name) &#123; this.lastname=name; &#125; &#125; 5.5.给 JavaScript 增加属性和方法Number 对象JavaScript 的 Number 对象是经过封装的能让你处理数字值的对象，由 Number() 构造器创建。 1234var x = 123;var y = new Number(123);typeof(x) // returns Numbertypeof(y) // returns Object Infinity:当数字运算结果超过了JavaScript所能表示的数字上限（溢出），结果为一个特殊的无穷大（infinity）值 NaN 属性是代表非数字值的特殊值。该属性用于指示某个值不是数字。可以把 Number 对象设置为该值，来指示其不是数字值。 数字属性 MAX_VALUE MIN_VALUE NEGATIVE_INFINITY POSITIVE_INFINITY NaN prototype constructor 数字方法 toExponential() toFixed() toPrecision() toString() valueOf() 字符串（String）对象1var y = new String('hello'); 属性: length prototype constructor 方法: charAt() charCodeAt() concat() fromCharCode() indexOf() lastIndexOf() match() replace() search() slice() split() substr() substring() toLowerCase() toUpperCase() valueOf() Date（日期）对象 创建日期 1234new Date() // 当前日期和时间 new Date(milliseconds) //返回从 1970 年 1 月 1 日至今的毫秒数 new Date(dateString) new Date(year, month, day, hours, minutes, seconds, milliseconds) 设置日期 12var myDate=new Date(); myDate.setFullYear(2010,0,14); 两个日期比较 123456789var x=new Date(); x.setFullYear(2100,0,4); var today = new Date(); if (x&gt;today)&#123; alert("Today is before 14th January 2100"); &#125; else&#123; alert("Today is after 14th January 2100"); &#125; Date 对象属性 属性 描述 constructor 返回对创建此对象的 Date 函数的引用。 prototype 使您有能力向对象添加属性和方法。 Date 对象方法 方法 描述 getDate() 从 Date 对象返回一个月中的某一天 (1 ~ 31)。 getDay() 从 Date 对象返回一周中的某一天 (0 ~ 6)。 getFullYear() 从 Date 对象以四位数字返回年份。 getHours() 返回 Date 对象的小时 (0 ~ 23)。 getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)。 getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。 getMonth() 从 Date 对象返回月份 (0 ~ 11)。 getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。 getTime() 返回 1970 年 1 月 1 日至今的毫秒数。 getTimezoneOffset() 返回本地时间与格林威治标准时间 (GMT) 的分钟差。 getUTCDate() 根据世界时从 Date 对象返回月中的一天 (1 ~ 31)。 getUTCDay() 根据世界时从 Date 对象返回周中的一天 (0 ~ 6)。 getUTCFullYear() 根据世界时从 Date 对象返回四位数的年份。 getUTCHours() 根据世界时返回 Date 对象的小时 (0 ~ 23)。 getUTCMilliseconds() 根据世界时返回 Date 对象的毫秒(0 ~ 999)。 getUTCMinutes() 根据世界时返回 Date 对象的分钟 (0 ~ 59)。 getUTCMonth() 根据世界时从 Date 对象返回月份 (0 ~ 11)。 getUTCSeconds() 根据世界时返回 Date 对象的秒钟 (0 ~ 59)。 getYear() 已废弃。 请使用 getFullYear() 方法代替。 parse() 返回1970年1月1日午夜到指定日期（字符串）的毫秒数。 setDate() 设置 Date 对象中月的某一天 (1 ~ 31)。 setFullYear() 设置 Date 对象中的年份（四位数字）。 setHours() 设置 Date 对象中的小时 (0 ~ 23)。 setMilliseconds() 设置 Date 对象中的毫秒 (0 ~ 999)。 setMinutes() 设置 Date 对象中的分钟 (0 ~ 59)。 setMonth() 设置 Date 对象中月份 (0 ~ 11)。 setSeconds() 设置 Date 对象中的秒钟 (0 ~ 59)。 setTime() setTime() 方法以毫秒设置 Date 对象。 setUTCDate() 根据世界时设置 Date 对象中月份的一天 (1 ~ 31)。 setUTCFullYear() 根据世界时设置 Date 对象中的年份（四位数字）。 setUTCHours() 根据世界时设置 Date 对象中的小时 (0 ~ 23)。 setUTCMilliseconds() 根据世界时设置 Date 对象中的毫秒 (0 ~ 999)。 setUTCMinutes() 根据世界时设置 Date 对象中的分钟 (0 ~ 59)。 setUTCMonth() 根据世界时设置 Date 对象中的月份 (0 ~ 11)。 setUTCSeconds() setUTCSeconds() 方法用于根据世界时 (UTC) 设置指定时间的秒字段。 setYear() 已废弃。请使用 setFullYear() 方法代替。 toDateString() 把 Date 对象的日期部分转换为字符串。 toGMTString() 已废弃。请使用 toUTCString() 方法代替。 toISOString() 使用 ISO 标准返回字符串的日期格式。 toJSON() 以 JSON 数据格式返回日期字符串。 toLocaleDateString() 根据本地时间格式，把 Date 对象的日期部分转换为字符串。 toLocaleTimeString() 根据本地时间格式，把 Date 对象的时间部分转换为字符串。 toLocaleString() 据本地时间格式，把 Date 对象转换为字符串。 toString() 把 Date 对象转换为字符串。 toTimeString() 把 Date 对象的时间部分转换为字符串。 toUTCString() 根据世界时，把 Date 对象转换为字符串。 UTC() 根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。 valueOf() 返回 Date 对象的原始值。 Array（数组）对象1var cars = ["Saab", "Volvo", "BMW"]; 属性 属性 描述 constructor 返回创建数组对象的原型函数。 length 设置或返回数组元素的个数。 prototype 允许你向数组对象添加属性或方法。 方法 方法 描述 concat() 连接两个或更多的数组，并返回结果。 copyWithin(). 从数组的指定位置拷贝元素到数组的另一个指定位置中。 entries(). 返回数组的可迭代对象。 every() 检测数组元素的每个元素是否都符合条件。 fill(). 使用一个固定值来填充数组。 filter() 检测数组元素，并返回符合条件所有元素的数组。 find(). 返回符合传入测试（函数）条件的数组元素。 findIndex(). 返回符合传入测试（函数）条件的数组元素索引。 forEach(). 数组每个元素都执行一次回调函数。 from(). 通过给定的对象中创建一个数组。 indexOf() 搜索数组中的元素，并返回它所在的位置。 join() 把数组的所有元素放入一个字符串。 lastIndexOf() 返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。 map() 通过指定函数处理数组的每个元素，并返回处理后的数组。 pop() 删除数组的最后一个元素并返回删除的元素。 push() 向数组的末尾添加一个或更多元素，并返回新的长度。 reverse() 反转数组的元素顺序。 shift() 删除数组的第一个元素。 slice() 选取数组的的一部分，并返回一个新数组。 some() 检测数组元素中是否有元素符合指定条件。 sort() 对数组的元素进行排序。 splice() 从数组中添加或删除元素。 toString() 把数组转换为字符串，并返回结果。 unshift() 向数组的开头添加一个或更多元素，并返回新的长度。 valueOf() 返回数组对象的原始值。 Boolean（布尔）对象1var myBoolean=new Boolean(); Boolean 对象属性 属性 描述 constructor 返回对创建此对象的 Boolean 函数的引用 prototype 使您有能力向对象添加属性和方法。 Boolean 对象方法 方法 描述 toString() 把布尔值转换为字符串，并返回结果。 valueOf() 返回 Boolean 对象的原始值。 Math（算数）对象12var x=Math.PI;var y=Math.sqrt(16); Math 对象属性 属性 描述 E 返回算术常量 e，即自然对数的底数（约等于2.718）。 LN2 返回 2 的自然对数（约等于0.693）。 LN10 返回 10 的自然对数（约等于2.302）。 LOG2E 返回以 2 为底的 e 的对数（约等于 1.414）。 LOG10E 返回以 10 为底的 e 的对数（约等于0.434）。 PI 返回圆周率（约等于3.14159）。 SQRT1_2 返回返回 2 的平方根的倒数（约等于 0.707）。 SQRT2 返回 2 的平方根（约等于 1.414）。 Math 对象方法 方法 描述 abs(x) 返回 x 的绝对值。 acos(x) 返回 x 的反余弦值。 asin(x) 返回 x 的反正弦值。 atan(x) 以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值。 atan2(y,x) 返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间）。 ceil(x) 对数进行上舍入。 cos(x) 返回数的余弦。 exp(x) 返回 Ex 的指数。 floor(x) 对 x 进行下舍入。 log(x) 返回数的自然对数（底为e）。 max(x,y,z,…,n) 返回 x,y,z,…,n 中的最高值。 min(x,y,z,…,n) 返回 x,y,z,…,n中的最低值。 pow(x,y) 返回 x 的 y 次幂。 random() 返回 0 ~ 1 之间的随机数。 round(x) 把数四舍五入为最接近的整数。 sin(x) 返回数的正弦。 sqrt(x) 返回数的平方根。 tan(x) 返回角的正切。 Window对象Window 对象表示一个浏览器窗口或一个框架。在客户端 JavaScript 中，Window 对象是全局对象，所有的表达式都在当前的环境中计算。 JavaScript document 对象 JavaScript frames 对象 JavaScript history 对象 JavaScript location 对象 JavaScript navigator 对象 JavaScript screen 对象 JavaScript 是面向对象的语言，但 JavaScript 不使用类。 More info: JavaScript教程]]></content>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript（一）JavaScript的基本知识(上)]]></title>
    <url>%2F2016%2F10%2F15%2FJavaScript01%2F</url>
    <content type="text"><![CDATA[JavaScript 是世界上最流行的脚本语言， 是属于 HTML 和 Web 的编程语言。 本文章主要介绍 JavaScript 的基本语法。 Quick GuideJavaScript 是 web 开发者必学的三种语言之一： HTML 定义网页的内容 CSS 规定网页的布局 JavaScript 对网页行为进行编程 一、用途 JavaScript 能够改变 HTML 内容 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h2&gt;JavaScript 能做什么&lt;/h2&gt;&lt;p id="demo"&gt;JavaScript 能够改变 HTML 内容。&lt;/p&gt;&lt;button type="button" onclick='document.getElementById("demo").innerHTML = "Hello JavaScript!"'&gt;点击我！&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; JavaScript 能够改变 HTML 属性 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h2&gt;JavaScript 能做什么？&lt;/h2&gt;&lt;p&gt;JavaScript 能够改变 HTML 属性值。&lt;/p&gt;&lt;p&gt;在本例中，JavaScript 改变了图像的 src 属性值。&lt;/p&gt;&lt;button onclick="document.getElementById('myImage').src='/i/eg_bulbon.gif'"&gt;开灯&lt;/button&gt;&lt;img id="myImage" border="0" src="/i/eg_bulboff.gif" style="text-align:center;"&gt;&lt;button onclick="document.getElementById('myImage').src='/i/eg_bulboff.gif'"&gt;关灯&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; JavaScript 能够改变 HTML 样式 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h2&gt;JavaScript 能够做什么&lt;/h2&gt;&lt;p id="demo"&gt;JavaScript 能够改变 HTML 元素的样式。&lt;/p&gt;&lt;button type="button" onclick="document.getElementById('demo').style.fontSize='35px'"&gt;点击我！&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; JavaScript 能够隐藏 HTML 元素 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h2&gt;JavaScript 能够做什么&lt;/h2&gt;&lt;p id="demo"&gt;JavaScript 能够隐藏 HTML 元素。&lt;/p&gt;&lt;button type="button" onclick="document.getElementById('demo').style.display='none'"&gt;点击我！&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; JavaScript 能够显示 HTML 元素 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h2&gt;JavaScript 能够做什么&lt;/h2&gt;&lt;p&gt;JavaScript 能够显示隐藏的 HTML 元素。&lt;/p&gt;&lt;p id="demo" style="display:none"&gt;Hello JavaScript!&lt;/p&gt;&lt;button type="button" onclick="document.getElementById('demo').style.display='block'"&gt;点击我！&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 二、使用在 HTML 中， 脚本可被放置与 HTML 页面的 &lt;body&gt; 或 &lt;head&gt; 部分中 &lt;script&gt; 与 &lt;/script&gt; 标签之间。 内部引用123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script&gt;function myFunction() &#123; document.getElementById("demo").innerHTML = "段落被更改。";&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;一张网页&lt;/h1&gt;&lt;p id="demo"&gt;一个段落&lt;/p&gt;&lt;button type="button" onclick="myFunction()"&gt;试一试&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 外部引用 分离了 HTML 和代码 使 HTML 和 JavaScript 更易于阅读和维护 已缓存的 JavaScript 文件可加速页面加载 1234// 外部myScript.jsfunction myFunction() &#123; document.getElementById("demo").innerHTML = "段落被更改。";&#125; 1&lt;script type="text/javascript" src="myScript.js"&gt;&lt;/script&gt; 三、基本语法3.1.输出 使用 window.alert() 写入警告框 使用 document.write() 写入 HTML 输出 使用 innerHTML 写入 HTML 元素 使用 console.log() 写入浏览器控制台 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;我的第一张网页&lt;/h1&gt;&lt;p&gt;我的第一个段落&lt;/p&gt;&lt;p id="demo"&gt;&lt;/p&gt;&lt;script&gt; document.getElementById("demo").innerHTML = 5 + 6;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;我的第一张网页&lt;/h1&gt;&lt;p&gt;我的第一个段落&lt;/p&gt;&lt;p id="demo"&gt;&lt;/p&gt;&lt;script&gt; document.getElementById("demo").innerHTML = 5 + 6;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;我的第一张网页&lt;/h1&gt;&lt;p&gt;我的第一个段落&lt;/p&gt;&lt;script&gt;window.alert(5 + 6);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;我的第一张网页&lt;/h1&gt;&lt;p&gt;我的第一个段落&lt;/p&gt;&lt;!-- 在 debugger 中选择 "Console"。然后再次点击运行按钮。 --&gt;&lt;script&gt;console.log(5 + 6);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.2.语句由 值、运算符、表达式、关键词和注释构成。 关键词：代码内部用于标识被执行的动作 值：字面量（具体的数据）和变量值（存储字面量的名称） 运算符：如算数运算符（+ - * /） 表达式：变量和运算符的组合，计算结果是值 注释：代码描述说明 123var x, y; // 如何声明变量x = 7; y = 8; // 如何赋值z = x + y; // 如何计算值 关键词指的是保留的单词。保留词无法用作变量名。 关键词 描述 break 终止 switch 或循环。 continue 跳出循环并在顶端开始。 debugger 停止执行 JavaScript，并调用调试函数（如果可用）。 do … while 执行语句块，并在条件为真时重复代码块。 for 标记需被执行的语句块，只要条件为真。 function 声明函数。 if … else 标记需被执行的语句块，根据某个条件。 return 退出函数。 switch 标记需被执行的语句块，根据不同的情况。 try … catch 对语句块实现错误处理。 var 声明变量。 注意: 1.使用分号分隔语句 2.增加适当空格(符号之间或者代码块的缩进)提高可读性 3.代码行控制在 80 个字符以内 4.使用花括号包围代码块 5.双斜杠 // 或 / 与 / 之间的代码被视为注释 3.3.标识符标识符:有 变量 和 关键词。下面是命名规则： 名称可包含字母、数字、下划线和美元符号 名称必须以字母开头 名称也可以 $ 和 _ 开头（一般不会这么做） 名称对大小写敏感（y 和 Y 是不同的变量） 保留字（比如 JavaScript 的关键词）无法用作变量名称 3.4.变量存储数据值的容器，变量必须以唯一的名称的标识。 12345678910// 声明未定义,值为undefinedvar carName;// 声明且定义var carName = "porsche";var person = "Bill Gates", carName = "porsche", price = 15000;// 重复声明 var carName = "porsche";var carName; 3.5.数据类型变量可用作不同类型 数据类型 字符串值 数值 布尔值 不包含任何值 undefined null function 对象类型 object Date Array 字符串值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 字符串var answer = "It's alright"; // 双引号内的单引号var answer = "He is called 'Bill'"; // 双引号内的单引号var answer = 'He is called "Bill"'; // 单引号内的双引号var x = "中国是瓷器的故乡，因此 china 与\"China（中国）\"同名。" // 转义字符\var firstName = new String("Bill") // 字符串对象// 字符串的长度var sln = answer.length; // 返回字符串中指定文本首次出现的索引var str = "The full name of China is the People's Republic of China.";var pos = str.indexOf("China"); var pos = str.indexOf("China", 18); // 18是起始位var pos = str.search("locate"); // 支持正则// 返回指定文本在字符串中最后一次出现的索引var pos = str.lastIndexOf("China");var pos = str.lastIndexOf("China", 15); // 15是起始位// 截取字符串var str = "Apple, Banana, Mango";var res = str.slice(7,13);var res = str.slice(-13,-7);var res = str.slice(7);var res = str.substring(7,13); // 无法接受负的索引var res = str.substr(7,6); // 第二个参数规定被提取部分的长度// 提取字符串字符var str = "HELLO WORLD";str.charAt(0); // 返回 Hstr.charCodeAt(0); // 返回 unicode 编码 72// 替换字符串,只替换首个匹配var n1 = str.replace("Banana", "W3School");var n2 = str.replace(/BANANA/i, "W3School"); //大小写不敏感的替换,正则不需要双引号// 转换为大写和小写var text2 = n1.toUpperCase(); // BANANAvar text2 = n1.toLowerCase(); // banana//连接两个或多个字符串var text = "Hello" + " " + "World!";var text = "Hello".concat(" ","World!");// 删除字符串两端的空白符var str = " Hello World! ";alert(str.trim());// 属性访问var str = "HELLO WORLD";str[0]; // 返回 H// 把字符串转换为数组var txt = "a,b,c,d,e"; // 字符串txt.split(","); // 用逗号分隔 数值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// 数值:64 位的浮点数 var x1 = 34.00; // 带小数点var x2 = 34; // 不带小数点var y = 123e5; // 12300000var z = 123e-5; // 0.00123// 整数（不使用指数或科学计数法）会被精确到 15 位 var x = 999999999999999; // x 将是 999999999999999var y = 9999999999999999; // y 将是 10000000000000000// 小数的最大数是 17 位，但是浮点的算数并不总是 100% 精准var x = 0.2 + 0.1; // x 将是 0.30000000000000004// 把要给数值放入引号中，其余数值会被视作字符串并被级联。var x = "Bill" + " " + "Gates";var x = "8" + 3 + 5;// 数字运算中（加法除外），将字符串转换为数字var x = "100";var y = "10";var z = x / y; // z 将是 10// NaN 属于 JavaScript 保留词，指示某个数不是合法数。var x = 100 / "Apple"; // x 将是 NaN（Not a Number）isNaN(x); // 返回 true，因为 x 不是数var y = "5";var z = x + y; // z 将是 NaN5typeof NaN; // 返回 "number"// Infinity （或 -Infinity）是 JavaScript 在计算数时超出最大可能数范围时返回的值。var x = 2 / 0; // x 将是 Infinityvar y = -2 / 0; // y 将是 -Infinitytypeof Infinity; // 返回 "number"// 前缀为 0x 的数值常量解释为十六进制var x = 0xFF; // x 将是 255// 数字对象var a = new Number(123); // typeof a 返回 objectvar x = 500; var y = new Number(500); // (x == y) 为 true,因为 x 和 y 有相等的值(x === y) 为 false,类型不同var z = new Number(500); // (y == z) 为 false,因为对象不可以比较// 转换为字符串var myNumber = 128;myNumber.toString(16); // 返回 80myNumber.toString(8); // 返回 200myNumber.toString(2); // 返回 10000000// 返回字符串值，它包含已被四舍五入并使用指数计数法的数字。var x = 9.656;x.toExponential(2); // 返回 9.66e+0x.toExponential(4); // 返回 9.6560e+0x.toExponential(6); // 返回 9.656000e+0// 返回字符串值，它包含了指定位数小数的数字var x = 9.656;x.toFixed(0); // 返回 10x.toFixed(2); // 返回 9.66x.toFixed(4); // 返回 9.6560x.toFixed(6); // 返回 9.656000// 返回字符串值，它包含了指定长度的数字：var x = 9.656;x.toPrecision(); // 返回 9.656x.toPrecision(2); // 返回 9.7x.toPrecision(4); // 返回 9.656x.toPrecision(6); // 返回 9.65600// 返回对象的原始值var a = new Number(123);a.valueOf(); // 从表达式 100 + 23 返回 123// 转换为数字Number("10"); // 返回 10x = Number("10 20"); // 返回 NaNNumber(new Date("2019-04-15")); // 返回 1506729600000// 解析一段字符串并返回数值。允许空格。只返回首个数字：parseInt("10 years"); // 返回 10parseInt("years 10"); // 返回 NaNparseFloat("10.33"); // 返回 10.33parseFloat("10 years"); // 返回 10parseFloat("10 20 30"); // 返回 10// 数值属性MAX_VALUE // 返回 JavaScript 中可能的最大数。MIN_VALUE // 返回 JavaScript 中可能的最小数。NEGATIVE_INFINITY // 表示负的无穷大（溢出返回）。NaN // 表示非数字值（"Not-a-Number"）。POSITIVE_INFINITY // 表示无穷大（溢出返回）。var x = Number.MAX_VALUE; // 数字属性不可用于变量 布尔值123// 布尔值var x = true;var y = false; undefined123456789// 空var person; // 值是 undefined，类型是 undefinedperson = undefined; // 值是 undefined，类型是 undefinedvar car = ""; // 值是 ""，类型是 "string"var person = null; // 值是 null，但是类型仍然是对象typeof undefined // undefinedtypeof null // objectnull === undefined // falsenull == undefined // true 等值不等型 对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144// 数组:一种特殊类型的对象,使用数字索引var array_name = [item1, item2, ...];var cars = new Array("Saab", "Volvo", "BMW");var cars = ["Porsche", "Volvo", "BMW"]; // 请不要最后一个元素之后写逗号（比如 "BMW",）。var name = cars[0]; // Porsche 通过引用索引号（下标号）来引用某个数组元素cars[0] = "Opel"; // 改变数组元素cars.length; // 返回数组的长度（数组元素的数目）var fruits = ["Banana", "Orange", "Apple", "Mango"];fruits.push("Lemon"); // 向 fruits 添加一个新元素 (Lemon),x 的值是 5(返回新数组的长度)fruits[fruits.length] = "Lemon"; // 向 fruits 添加一个新元素 (Lemon)var x = fruits.pop(); // fruits 删除最后一个元素（"Mango"）,x 的值是 "Mango"var x = fruits.shift(); // 从 fruits 删除第一个元素 "Banana",x 的值是 "Bananadelete fruits[0]; // 把 fruits 中的首个元素改为 undefinedfruits.unshift("Lemon"); // 向 fruits 添加新元素 "Lemon", 返回新数组的长度var removed = fruits.splice(2, 2, "Lemon", "Kiwi"); // 从位置 2 开始删除 2 个元素 添加新元素 "Lemon,Kiwi", 返回删除元素// 数组转换字符串document.getElementById("demo").innerHTML = fruits.toString(); // Banana,Orange,Apple,Mangodocument.getElementById("demo").innerHTML = fruits.join(" * "); // Banana * Orange * Apple * Mangovar myGirls = ["Emma", "Isabella"];var myBoys = ["Jacob", "Michael", "Ethan"];var myChildren = myGirls.concat(myBoys); // Emma,Isabella,Jacob,Michael,Ethanvar arr1 = ["Cecilie", "Lone"];var arr2 = ["Emil", "Tobias", "Linus"];var arr3 = ["Robin", "Morgan"];var myChildren = arr1.concat(arr2, arr3); // 将arr1、arr2 与 arr3 连接在一起// 切片新数组var fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"];var citrus = fruits.slice(3); // Apple,Mangovar citrus = fruits.slice(1, 3); // Orange,Lemon// 最大值var arr = [1,2,3]Math.max(1, 2, 3) // 不允许直接放入数组Math.max.apply(null, arr)Math.min(1, 2, 3) Math.min.apply(null, arr)// 遍历数组for (i = 0; i &lt; cars.length; i++) &#123; text += "&lt;li&gt;" + cars[i] + "&lt;/li&gt;";&#125; text1 = "&lt;ul&gt;";text2 = "&lt;ul&gt;";text3 = "&lt;ul&gt;";fruits.forEach(myFunction);function myFunction(value, index, array) &#123; text1 += "&lt;li&gt;" + value + "&lt;/li&gt;"; // 项目值 text2 += "&lt;li&gt;" + index + "&lt;/li&gt;"; // 项目索引 text3 += "&lt;li&gt;" + array + "&lt;/li&gt;"; // 数组本身&#125;// 以字母顺序对数组进行排序：fruits.sort(); // 对 fruits 中的元素进行排序fruits.reverse(); // 反转元素顺序var points = [40, 100, 1, 5, 25, 10];points.sort(function(a, b)&#123;return a - b&#125;); // 数字也会当作字符串比较,需要用比值函数points.sort(function(a, b)&#123;return 0.5 - Math.random()&#125;); // 随机顺序排序数组var numbers = [45, 4, 9, 16, 25];// 对每个数组元素执行函数来创建新数组var numbers2 = numbers.map(myFunction);function myFunction(value, index, array) &#123; return value * 2;&#125;// 过滤,创建一个包含通过测试的数组元素的新数组var over18 = numbers.filter(myFunction);function myFunction(value, index, array) &#123; return value &gt; 18;&#125;// 检查所有数组值是否通过测试var allOver18 = numbers.every(myFunction); // Truefunction myFunction(value, index, array) &#123; return value &gt; 18;&#125;// 检查所有数组值是否通过测试var allOver18 = numbers.every(myFunction); // Truefunction myFunction(value, index, array) &#123; return value &gt; 18;&#125;// 检查数组值是否有通过测试var allOver18 = numbers.some(myFunction); // Truefunction myFunction(value, index, array) &#123; return value &gt; 18;&#125;// 返回通过测试函数的第一个数组元素的值var first = numbers.find(myFunction);function myFunction(value, index, array) &#123; return value &gt; 18;&#125;// 返回通过测试函数的第一个数组元素的索引var first = numbers.findIndex(myFunction);function myFunction(value, index, array) &#123; return value &gt; 18;&#125;// 在数组中搜索元素值并返回其位置var a = points.indexOf(100,0) // a为1,第二个参数可选 是起始位,搜索到结尾var a = fruits.lastIndexOf(100); // a为1,第二个参数可选 是起始位,搜索到开头// 递归var sum = numbers.reduce(myFunction,100); // 100为初始值,可选填var sum = numbers1.reduceRight(myFunction); // 在数组中从右到左工作function myFunction(total, value, index, array) &#123; return total + value; // total:总数（初始值/先前返回的值）&#125;// 判断是否数组Array.isArray(fruits); // 返回 truefunction isArray(x) &#123; return x.constructor.toString().indexOf("Array") &gt; -1;&#125; // 自定义fruits instanceof Array // 返回 true// 日期,格式Thu Dec 03 2020 20:32:48 GMT+0800 (中国标准时间)var d = new Date(); var d = new Date(year, month, day, hours, minutes, seconds, milliseconds)var d = new Date(2018, 11); // year monthvar d = new Date(99, 11, 24); // 一位和两位数年份将被解释为 19xx 年var d = new Date(2018, 11, 24); // year month dayvar d = new Date(2018, 11, 24, 10); // year month day hoursvar d = new Date("October 13, 2014 11:13:00");new Date(milliseconds);new Date(date string);// 对象使用命名索引var person = &#123;firstName:"Bill", lastName:"Gates", age:62, eyeColor:"blue"&#125;;typeof &#123;name:'Bill', age:62&#125; // 返回 "object"typeof [1,2,3,4] // 返回 "object" (数组也是对象)typeof null // 返回 "object"typeof function myFunc()&#123;&#125; // 返回 "function"// 访问对象属性objectName.propertyNameobjectName["propertyName"]// 访问对象方法objectName.methodName()name = person.fullName; // 不使用 () 访问 fullName 方法，则将返回函数定义： 代码 结果 \b 退格键 \f 换页 \n 新行 \r 回车 \t 水平制表符 \v 垂直制表符 获取类型 typeof 使用 typeof 操作符来查看 JavaScript 变量的数据类型。 NaN 的数据类型是 number 数组(Array)的数据类型是 object 日期(Date)的数据类型为 object null 的数据类型是 object 未定义变量的数据类型为 undefined 12345678910typeof "John" // 返回 stringtypeof 3.14 // 返回 numbertypeof NaN // 返回 numbertypeof false // 返回 booleantypeof [ 1,2,3,4] // 返回 objecttypeof &#123;name: 'John', age:34&#125; // 返回 objecttypeof new Date() // 返回 objecttypeof function () &#123;&#125; // 返回 functiontypeof myCar // 返回 undefined (如果 myCar没有被实例化的话)typeof null // 返回 object 如果对象是 JavaScript Array 或 JavaScript Date ，我们就无法通过 typeof 来判断他们的类型，因为都是 返回 Object。 constructor constructor 属性返回所有 JavaScript 变量的构造函数。 1234567"John".constructor // 返回函数 String() &#123; [native code] &#125;(3.14).constructor // 返回函数 Number() &#123; [native code] &#125;false.constructor // 返回函数 Boolean() &#123; [native code] &#125;[1,2, 3,4].constructor // 返回函数 Array() &#123; [native code] &#125;&#123;name:'John', age:34&#125;.constructor // 返回函数 Object() &#123; [native code] &#125;new Date().constructor // 返回函数 Date() &#123; [native code] &#125;function() &#123;&#125;.constructor // 返回函数 Function()&#123; [native code] &#125; 类型转换JavaScript 变量可以转换为新变量或其他数据类型： 通过使用 JavaScript 函数 通过 JavaScript 自身自动转换 转换为字符串123456789101112131415161718// 将数字转换为字符串String(x) // 将变量 x 转换为字符串并返回String(123) // 将数字 123 转换为字符串并返回String( 100+ 23) // 将数字表达式转换为字符串并返回x.toString()(123).toString()(100 + 23).toString()// 将布尔值转换为字符串String(false) // 返回 "false"String(true) // 返回 "true"false.toString() // 返回 "false"true.toString() // 返回 "true"// 将日期转换为字符串String(Date()) // 返回 Thu Jul 17 2014 15:38:19 GMT+0200 (W. Europe Daylight Time)Date().toString() // 返回 Thu Jul 17 2014 15:38:19 GMT+0200 (W. Europe Daylight Time) 转换为数字12345678910111213141516171819202122//将字符串转换为数字Number("3.14") // 返回 3.14Number(" ") // 返回 0Number("") // 返回 0Number("99 88") // 返回 NaN// 一元运算符 +var y = "5"; // y 是一个字符串var x = + y; // x 是一个数字var y = "John"; // y 是一个字符串var x = + y; // x 是一个数字 (NaN)//将布尔值转换为数字Number(false) // 返回 0Number(true) // 返回 1//将日期转换为数字d = new Date();Number(d) // 返回 1404568027739d = new Date();d.getTime() // 返回 1404568027739 自动转换类型当 JavaScript 尝试操作一个 “错误” 的数据类型时，会自动转换为 “正确” 的数据类型。 1234567891011121314151617185 + null // 返回 5 because null is converted to 0"5" + null // 返回"5null" because null is converted to "null""5" + 1 // 返回 "51" because 1 is converted to "1" "5" - 1 // 返回 4 because "5" is converted to 5document.getElementById("demo").innerHTML = myVar;// if myVar = &#123;name:"Fjohn"&#125; // toString 转换为 "[object Object]"// if myVar = [1,2,3,4] // toString 转换为 "1,2,3,4"// if myVar = new Date() // toString 转换为 "Fri Jul 18 2014 09:08:55 GMT+0200"// if myVar = 123 // toString 转换为 "123"// if myVar = true // toString 转换为 "true"// if myVar = false // toString 转换为 "false"var person = null; // 值为 null(空), 但类型为对象var person; // 值为 undefined(空), 类型是undefined 3.6.运算符 算数运算 赋值运算 比较运算符 逻辑运算符 类型运算符 位运算符 运算符优先级值 算数运算算数运算符用于对数字执行算数运算： 运算符 描述 + 加法 - 减法 * 乘法 / 除法 % 系数 ++ 递加 – 递减 赋值运算赋值运算符向 JavaScript 变量赋值。 运算符 例子 等同于 = x = y x = y += x += y x = x + y -= x -= y x = x - y *= x *= y x = x * y /= x /= y x = x / y %= x %= y x = x % y 比较预算符 运算符 描述 == 等于 === 等值等型 != 不相等 !== 不等值或不等型 &gt; 大于 &lt; 小于 &gt;= 大于或等于 &lt;= 小于或等于 ? 三元运算符 逻辑运算符 运算符 描述 &amp;&amp; 逻辑与 \ \ 逻辑或 ! 逻辑非 类型运算符 运算符 描述 typeof 返回变量的类型。 instanceof 返回 true，如果对象是对象类型的实例。 位运算符 运算符 描述 例子 等同于 结果 十进制 &amp; 与 5 &amp; 1 0101 &amp; 0001 0001 1 \ 或 5 \ 1 0101 \ 0001 0101 5 ~ 非 ~ 5 ~0101 1010 10 ^ 异或 5 ^ 1 0101 ^ 0001 0100 4 &lt;&lt; 零填充左位移 5 &lt;&lt; 1 0101 &lt;&lt; 1 1010 10 &gt;&gt; 有符号右位移 5 &gt;&gt; 1 0101 &gt;&gt; 1 0010 2 &gt;&gt;&gt; 零填充右位移 5 &gt;&gt;&gt; 1 0101 &gt;&gt;&gt; 1 0010 2 运算符优先级值 值 运算符 描述 实例 20 ( ) 表达式分组 (3 + 4) 19 . 成员 person.name 19 [] 成员 person[“name”] 19 () 函数调用 myFunction() 19 new 创建 new Date() 17 ++ 后缀递增 i++ 17 – 后缀递减 i– 16 ++ 前缀递增 ++i 16 – 前缀递减 –i 16 ! 逻辑否 !(x==y) 16 typeof 类型 typeof x 15 ** 求幂 (ES7) 10 ** 2 14 * 乘 10 * 5 14 / 除 10 / 5 14 % 模数除法 10 % 5 13 + 加 10 + 5 13 - 减 10 - 5 12 &lt;&lt; 左位移 x &lt;&lt; 2 12 &gt;&gt; 右位移 x &gt;&gt; 2 12 &gt;&gt;&gt; 右位移（无符号） x &gt;&gt;&gt; 2 11 &lt; 小于 x &lt; y 11 &lt;= 小于或等于 x &lt;= y 11 &gt; 大于 x &gt; y 11 &gt;= 大于或等于 x &gt;= y 11 in 对象中的属性 “PI” in Math 11 instanceof 对象的实例 instanceof Array 10 == 相等 x == y 10 === 严格相等 x === y 10 != 不相等 x != y 10 !== 严格不相等 x !== y 9 &amp; 按位与 x &amp; y 8 ^ 按位 XOR x ^ y 7 \ 按位或 x \ y 6 &amp;&amp; 逻辑与 x &amp;&amp; y 5 \ \ 逻辑否 x \ \ y 4 ? : 条件 ? “Yes” : “No” 3 = 赋值 x = y 3 += 赋值 x += y 3 -= 赋值 x -= y 3 *= 赋值 x *= y 3 %= 赋值 x %= y 3 &lt;&lt;= 赋值 x &lt;&lt;= y 3 &gt;&gt;= 赋值 x &gt;&gt;= y 3 &gt;&gt;&gt;= 赋值 x &gt;&gt;&gt;= y 3 &amp;= 赋值 x &amp;= y 3 ^= 赋值 x ^= y 3 \ = 赋值 x \ = y 2 yield 暂停函数 yield x 1 , 逗号 7 , 8 提示：括号中的表达式会在值在表达式的其余部分中被使用之前进行完全计算。 3.7.保留关键字保留关键字在意思上表达成为将来的关键字而保留的单词。 JavaScript 保留关键字 abstract arguments boolean break byte case catch char class* const continue debugger default delete do double else enum* eval export* extends* false final finally float for function goto if implements import* in instanceof int interface let long native new null package private protected public return short static super* switch synchronized this throw throws transient true try typeof var void volatile while with yield * 标记的关键字是 ECMAScript5 中新添加的。 JavaScript 对象、属性和方法 Array Date eval function hasOwnProperty Infinity isFinite isNaN isPrototypeOf length Math NaN name Number Object prototype String toString undefined valueOf Java 保留关键字JavaScript 经常与 Java 一起使用。您应该避免使用一些 Java 对象和属性作为 JavaScript 标识符： getClass java JavaArray javaClass JavaObject JavaPackage Windows 保留关键字 alert all anchor anchors area assign blur button checkbox clearInterval clearTimeout clientInformation close closed confirm constructor crypto decodeURI decodeURIComponent defaultStatus document element elements embed embeds encodeURI encodeURIComponent escape event fileUpload focus form forms frame innerHeight innerWidth layer layers link location mimeTypes navigate navigator frames frameRate hidden history image images offscreenBuffering open opener option outerHeight outerWidth packages pageXOffset pageYOffset parent parseFloat parseInt password pkcs11 plugin prompt propertyIsEnum radio reset screenX screenY scroll secure select self setInterval setTimeout status submit taint text textarea top unescape untaint window HTML 事件句柄 onblur onclick onerror onfocus onkeydown onkeypress onkeyup onmouseover onload onmouseup onmousedown onsubmit 注意：在JavaScript中关键字不能用作变量名或者函数名，否则可能会得到错误消息，例如“”Identifier Expected”（应该有标识符、期望标识符）”。 四、流程4.1.条件通常在写代码时，您总是需要为不同的决定来执行不同的动作。您可以在代码中使用条件语句来完成该任务。 if 语句 - 只有当指定条件为 true 时，使用该语句来执行代码 if…else 语句 - 当条件为 true 时执行代码，当条件为 false 时执行其他代码 JavaScript三目运算 - 当条件为true 时执行代码，当条件为 false 时执行其他代码 if…else if….else 语句- 使用该语句来选择多个代码块之一来执行 switch 语句 - 使用该语句来选择多个代码块之一来执行 if只有当指定条件为 true 时，该语句才会执行代码。 语法 123456789101112131415161718192021if (condition)&#123; 当条件为 true 时执行的代码 &#125;if (condition) &#123; 当条件为 true 时执行的代码 &#125;else&#123; 当条件不为 true 时执行的代码 &#125;if (condition1)&#123; 当条件 1 为 true 时执行的代码 &#125;else if (condition2)&#123; 当条件 2 为 true 时执行的代码 &#125; else&#123; 当条件 1 和 条件 2 都不为 true 时执行的代码 &#125; 例子 12345678if (time&lt;20)&#123; x="Good day";&#125;else&#123; x="Good evening";&#125;5 &gt; 3 ? alert("5大于3") : alert("5小于3"); switchswitch 语句用于在不同的条件执行不同的动作。搭配case和default使用（default可以认为是一个特殊的case，case对应一种或多种（default）情况，Switch语句没有case是没有办法体现其功能的）。 语法 计算一次 switch 表达式 把表达式的值与每个case的值进行对比 如果存在匹配，则执行关联代码12345678910switch(n)&#123; case 1: 执行代码块 1 break; case 2: 执行代码块 2 break; default: n 与 case 1 和 case 2 不同时执行的代码&#125; 例子 123456789101112131415161718192021var x = "0";switch (x) &#123; case 0: text = "Off"; break; case 1: text = "On"; break; default: text = "No value found";&#125; 4.2.循环循环可以将代码块执行指定的次数。 for - 循环代码块一定的次数 for/in - 循环遍历对象的属性 while - 当指定的条件为 true 时循环指定的代码块 do/while - 同样当指定的条件为 true 时循环指定的代码块 for 语法 语句 1 （代码块）开始前执行 starts. 语句 2 定义运行循环（代码块）的条件 语句 3 在循环（代码块）已被执行之后执行 123for (语句 1; 语句 2; 语句 3)&#123; 被执行的代码块 &#125; 例子 Statement 1 在循环开始之前设置变量 (var i=0)。 Statement 2 定义循环运行的条件（i 必须小于 5）。 Statement 3 在每次代码块已被执行后增加一个值 (i++) 123456789for (var i=0; i&lt;5; i++)&#123; x=x + "The number is " + i + "&lt;br&gt;";&#125;var i=0,len=cars.length;for (; i&lt;len; )&#123; document.write(cars[i] + "&lt;br&gt;"); i++;&#125; whilewhile 循环会在指定条件为真时循环执行代码块。 语法 1234567while (条件)&#123; 需要执行的代码&#125;do&#123;需要执行的代码&#125;while (条件); 例子 123456789while (i&lt;5)&#123; x=x + "The number is " + i + "&lt;br&gt;"; i++;&#125;do&#123; x=x + "The number is " + i + "&lt;br&gt;"; i++;&#125;while (i&lt;5); 4.3.跳转 return 用于结束当前函数,并返回内容 break 语句用于跳出循环。 continue 用于跳过循环中的一个迭代。 Break123456for (i=0;i&lt;10;i++)&#123; if (i==3)&#123; break; &#125; x=x + "The number is " + i + "&lt;br&gt;";&#125; Continue1234for (i=0;i&lt;=10;i++)&#123; if (i==3) continue; x=x + "The number is " + i + "&lt;br&gt;";&#125; 4.4.异常处理 try 语句测试代码块的错误。 catch 语句处理错误。 throw 语句创建自定义错误。 throwthrow 语句允许我们创建自定义错误。 语法 1throw exception 例子 12var x=document.getElementById("demo").value;if(x=="") throw "empty"; try 和 catch 语法 12345678910111213try&#123; //在这里运行代码&#125;catch(err)&#123; //在这里处理错误&#125;try&#123; //在这里运行代码&#125;catch(err)&#123; //在这里处理错误&#125;finally&#123; //无论错误和失败都会运行&#125; 实例 1234567891011var txt="";function message()&#123; try&#123; adddlert("Welcome guest!"); &#125;catch(err)&#123; txt="本页有一个错误。\n\n"; txt+="错误描述：" + err.message + "\n\n"; txt+="点击确定继续。\n\n"; alert(txt); &#125;&#125; 五、函数JavaScript 使用关键字 function 定义函数。函数可以通过声明定义，也可以是一个表达式。 5.1.定义 函数声明 123function myFunction(a, b) &#123; return a * b;&#125; 函数表达式 1var x = function (a, b) &#123;return a * b&#125;; 构造函数 123var myFunction = new Function("a", "b", "return a * b");var x = myFunction(4, 3); 函数提升 12345// 提升（Hoisting）是 JavaScript 默认将当前作用域提升到前面去的的行为myFunction(5); function myFunction(y) &#123; return y * y; &#125; 5.2.函数参数JavaScript 函数参数与大多数其他语言的函数参数的区别在于：它不会关注有多少个参数被传递，不关注传递的参数的数据类型。 显式参数 123functionName(parameter1, parameter2, parameter3) &#123; code to be executed&#125; 隐私参数 Arguments 包含了函数调用的参数数组 123456789x = sumAll(1, 123, 500, 115, 44, 88);function sumAll() &#123; var i, sum = 0; for (i = 0; i &lt; arguments.length; i++) &#123; sum += arguments[i]; &#125; return sum;&#125; 默认参数 12345function myFunction(x, y) &#123; if (y === undefined) &#123; y = 0; &#125;&#125; 值传递 12345678var x = 1;// 通过值传递参数function myFunction(x) &#123; x++; //修改参数x的值，将不会修改在函数外定义的变量 x console.log(x);&#125;myFunction(x); // 2console.log(x); // 1 对象传递参数 12345678var obj = &#123;x:1&#125;;// 通过对象传递参数function myFunction(obj) &#123; obj.x++; //修改参数对象obj.x的值，函数外定义的obj也将会被修改 console.log(obj.x);&#125;myFunction(obj); // 2console.log(obj.x); // 2 5.3.函数调用JavaScript 函数有 4 种调用方式。每种方式的不同在于 this 的初始化。一般而言，在Javascript中，this指向函数执行时的当前对象。 作为一个函数调用 123456789function myFunction(a, b) &#123; return a * b;&#125;myFunction(10, 2); // myFunction(10, 2) 返回 20function myFunction() &#123; return this;&#125;myFunction(); // 返回 window 对象 函数作为方法调用 12345678var myObject = &#123; firstName:"John", lastName: "Doe", fullName: function () &#123; return this.firstName + " " + this.lastName; &#125;&#125;myObject.fullName(); // 返回 "John Doe" 使用构造函数调用函数 123456789// 构造函数:function myFunction(arg1, arg2) &#123; this.firstName = arg1; this.lastName = arg2;&#125;// This creates a new objectvar x = new myFunction("John","Doe");x.firstName; // 返回 "John" 作为函数方法调用函数 1234567function myFunction(a, b) &#123; return a * b;&#125;myFunction.call(myObject, 10, 2); // 返回 20myArray = [10,2];myFunction.apply(myObject, myArray); // 返回 20 5.4.闭包能访问函数内部的变量 1234567891011// 只有调用函数才能累计var add = (function () &#123; var counter = 0; return function () &#123;return counter += 1;&#125;&#125;)();add();add();add();// 计数器为 3 More info: JavaScript 参考手册]]></content>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML（五）CSS3]]></title>
    <url>%2F2016%2F09%2F15%2FHtml05%2F</url>
    <content type="text"><![CDATA[CSS3 是最新的 CSS 标准。本文章主要介绍 CSS3 的基本概念。 Quick GuideCSS3 完全向后兼容，因此您不必改变现有的设计。浏览器通常支持 CSS2。 一、边框创建圆角边框，向矩形添加阴影，使用图片来绘制边框. 属性 描述 CSS border-image 设置所有 border-image-* 属性的简写属性。 3 border-radius 设置所有四个 border-*-radius 属性的简写属性。 3 box-shadow 向方框添加一个或多个阴影。 3 border-radius:圆角边框 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; div&#123;text-align:center;border:2px solid #a1a1a1;padding:10px 40px; background:#dddddd;width:350px;border-radius:25px;-moz-border-radius:25px; /* 老的 Firefox */&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;border-radius 属性允许您向元素添加圆角。&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; box-shadow:边框阴影 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; div&#123;width:300px;height:100px;background-color:#ff9900;-moz-box-shadow: 10px 10px 5px #888888; /* 老的 Firefox */box-shadow: 10px 10px 5px #888888;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; border-image:边框图片 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; div&#123;border:15px solid transparent;width:300px;padding:10px 20px;&#125;#round&#123;-moz-border-image:url(/i/border.png) 30 30 round; /* Old Firefox */-webkit-border-image:url(/i/border.png) 30 30 round; /* Safari and Chrome */-o-border-image:url(/i/border.png) 30 30 round; /* Opera */border-image:url(/i/border.png) 30 30 round;&#125;#stretch&#123;-moz-border-image:url(/i/border.png) 30 30 stretch; /* Old Firefox */-webkit-border-image:url(/i/border.png) 30 30 stretch; /* Safari and Chrome */-o-border-image:url(/i/border.png) 30 30 stretch; /* Opera */border-image:url(/i/border.png) 30 30 stretch;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="round"&gt;在这里，图片铺满整个边框。&lt;/div&gt;&lt;br&gt;&lt;div id="stretch"&gt;在这里，图片被拉伸以填充该区域。&lt;/div&gt;&lt;p&gt;这是我们使用的图片：&lt;/p&gt;&lt;img src="/i/border.png"&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt; Internet Explorer 不支持 border-image 属性。&lt;/p&gt;&lt;p&gt;border-image 属性规定了用作边框的图片。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 二、背景 background-size:规定背景图片的尺寸 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; body&#123;background:url(/i/bg_flower.gif);background-size:63px 100px;-moz-background-size:63px 100px; /* 老版本的 Firefox */background-repeat:no-repeat;padding-top:80px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;上面是缩小的背景图片。&lt;/p&gt;&lt;p&gt;原始图片：&lt;img src="/i/bg_flower.gif" alt="Flowers"&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; background-origin:规定背景图片的定位区域 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; div&#123;border:1px solid black;padding:35px;background-image:url('/i/bg_flower.gif');background-repeat:no-repeat;background-position:left;&#125;#div1&#123;background-origin:border-box;&#125;#div2&#123;background-origin:content-box;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;background-origin:border-box:&lt;/p&gt;&lt;div id="div1"&gt;这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。&lt;/div&gt;&lt;p&gt;background-origin:content-box:&lt;/p&gt;&lt;div id="div2"&gt;这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; background-image:使用多个背景图像1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; body&#123;background-image:url(/i/bg_flower.gif),url(/i/bg_flower_2.gif);&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 三、文本效果 属性 描述 CSS hanging-punctuation 规定标点字符是否位于线框之外。 3 punctuation-trim 规定是否对标点字符进行修剪。 3 text-align-last 设置如何对齐最后一行或紧挨着强制换行符之前的行。 3 text-emphasis 向元素的文本应用重点标记以及重点标记的前景色。 3 text-justify 规定当 text-align 设置为 “justify” 时所使用的对齐方法。 3 text-outline 规定文本的轮廓。 3 text-overflow 规定当文本溢出包含元素时发生的事情。 3 text-shadow 向文本添加阴影。 3 text-wrap 规定文本的换行规则。 3 word-break 规定非中日韩文本的换行规则。 3 word-wrap 允许对长的不可分割的单词进行分割并换行到下一行。 3 text-shadow 可向文本应用阴影 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;h1&#123;text-shadow: 5px 5px 5px #FF0000;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;文本阴影效果！&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; word-wrap 属性允许您允许文本强制文本进行换行 - 即使这意味着会对单词进行拆分： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; p.test&#123;width:11em; border:1px solid #000000;word-wrap:break-word;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p class="test"&gt;This paragraph contains a very long word: thisisaveryveryveryveryveryverylongword. The long word will break and wrap to the next line.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 四、字体在 CSS3 之前，web 设计师必须使用已在用户计算机上安装好的字体。 通过 CSS3，web 设计师可以使用他们喜欢的任意字体。将该字体文件存放到 web 服务器上，它会在需要时被自动下载到用户的计算机上。字体是通过 CSS3 @font-face 规则中定义的。 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; @font-face&#123;font-family: myFirstFont;/* 定义字体的名称 */src: url('/example/css3/Sansation_Light.ttf') /* 指向字体文件 */ ,url('/example/css3/Sansation_Light.eot'); /* IE9+ */&#125;@font-face&#123;font-family: myFirstFont;src: url('/example/css3/Sansation_Bold.ttf') ,url('/example/css3/Sansation_Bold.eot'); /* IE9+ */font-weight:bold;&#125;div&#123;font-family:myFirstFont;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;With CSS3, websites can &lt;b&gt;finally&lt;/b&gt; use fonts other than the pre-selected "web-safe" fonts.&lt;/div&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;Internet Explorer 9+ 支持新的 @font-face 规则。Internet Explorer 8 以及更早的版本不支持新的 @font-face 规则。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 下面的表格列出了能够在 @font-face 规则中定义的所有字体描述符： 描述符 值 描述 font-family name 必需。规定字体的名称。 src URL 必需。定义字体文件的 URL。 font-stretch normalcondensedultra-condensedextra-condensedsemi-condensedexpandedsemi-expandedextra-expandedultra-expanded 可选。定义如何拉伸字体。默认是 “normal”。 font-style ormalitalicoblique 可选。定义字体的样式。默认是 “normal”。 font-weight normalbold100200300400500600700800900 可选。定义字体的粗细。默认是 “normal”。 unicode-range unicode-range 可选。定义字体支持的 UNICODE 字符范围。默认是 “U+0-10FFFF”。 五、转换 转换是使元素改变形状、尺寸和位置的一种效果。 2D 转换 转换属性 描述 CSS transform 向元素应用 2D 或 3D 转换。 3 transform-origin 允许你改变被转换元素的位置。 3 2D转换函数 描述 matrix(n,n,n,n,n,n) 定义 2D 转换，使用六个值的矩阵。 translate(x,y) 定义 2D 转换，沿着 X 和 Y 轴移动元素。 translateX(n) 定义 2D 转换，沿着 X 轴移动元素。 translateY(n) 定义 2D 转换，沿着 Y 轴移动元素。 scale(x,y) 定义 2D 缩放转换，改变元素的宽度和高度。 scaleX(n) 定义 2D 缩放转换，改变元素的宽度。 scaleY(n) 定义 2D 缩放转换，改变元素的高度。 rotate(angle) 定义 2D 旋转，在参数中规定角度。 skew(x-angle,y-angle) 定义 2D 倾斜转换，沿着 X 和 Y 轴。 skewX(angle) 定义 2D 倾斜转换，沿着 X 轴。 skewY(angle) 定义 2D 倾斜转换，沿着 Y 轴。 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; div&#123;width:100px;height:75px;background-color:yellow;border:1px solid black;&#125;div#div2&#123;transform:matrix(0.866,0.5,-0.5,0.866,0,0);-ms-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* IE 9 */-moz-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* Firefox */-webkit-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* Safari and Chrome */-o-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* Opera */&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;你好。这是一个 div 元素。&lt;/div&gt;&lt;div id="div2"&gt;你好。这是一个 div 元素。&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3D 转换 转换属性 描述 CSS transform 向元素应用 2D 或 3D 转换。 3 transform-origin 允许你改变被转换元素的位置。 3 transform-style 规定被嵌套元素如何在 3D 空间中显示。 3 perspective 规定 3D 元素的透视效果。 3 perspective-origin 规定 3D 元素的底部位置。 3 backface-visibility 定义元素在不面对屏幕时是否可见。 3 3D转换函数 描述 matrix3d(n,n,n,n,n,n, n,n,n,n,n,n,n,n,n,n) 定义 3D 转换，使用 16 个值的 4x4 矩阵。 translate3d(x,y,z) 定义 3D 转化。 translateX(x) 定义 3D 转化，仅使用用于 X 轴的值。 translateY(y) 定义 3D 转化，仅使用用于 Y 轴的值。 translateZ(z) 定义 3D 转化，仅使用用于 Z 轴的值。 scale3d(x,y,z) 定义 3D 缩放转换。 scaleX(x) 定义 3D 缩放转换，通过给定一个 X 轴的值。 scaleY(y) 定义 3D 缩放转换，通过给定一个 Y 轴的值。 scaleZ(z) 定义 3D 缩放转换，通过给定一个 Z 轴的值。 rotate3d(x,y,z,angle) 定义 3D 旋转。 rotateX(angle) 定义沿 X 轴的 3D 旋转。 rotateY(angle) 定义沿 Y 轴的 3D 旋转。 rotateZ(angle) 定义沿 Z 轴的 3D 旋转。 perspective(n) 定义 3D 转换元素的透视视图。 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; div&#123;width:100px;height:75px;background-color:yellow;border:1px solid black;&#125;div#div2&#123;transform:rotateY(130deg);-webkit-transform:rotateY(130deg); /* Safari and Chrome */-moz-transform:rotateY(130deg); /* Firefox */&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;你好。这是一个 div 元素。&lt;/div&gt;&lt;div id="div2"&gt;你好。这是一个 div 元素。&lt;/div&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt; Internet Explorer 和 Opera 不支持 rotateX 方法。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 六、过渡过渡是元素从一种样式逐渐改变为另一种的效果。 要实现这一点，必须规定两项内容： 规定您希望把效果添加到哪个 CSS 属性上 规定效果的时长 转换属性 描述 CSS transition 简写属性，用于在一个属性中设置四个过渡属性。 3 transition-property 规定应用过渡的 CSS 属性的名称。 3 transition-duration 定义过渡效果花费的时间。默认是 0。 3 transition-timing-function 规定过渡效果的时间曲线。默认是 “ease”。 3 transition-delay 规定过渡效果何时开始。默认是 0。 3 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; div&#123;/* 过渡前 */width:100px;height:100px;background:yellow;transition:width 2s, height 2s;-moz-transition:width 2s, height 2s, -moz-transform 2s; /* Firefox 4 */-webkit-transition:width 2s, height 2s, -webkit-transform 2s; /* Safari and Chrome */-o-transition:width 2s, height 2s, -o-transform 2s; /* Opera */&#125;div:hover&#123;/* 过渡后 */width:200px;height:200px;transform:rotate(180deg);-moz-transform:rotate(180deg); /* Firefox 4 */-webkit-transform:rotate(180deg); /* Safari and Chrome */-o-transform:rotate(180deg); /* Opera */&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;请把鼠标指针放到黄色的 div 元素上，来查看过渡效果。&lt;/div&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;本例在 Internet Explorer 中无效。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 七、动画动画是使元素从一种样式逐渐变化为另一种样式的效果。 请用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100%。 0% 是动画的开始，100% 是动画的完成。 为了得到最佳的浏览器支持，您应该始终定义 0% 和 100% 选择器。 当您在 @keyframes 中创建动画时，请把它捆绑到某个选择器，否则不会产生动画效果。 通过规定至少以下两项 CSS3 动画属性，即可将动画绑定到选择器： 规定动画的名称 规定动画的时长 动画属性 描述 CSS @keyframes 规定动画。 3 animation 所有动画属性的简写属性，除了 animation-play-state 属性。 3 animation-name 规定 @keyframes 动画的名称。 3 animation-duration 规定动画完成一个周期所花费的秒或毫秒。默认是 0。 3 animation-timing-function 规定动画的速度曲线。默认是 “ease”。 3 animation-delay 规定动画何时开始。默认是 0。 3 animation-iteration-count 规定动画被播放的次数。默认是 1。 3 animation-direction 规定动画是否在下一周期逆向地播放。默认是 “normal”。 3 animation-play-state 规定动画是否正在运行或暂停。默认是 “running”。 3 animation-fill-mode 规定对象动画时间之外的状态。 3 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; div&#123;width:100px;height:100px;background:red;position:relative;animation-name:myfirst;animation-duration:5s;animation-timing-function:linear;animation-delay:2s;animation-iteration-count:infinite;animation-direction:alternate;animation-play-state:running;/* Firefox: */-moz-animation-name:myfirst;-moz-animation-duration:5s;-moz-animation-timing-function:linear;-moz-animation-delay:2s;-moz-animation-iteration-count:infinite;-moz-animation-direction:alternate;-moz-animation-play-state:running;/* Safari and Chrome: */-webkit-animation-name:myfirst;-webkit-animation-duration:5s;-webkit-animation-timing-function:linear;-webkit-animation-delay:2s;-webkit-animation-iteration-count:infinite;-webkit-animation-direction:alternate;-webkit-animation-play-state:running;/* Opera: */-o-animation-name:myfirst;-o-animation-duration:5s;-o-animation-timing-function:linear;-o-animation-delay:2s;-o-animation-iteration-count:infinite;-o-animation-direction:alternate;-o-animation-play-state:running;&#125;@keyframes myfirst&#123;0% &#123;background:red; left:0px; top:0px;&#125;25% &#123;background:yellow; left:200px; top:0px;&#125;50% &#123;background:blue; left:200px; top:200px;&#125;75% &#123;background:green; left:0px; top:200px;&#125;100% &#123;background:red; left:0px; top:0px;&#125;&#125;@-moz-keyframes myfirst /* Firefox */&#123;0% &#123;background:red; left:0px; top:0px;&#125;25% &#123;background:yellow; left:200px; top:0px;&#125;50% &#123;background:blue; left:200px; top:200px;&#125;75% &#123;background:green; left:0px; top:200px;&#125;100% &#123;background:red; left:0px; top:0px;&#125;&#125;@-webkit-keyframes myfirst /* Safari and Chrome */&#123;0% &#123;background:red; left:0px; top:0px;&#125;25% &#123;background:yellow; left:200px; top:0px;&#125;50% &#123;background:blue; left:200px; top:200px;&#125;75% &#123;background:green; left:0px; top:200px;&#125;100% &#123;background:red; left:0px; top:0px;&#125;&#125;@-o-keyframes myfirst /* Opera */&#123;0% &#123;background:red; left:0px; top:0px;&#125;25% &#123;background:yellow; left:200px; top:0px;&#125;50% &#123;background:blue; left:200px; top:200px;&#125;75% &#123;background:green; left:0px; top:200px;&#125;100% &#123;background:red; left:0px; top:0px;&#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;本例在 Internet Explorer 中无效。&lt;/p&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 八、多列 创建多个列来对文本进行布局 属性 描述 CSS column-count 规定元素应该被分隔的列数。 3 column-fill 规定如何填充列。 3 column-gap 规定列之间的间隔。 3 column-rule 设置所有 column-rule-* 属性的简写属性。 3 column-rule-color 规定列之间规则的颜色。 3 column-rule-style 规定列之间规则的样式。 3 column-rule-width 规定列之间规则的宽度。 3 column-span 规定元素应该横跨的列数。 3 column-width 规定列的宽度。 3 columns 规定设置 column-width 和 column-count 的简写属性。 3 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; .newspaper&#123;-moz-column-count:3; /* Firefox */-webkit-column-count:3; /* Safari and Chrome */column-count:3;-moz-column-gap:40px; /* Firefox */-webkit-column-gap:40px; /* Safari and Chrome */column-gap:40px;-moz-column-rule:4px outset #ff0000; /* Firefox */-webkit-column-rule:4px outset #ff0000; /* Safari and Chrome */column-rule:4px outset #ff0000;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;Internet Explorer 不支持 column-count 属性。&lt;/p&gt;&lt;div class="newspaper"&gt;人民网北京2月24日电 (记者 刘阳)国家发展改革委近日发出通知，决定自2月25日零时起将汽、柴油价格每吨分别提高300元和290元，折算到90号汽油和0号柴油（全国平均）每升零售价格分别提高0.22元和0.25元。此次国内成品油价格调整幅度，是按照现行国内成品油价格形成机制，根据国际市场油价变化情况确定的。去年11月16日国内成品油价格调整以来，受市场预期欧美经济复苏前景向好以及中东局势持续动荡等因素影响，国际市场原油价格先抑后扬，2月上旬WTI和布伦特原油期货价格再次回升至每桶95美元和115美元以上。虽然近两日价格有所回落，但国内油价挂钩的国际市场三种原油连续22个工作日移动平均价格上涨幅度已超过4%，达到国内成品油价格调整的边界条件。通知指出，这次成品油调价后，国家将按照已建立的补贴机制，继续对种粮农民、渔业（含远洋渔业）、林业、城市公交、农村道路客运（含岛际和农村水路客运）等给予补贴。同时，为保证市场物价基本稳定，防止连锁涨价，对与居民生活密切相关的铁路客运、城市公交、农村道路客运（含岛际和农村水路客运）价格不作调整。通知要求，中石油、中石化、中海油三大公司要组织好成品油生产和调运，保持合理库存，加强综合协调和应急调度，保障成品油供应。各级价格主管部门要加大市场监督检查力度，依法查处不执行国家价格政策，以及囤积居奇、造谣惑众、合谋涨价、搭车涨价等违法行为，维护正常市场秩序。&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 九、用户界面 用户界面特性包括重设元素尺寸、盒尺寸以及轮廓等。 属性 描述 CSS appearance 允许您将元素设置为标准用户界面元素的外观 3 box-sizing 允许您以确切的方式定义适应某个区域的具体内容。 3 icon 为创作者提供使用图标化等价物来设置元素样式的能力。 3 nav-down 规定在使用 arrow-down 导航键时向何处导航。 3 nav-index 设置元素的 tab 键控制次序。 3 nav-left 规定在使用 arrow-left 导航键时向何处导航。 3 nav-right 规定在使用 arrow-right 导航键时向何处导航。 3 nav-up 规定在使用 arrow-up 导航键时向何处导航。 3 outline-offset 对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。 3 resize 规定是否可由用户对元素的尺寸进行调整。 3 resize:是否可由用户调整元素尺寸 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; div&#123;border:2px solid;padding:10px 40px; width:300px;resize:both;overflow:auto;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;resize 属性规定是否可由用户调整元素尺寸。&lt;/div&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt; Firefox 4+、Safari 以及 Chrome 支持 resize 属性。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; box-sizing:以确切的方式定义适应某个区域的具体内容 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; div.container&#123;width:30em;border:1em solid;&#125;div.box&#123;box-sizing:border-box;-moz-box-sizing:border-box; /* Firefox */-webkit-box-sizing:border-box; /* Safari */width:50%;border:1em solid red;float:left;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt;&lt;div class="box"&gt;这个 div 占据左半部分。&lt;/div&gt;&lt;div class="box"&gt;这个 div 占据右半部分。&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; outline-offset:对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; div&#123;margin:20px;width:150px; padding:10px;height:70px;border:2px solid black;outline:2px solid red;outline-offset:15px;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;Internet Explorer 和 Opera 不支持 support outline-offset 属性。&lt;/p&gt;&lt;div&gt;这个 div 在边框边缘之外 15 像素处有一个轮廓。&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; More info: CSS3 参考手册]]></content>
      <tags>
        <tag>web</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML（四）CSS]]></title>
    <url>%2F2016%2F08%2F15%2FHtml04%2F</url>
    <content type="text"><![CDATA[层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。本文章主要介绍 CSS 的基本概念。 Quick Guide样式定义如何显示 HTML 元素，样式通常存储在样式表中，CSS 指层叠样式表 (Cascading Style Sheets) 样式表允许以多种方式规定样式信息。数字越大，优先展示。 浏览器缺省设置 外部样式表 内部样式表（位于&lt;head&gt; 标签内部） 内联样式（在 HTML 元素内部） 一、语法CSS 规则由两个主要的部分构成： 选择器 一条或多条声明 1selector &#123;declaration1; declaration2; ... declarationN &#125; 每条声明由一个属性和一个值组成。 1selector &#123;property: value&#125; 样例： 1234567891011121314151617&lt;!--值的不同写法和单位--&gt;p &#123; color: #ff0000; &#125;p &#123; color: #f00; &#125;p &#123; color: rgb(255,0,0); &#125;p &#123; color: rgb(100%,0%,0%); &#125;p &#123;font-family: "sans serif";&#125;&lt;!--值为若干单词，则要给值加引号--&gt;p &#123;font-family: "sans serif";&#125;&lt;!--保持换行和末尾的';' 这样更好修改,避免错误--&gt;body &#123; color: #000; background: #fff; margin: 0; padding: 0; font-family: Georgia, Palatino, serif; &#125; 1.1.继承123456789101112&lt;!--通过 CSS 继承，子元素将继承最高级元素（在本例中是 body）所拥有的属性（这些子元素诸如 p, td, ul, ol, ul, li, dl, dt,和 dd）,除了部分浏览器不支持(Netscape 4 IE6 )--&gt;body &#123; font-family: Verdana, sans-serif; &#125;&lt;!--为了避免遇到不支持,下面做一下子元素设置--&gt;td, ul, ol, ul, li, dl, dt, dd &#123; font-family: Verdana, sans-serif; &#125;&lt;!--针对p元素设置一个独立的设置--&gt;p &#123; font-family: Times, "Times New Roman", serif; &#125; 二、创建 CSS 外部样式表：使用 &lt;link&gt; 标签链接到样式表 123&lt;head&gt;&lt;link rel="stylesheet" type="text/css" href="mystyle.css" /&gt;&lt;/head&gt; 内部样式表:使用 &lt;style&gt; 标签在文档头部定义内部样式表 1234567&lt;head&gt;&lt;style type="text/css"&gt; hr &#123;color: sienna;&#125; p &#123;margin-left: 20px;&#125; body &#123;background-image: url("images/back40.gif");&#125;&lt;/style&gt;&lt;/head&gt; 内联样式:相关的标签内使用样式（style）属性 123&lt;p style="color: sienna; margin-left: 20px"&gt;This is a paragraph&lt;/p&gt; 多重样式：多种样式同时存在，取交集；同样的部分，优先级高覆盖低 三、CSS 样式3.1.背景 属性 描述 background 简写属性，作用是将背景属性设置在一个声明中。 background-attachment 背景图像是否固定或者随着页面的其余部分滚动。 background-color 设置元素的背景颜色。 background-image 把图像设置为背景。 background-position 设置背景图像的起始位置。支持位置关键字、百分比和长度值 background-repeat 设置背景图像是否及如何重复。 123456789101112131415161718&lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt;body &#123;background-color: yellow&#125;h1 &#123;background-color: #00ff00&#125;h2 &#123;background-color: transparent&#125;p &#123;background-color: rgb(250,0,255)&#125;p.no2 &#123;background-color: gray; padding: 20px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;这是标题 1&lt;/h1&gt;&lt;h2&gt;这是标题 2&lt;/h2&gt;&lt;p&gt;这是段落&lt;/p&gt;&lt;p class="no2"&gt;这个段落设置了内边距。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 3.2.文本 属性 描述 color 设置文本颜色 direction 设置文本方向。 line-height 设置行高。 letter-spacing 设置字符间距。 text-align 对齐元素中的文本。 text-decoration 向文本添加修饰。 text-indent 缩进元素中文本的首行。 text-shadow 设置文本阴影。CSS2 包含该属性，但是 CSS2.1 没有保留该属性。 text-transform 控制元素中的字母。 unicode-bidi 设置文本方向。 white-space 设置元素中空白的处理方式。 word-spacing 设置字间距。 123456789101112131415161718192021222324&lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt;p &#123;text-indent: 1em&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;这是段落中的一些文本。这是段落中的一些文本。这是段落中的一些文本。这是段落中的一些文本。这是段落中的一些文本。这是段落中的一些文本。这是段落中的一些文本。这是段落中的一些文本。这是段落中的一些文本。这是段落中的一些文本。这是段落中的一些文本。这是段落中的一些文本。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 3.3.字体在 CSS 中，有两种不同类型的字体系列名称： 通用字体系列 - 拥有相似外观的字体系统组合（比如 “Serif” 或 “Monospace”） 特定字体系列 - 具体的字体系列（比如 “Times” 或 “Courier”） 除了各种特定的字体系列外，CSS 定义了 5 种通用字体系列： Serif 字体 Sans-serif 字体 Monospace 字体 Cursive 字体 Fantasy 字体 属性 描述 font 简写属性。作用是把所有针对字体的属性设置在一个声明中。 font-family 设置字体系列。 font-size 设置字体的尺寸。 font-size-adjust 当首选字体不可用时，对替换字体进行智能缩放。（CSS2.1 已删除该属性。） font-stretch 对字体进行水平拉伸。（CSS2.1 已删除该属性。） font-style 设置字体风格。 font-variant 以小型大写字体或者正常字体显示文本。 font-weight 设置字体的粗细。 123456789101112131415161718192021&lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt;body &#123;font-family:sans-serif;&#125;p &#123; font-family: Times, TimesNR, 'New Century Schoolbook', Georgia, 'New York', serif; font-size:1em; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;This is heading 1&lt;/h1&gt;&lt;p style="font-family: Times, TimesNR, 'New Century Schoolbook', Georgia, 'New York', serif;"&gt;This is a paragraph.&lt;/p&gt;&lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;p&gt;...&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 3.4.链接链接的四种状态： a:link - 普通的、未被访问的链接 a:visited - 用户已访问的链接 a:hover - 鼠标指针位于链接的上方 a:active - 链接被点击的时刻 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;a:link &#123;color:#FF0000;&#125; /* 未被访问的链接 */a:visited &#123;color:#00FF00;&#125; /* 已被访问的链接 */a:hover &#123;color:#FF00FF;&#125; /* 鼠标指针移动到链接上 */a:active &#123;color:#0000FF;&#125; /* 正在被点击的链接 */&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;b&gt;&lt;a href="/index.html" target="_blank"&gt;这是一个链接&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;为了使定义生效，a:hover 必须位于 a:link 和 a:visited 之后！！&lt;/p&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;为了使定义生效，a:active 必须位于 a:hover 之后！！&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 3.5.列表 属性 描述 list-style 简写属性。用于把所有用于列表的属性设置于一个声明中。 list-style-image 将图象设置为列表项标志。 list-style-position 设置列表中列表项标志的位置。 list-style-type 设置列表项标志的类型。 marker-offset 12345678910111213141516171819202122232425262728293031323334353637&lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt;ul.disc &#123;list-style-type: disc&#125;ul.circle &#123;list-style-type: circle&#125;ul.square &#123;list-style-type: square&#125;ul.none &#123;list-style-type: none&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul class="disc"&gt;&lt;li&gt;咖啡&lt;/li&gt;&lt;li&gt;茶&lt;/li&gt;&lt;li&gt;可口可乐&lt;/li&gt;&lt;/ul&gt;&lt;ul class="circle"&gt;&lt;li&gt;咖啡&lt;/li&gt;&lt;li&gt;茶&lt;/li&gt;&lt;li&gt;可口可乐&lt;/li&gt;&lt;/ul&gt;&lt;ul class="square"&gt;&lt;li&gt;咖啡&lt;/li&gt;&lt;li&gt;茶&lt;/li&gt;&lt;li&gt;可口可乐&lt;/li&gt;&lt;/ul&gt;&lt;ul class="none"&gt;&lt;li&gt;咖啡&lt;/li&gt;&lt;li&gt;茶&lt;/li&gt;&lt;li&gt;可口可乐&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 3.6.表格 属性 描述 border-collapse 设置是否把表格边框合并为单一的边框。 border-spacing 设置分隔单元格边框的距离。 caption-side 设置表格标题的位置。 empty-cells 设置是否显示表格中的空单元格。 table-layout 设置显示单元、行和列的算法。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt;table,td,th &#123; border:1px solid black; &#125;table &#123; width:100%; &#125;th &#123; height:50px; &#125;td&#123;height:50px;vertical-align:bottom;text-align:right;padding:15px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt;&lt;tr&gt;&lt;th&gt;Firstname&lt;/th&gt;&lt;th&gt;Lastname&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Bill&lt;/td&gt;&lt;td&gt;Gates&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Steven&lt;/td&gt;&lt;td&gt;Jobs&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 3.7.轮廓 属性 描述 CSS outline 在一个声明中设置所有的轮廓属性。 2 outline-color 设置轮廓的颜色。 2 outline-style 设置轮廓的样式。 2 outline-width 设置轮廓的宽度。 2 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt;p&#123;border: red solid thin;&#125;p.dotted &#123;outline-style: dotted&#125;p.dashed &#123;outline-style: dashed&#125;p.solid &#123;outline-style: solid&#125;p.double &#123;outline-style: double&#125;p.groove &#123;outline-style: groove&#125;p.ridge &#123;outline-style: ridge&#125;p.inset &#123;outline-style: inset&#125;p.outset &#123;outline-style: outset&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p class="dotted"&gt;A dotted outline&lt;/p&gt;&lt;p class="dashed"&gt;A dashed outline&lt;/p&gt;&lt;p class="solid"&gt;A solid outline&lt;/p&gt;&lt;p class="double"&gt;A double outline&lt;/p&gt;&lt;p class="groove"&gt;A groove outline&lt;/p&gt;&lt;p class="ridge"&gt;A ridge outline&lt;/p&gt;&lt;p class="inset"&gt;An inset outline&lt;/p&gt;&lt;p class="outset"&gt;An outset outline&lt;/p&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;只有在规定了 !DOCTYPE 时，Internet Explorer 8 （以及更高版本） 才支持 outline-style 属性。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 四、框模型 CSS 框模型 (Box Model) 规定了元素框处理元素内容、内边距、边框 和 外边距 的方式。 4.1.内边距 元素边框与元素内容之间的空白区域。 属性 描述 padding 简写属性。作用是在一个声明中设置元素的所内边距属性。 padding-bottom 设置元素的下内边距。 padding-left 设置元素的左内边距。 padding-right 设置元素的右内边距。 padding-top 设置元素的上内边距。 123456789101112131415161718192021222324252627&lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt;td.test1 &#123;padding: 1.5cm&#125;td.test2 &#123;padding: 0.5cm 2.5cm&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;table border="1"&gt;&lt;tr&gt;&lt;td class="test1"&gt;这个表格单元的每个边拥有相等的内边距。&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;br /&gt;&lt;table border="1"&gt;&lt;tr&gt;&lt;td class="test2"&gt;这个表格单元的上和下内边距是 0.5cm，左和右内边距是 2.5cm。&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 4.2.边框CSS 边框属性 属性 描述 border 简写属性，用于把针对四个边的属性设置在一个声明。 border-style 用于设置元素所有边框的样式，或者单独地为各边设置边框样式。 border-width 简写属性，用于为元素的所有边框设置宽度，或者单独地为各边边框设置宽度。 border-color 简写属性，设置元素的所有边框中可见部分的颜色，或为 4 个边分别设置颜色。 border-bottom 简写属性，用于把下边框的所有属性设置到一个声明中。 border-bottom-color 设置元素的下边框的颜色。 border-bottom-style 设置元素的下边框的样式。 border-bottom-width 设置元素的下边框的宽度。 border-left 简写属性，用于把左边框的所有属性设置到一个声明中。 border-left-color 设置元素的左边框的颜色。 border-left-style 设置元素的左边框的样式。 border-left-width 设置元素的左边框的宽度。 border-right 简写属性，用于把右边框的所有属性设置到一个声明中。 border-right-color 设置元素的右边框的颜色。 border-right-style 设置元素的右边框的样式。 border-right-width 设置元素的右边框的宽度。 border-top 简写属性，用于把上边框的所有属性设置到一个声明中。 border-top-color 设置元素的上边框的颜色。 border-top-style 设置元素的上边框的样式。 border-top-width 设置元素的上边框的宽度。 123456789101112131415&lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt;p &#123;border-style:solid;border-left:thick double #ff0000;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;This is some text in a paragraph.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 4.3.外边距 围绕在元素边框的空白区域是外边距。 属性 描述 margin 简写属性。在一个声明中设置所有外边距属性。margin: top right bottom left margin-bottom 设置元素的下外边距。 margin-left 设置元素的左外边距。 margin-right 设置元素的右外边距。 margin-top 设置元素的上外边距。 外边距少于 4 个值。规则如下： 如果缺少左外边距的值，则使用右外边距的值。 如果缺少下外边距的值，则使用上外边距的值。 如果缺少右外边距的值，则使用上外边距的值。 123456789101112131415161718&lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt;p.margin &#123;margin: 2cm&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;这个段落没有指定外边距。&lt;/p&gt;&lt;p class="margin"&gt;这个段落带有指定的外边距。这个段落带有指定的外边距。这个段落带有指定的外边距。这个段落带有指定的外边距。这个段落带有指定的外边距。&lt;/p&gt;&lt;p&gt;这个段落没有指定外边距。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 当两个垂直外边距相遇时，它们将形成一个外边距。 合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。 五、定位定位属性允许你对元素进行定位。 普通流： 普通流中的元素的位置由元素在 (X)HTML 中的位置决定。 绝对定位 浮动 属性 描述 position 把元素放置到一个静态的、相对的、绝对的、或固定的位置中。 top 定义了一个定位元素的上外边距边界与其包含块上边界之间的偏移。 right 定义了定位元素右外边距边界与其包含块右边界之间的偏移。 bottom 定义了定位元素下外边距边界与其包含块下边界之间的偏移。 left 定义了定位元素左外边距边界与其包含块左边界之间的偏移。 overflow 设置当元素的内容溢出其区域时发生的事情。 clip 设置元素的形状。元素被剪入这个形状之中，然后显示出来。 vertical-align 设置元素的垂直对齐方式。 z-index 设置元素的堆叠顺序。 5.1.相对定位 相对定位实际上被看作普通流定位模型的一部分，因为元素的位置相对于它在普通流中的位置。 1234567891011121314151617181920212223242526&lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt;h2.pos_left&#123;position:relative;left:-20px&#125;h2.pos_right&#123;position:relative;left:20px&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;这是位于正常位置的标题&lt;/h2&gt;&lt;h2 class="pos_left"&gt;这个标题相对于其正常位置向左移动&lt;/h2&gt;&lt;h2 class="pos_right"&gt;这个标题相对于其正常位置向右移动&lt;/h2&gt;&lt;p&gt;相对定位会按照元素的原始位置对该元素进行移动。&lt;/p&gt;&lt;p&gt;样式 "left:-20px" 从元素的原始左侧位置减去 20 像素。&lt;/p&gt;&lt;p&gt;样式 "left:20px" 向元素的原始左侧位置增加 20 像素。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 5.2.绝对定位 绝对定位使元素的位置与文档流无关， 普通流中其它元素的布局就像绝对定位的元素不存在一样 。 123456789101112131415161718&lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt;h2.pos_abs&#123;position:absolute;left:100px;top:150px&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 class="pos_abs"&gt;这是带有绝对定位的标题&lt;/h2&gt;&lt;p&gt;通过绝对定位，元素可以放置到页面上的任何位置。下面的标题距离页面左侧 100px，距离页面顶部 150px。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 5.3.浮动浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。 由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。 float ：元素的浮动。 clear：元素的哪一侧不允许其他浮动元素 12345678910111213141516171819202122&lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt;img &#123;float:right&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;在下面的段落中，我们添加了一个样式为 &lt;b&gt;float:right&lt;/b&gt; 的图像。结果是这个图像会浮动到段落的右侧。&lt;/p&gt;&lt;p&gt;&lt;img src="/i/eg_cute.gif" /&gt;This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617&lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt;img &#123; float:left; clear:both; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;img src="/i/eg_smile.gif" /&gt;&lt;img src="/i/eg_smile.gif" /&gt;&lt;/body&gt;&lt;/html&gt; 六、选择器6.1.元素选择器元素选择器又称为类型选择器（type selector）。 123456789101112131415&lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt;html &#123;color:black;&#125;p &#123;color:blue;&#125;h2 &#123;color:silver;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;这是 heading 1&lt;/h1&gt;&lt;h2&gt;这是 heading 2&lt;/h2&gt;&lt;p&gt;这是一段普通的段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 6.2.选择器的分组1234h1,h2,h3,h4,h5,h6 &#123; color: green; &#125;* &#123;color:red;&#125; 6.3.派生选择器根据文档的上下文关系来确定某个标签的样式。 1234567891011li strong &#123; font-style: italic; font-weight: normal; &#125;&lt;p&gt;&lt;strong&gt;我是粗体字，不是斜体字，因为我不在列表当中，所以这个规则对我不起作用&lt;/strong&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;我是斜体字。这是因为 strong 元素位于 li 元素内。&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;我是正常的字体。&lt;/li&gt;&lt;/ol&gt; 6.4.类选择器在 CSS 中，类选择器以一个点号显示：1234567891011121314151617181920.center &#123;text-align: center&#125;&lt;h1 class="center"&gt;This heading will be center-aligned&lt;/h1&gt;&lt;p class="center"&gt;This paragraph will also be center-aligned.&lt;/p&gt;&lt;!-- 与派生器结合--&gt;.fancy td &#123; color: #f60; background: #666; &#125;td.fancy &#123; color: #f60; background: #666; &#125; 12345678910111213141516171819202122&lt;html&gt;&lt;head&gt;&lt;!-- 多类选择器:通过把两个类选择器链接在一起，选择同时包含这些类名的元素 --&gt;&lt;style type="text/css"&gt;.important &#123;font-weight:bold;&#125;.warning &#123;font-style:italic;&#125;.important.warning &#123;background:silver;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p class="important"&gt;This paragraph is very important.&lt;/p&gt;&lt;p class="warning"&gt;This is a warning.&lt;/p&gt;&lt;p class="important urgent warning"&gt;This paragraph is a very important warning.&lt;/p&gt;&lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;p&gt;...&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 6.5.id 选择器为标有特定 id 的 HTML 元素指定特定的样式。以 “#” 来定义。 123456789101112#red &#123;color:red;&#125;#green &#123;color:green;&#125;&lt;p id="red"&gt;这个段落是红色。&lt;/p&gt;&lt;p id="green"&gt;这个段落是绿色。&lt;/p&gt;&lt;!-- 与派生器结合--&gt;#sidebar p &#123; font-style: italic; text-align: right; margin-top: 0.5em; &#125; 注意事项: 只能在文档中使用一次 不能使用 ID 词列表 区分大小写 6.6.属性选择器为拥有指定属性的 HTML 元素设置样式，而不仅限于 class 和 id 属性。只有在规定了 !DOCTYPE 时，IE7 和 IE8 才支持属性选择器。在 IE6 及更低的版本中，不支持属性选择。 选择器 描述 [attribute] 用于选取带有指定属性的元素。 [attribute=value] 用于选取带有指定属性和值的元素。属性与属性值必须完全匹配 [attribute~=value] 用于选取属性值中包含指定词汇的元素。 [[attribute\ =value]](https://www.w3school.com.cn/cssref/selector_attribute_value_start.asp) 用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。 [attribute^=value] 匹配属性值以指定值开头的每个元素。 [attribute$=value] 匹配属性值以指定值结尾的每个元素。 [attribute**=value*] 匹配属性值中包含指定值的每个元素。 123456*[title] &#123;color:red;&#125;a[href][title] &#123;color:red;&#125;[title=W3School]&#123;border:5px solid blue;&#125; 6.7.后代选择器 在后代选择器中，规则左边的选择器一端包括两个或多个用空格分隔的选择器。选择器之间的空格是一种结合符（combinator）。每个空格结合符可以解释为“… 在 … 找到”、“… 作为 … 的一部分”、“… 作为 … 的后代”，但是要求必须从右向左读选择器。 12345678910111213141516171819202122232425262728&lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt;ul em &#123;color:red; font-weight:bold;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;List item 1 &lt;ol&gt; &lt;li&gt;List item 1-1&lt;/li&gt; &lt;li&gt;List item 1-2&lt;/li&gt; &lt;li&gt;List item 1-3 &lt;ol&gt; &lt;li&gt;List item 1-3-1&lt;/li&gt; &lt;li&gt;List item &lt;em&gt;1-3-2&lt;/em&gt;&lt;/li&gt; &lt;li&gt;List item 1-3-3&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt;List item 1-4&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt;List item 2&lt;/li&gt; &lt;li&gt;List item 3&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 6.8.子元素选择器 选择作为某元素子元素的元素，子选择器使用了大于号（子结合符）。 1234567891011121314&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;!--选择只作为 h1 元素子元素的 strong 元素 --&gt;&lt;style type="text/css"&gt;h1 &gt; strong &#123;color:red;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;This is &lt;strong&gt;very&lt;/strong&gt; &lt;strong&gt;very&lt;/strong&gt; important.&lt;/h1&gt;&lt;h1&gt;This is &lt;em&gt;really &lt;strong&gt;very&lt;/strong&gt;&lt;/em&gt; important.&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 6.9.相邻兄弟选择器 选择紧接在另一元素后的元素，且二者有相同父元素。 相邻兄弟选择器使用了加号（+），即相邻兄弟结合符（Adjacent sibling combinator）。 123456789101112&lt;div&gt; &lt;ul&gt; &lt;li&gt;List item 1&lt;/li&gt; &lt;li&gt;List item 2&lt;/li&gt; &lt;li&gt;List item 3&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt;List item 1&lt;/li&gt; &lt;li&gt;List item 2&lt;/li&gt; &lt;li&gt;List item 3&lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 6.10.伪类 (Pseudo-classes) 用于向某些选择器添加特殊的效果。 12selector : pseudo-class &#123;property: value&#125;selector.class : pseudo-class &#123;property: value&#125; W3C：”W3C” 列指示出该属性在哪个 CSS 版本中定义（CSS1 还是 CSS2）。 属性 描述 CSS :active 向被激活的元素添加样式。 1 :focus 向拥有键盘输入焦点的元素添加样式。 2 :hover 当鼠标悬浮在元素上方时，向元素添加样式。 1 :link 向未被访问的链接添加样式。 1 :visited 向已被访问的链接添加样式。 1 :first-child 向元素的第一个子元素添加样式。 2 :lang 向带有指定 lang 属性的元素添加样式。 2 1234567891011121314151617181920&lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt;a:link &#123;color: #FF0000&#125;a:visited &#123;color: #00FF00&#125;a:hover &#123;color: #FF00FF&#125;a:active &#123;color: #0000FF&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;b&gt;&lt;a href="/index.html" target="_blank"&gt;这是一个链接。&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;在 CSS 定义中，a:hover 必须位于 a:link 和 a:visited 之后，这样才能生效！&lt;/p&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;在 CSS 定义中，a:active 必须位于 a:hover 之后，这样才能生效！&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 注： 伪类名称对大小写不敏感。 6.11.伪元素 (Pseudo-elements)用于向某些选择器设置特殊效果。 12selector:pseudo-element &#123;property:value;&#125;selector.class:pseudo-element &#123;property:value;&#125; W3C：”W3C” 列指示出该属性在哪个 CSS 版本中定义（CSS1 还是 CSS2）。 属性 描述 CSS :first-letter 向文本的第一个字母添加特殊样式。 1 :first-line 向文本的首行添加特殊样式。 1 :before 在元素之前添加内容。 2 :after 在元素之后添加内容。 1234567891011121314151617181920212223&lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt;p:first-letter &#123; color:#ff0000; font-size:xx-large; &#125;p:first-line &#123; color:#0000ff; font-variant:small-caps; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;You can combine the :first-letter and :first-line pseudo-elements to add a special effect to the first letter and the first line of a text!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 七、高级7.1.对齐使用多种属性来水平对齐元素。 对齐块元素 123&lt;h1&gt;&lt;p&gt;&lt;div&gt; margin 属性来水平对齐 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;.center&#123;margin:auto;width:70%;background-color:#b0e0e6;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="center"&gt;&lt;p&gt;这是一个段落。这是一个段落。这是一个段落。这是一个段落。这是一个段落。&lt;/p&gt;&lt;p&gt;这是一个段落。这是一个段落。这是一个段落。这是一个段落。这是一个段落。&lt;/p&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;除非已经声明了 !DOCTYPE，否则使用 margin:auto 在 IE8 以及更早的版本中是无效的。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; position 属性进行左和右对齐 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;body&#123;margin:0;padding:0;&#125;.container&#123;position:relative;width:100%;&#125;.right&#123;position:absolute;right:0px;width:300px;background-color:#b0e0e6;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt;&lt;div class="right"&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;当使用 position 属性进行对齐时，请始终包含 !DOCTYPE 声明！如果省略，则会在 IE 浏览器中产生奇怪的结果。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; float 属性来进行左和右对齐 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;body&#123;margin:0;padding:0;&#125;.right&#123;float:right;width:300px;background-color:#b0e0e6;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="right"&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;当使用 float 属性进行对齐时，请始终包含 !DOCTYPE 声明！如果省略，则会在 IE 浏览器中产生奇怪的结果。&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 7.2.尺寸 属性 描述 height 设置元素的高度。 line-height 设置行高。 max-height 设置元素的最大高度。 max-width 设置元素的最大宽度。 min-height 设置元素的最小高度。 min-width 设置元素的最小宽度。 width 设置元素的宽度。 7.3 分类 属性 描述 clear 设置一个元素的侧面是否允许其他的浮动元素。 cursor 规定当指向某元素之上时显示的指针类型。 display 设置是否及如何显示元素。 float 定义元素在哪个方向浮动。 position 把元素放置到一个静态的、相对的、绝对的、或固定的位置中。 visibility 设置元素是否可见或不可见。 7.4.导航条 链接列表 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="#home"&gt;Home&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#news"&gt;News&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#contact"&gt;Contact&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#about"&gt;About&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;我们使用在测试链接中使用了 href="#"。在真实的网站中，应该是真实的 URL。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 垂直导航栏 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;ul&#123;list-style-type:none;margin:0;padding:0;&#125;a&#123;display:block;width:60px;background-color:#dddddd;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="#home"&gt;Home&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#news"&gt;News&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#contact"&gt;Contact&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#about"&gt;About&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;为了显示出链接区域，我们为链接添加了背景色。&lt;/p&gt;&lt;p&gt;请注意，全部链接区域都是可点击的，不仅仅是文本。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 水平导航栏 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;ul&#123;list-style-type:none;margin:0;padding:0;&#125;li&#123;display:inline;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="#home"&gt;Home&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#news"&gt;News&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#contact"&gt;Contact&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#about"&gt;About&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 对列表项进行浮动 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;ul&#123;list-style-type:none;margin:0;padding:0;overflow:hidden;&#125;li&#123;float:left;&#125;a&#123;display:block;width:60px;background-color:#dddddd;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="#home"&gt;Home&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#news"&gt;News&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#contact"&gt;Contact&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#about"&gt;About&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;如果没有规定 !DOCTYPE，则浮动项目会产生意想不到的结果。&lt;/p&gt;&lt;p&gt;为了显示出链接区域，我们为链接添加了背景色。&lt;/p&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;向 ul 元素添加 overflow:hidden，是为了防止 li 元素出现在列表之外。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 7.5.图片库1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;div.img &#123; margin:3px; border:1px solid #bebebe; height:auto; width:auto; float:left; text-align:center; &#125;div.img img &#123; display:inline; margin:3px; border:1px solid #bebebe; &#125;div.img a:hover img &#123; border:1px solid #333333; &#125;div.desc &#123; text-align:center; font-weight:normal; width:150px; font-size:12px; margin:10px 5px 10px 5px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="img"&gt; &lt;a target="_blank" href="/i/tulip_ballade.jpg"&gt; &lt;img src="/i/tulip_ballade_s.jpg" alt="Ballade" width="160" height="160"&gt; &lt;/a&gt; &lt;div class="desc"&gt;在此处添加对图像的描述&lt;/div&gt;&lt;/div&gt;&lt;div class="img"&gt; &lt;a target="_blank" href="/i/tulip_flaming_club.jpg"&gt; &lt;img src="/i/tulip_flaming_club_s.jpg" alt="Ballade" width="160" height="160"&gt; &lt;/a&gt; &lt;div class="desc"&gt;在此处添加对图像的描述&lt;/div&gt;&lt;/div&gt;&lt;div class="img"&gt; &lt;a target="_blank" href="/i/tulip_fringed_family.jpg"&gt; &lt;img src="/i/tulip_fringed_family_s.jpg" alt="Ballade" width="160" height="160"&gt; &lt;/a&gt; &lt;div class="desc"&gt;在此处添加对图像的描述&lt;/div&gt;&lt;/div&gt;&lt;div class="img"&gt; &lt;a target="_blank" href="/i/tulip_peach_blossom.jpg"&gt; &lt;img src="/i/tulip_peach_blossom_s.jpg" alt="Ballade" width="160" height="160"&gt; &lt;/a&gt; &lt;div class="desc"&gt;在此处添加对图像的描述&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 7.6.透明 图片透明 12345img&#123;opacity:0.4;filter:alpha(opacity=40); /* 针对 IE8 以及更早的版本 */&#125; 图片透明，当指针在上面不透明 12345678910img&#123;opacity:0.4;filter:alpha(opacity=40); /* 针对 IE8 以及更早的版本 */&#125;img:hover&#123;opacity:1.0;filter:alpha(opacity=100); /* 针对 IE8 以及更早的版本 */&#125; 透明框中的文本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;div.background&#123; width: 400px; height: 266px; background: url('/i/tulip_peach_blossom_w.jpg') no-repeat; border: 1px solid black;&#125;div.transbox&#123; width: 338px; height: 204px; margin:30px; background-color: #ffffff; border: 1px solid black; /* for IE */ filter:alpha(opacity=60); /* CSS3 standard */ opacity:0.6;&#125;div.transbox p&#123; margin: 30px 40px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="background"&gt;&lt;div class="transbox"&gt;&lt;p&gt;This is some text that is placed in the transparent box.This is some text that is placed in the transparent box.This is some text that is placed in the transparent box.This is some text that is placed in the transparent box.This is some text that is placed in the transparent box.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 7.7.媒介类型 允许你定义以何种媒介来提交文档。文档可以被显示在显示器、纸媒介或者听觉浏览器等等。 注释：媒介类型名称对大小写不敏感。 媒介类型 描述 all 用于所有的媒介设备。 aural 用于语音和音频合成器。 braille 用于盲人用点字法触觉回馈设备。 embossed 用于分页的盲人用点字法打印机。 handheld 用于小的手持的设备。 print 用于打印机。 projection 用于方案展示，比如幻灯片。 screen 用于电脑显示器。 tty 用于使用固定密度字母栅格的媒介，比如电传打字机和终端。 tv 用于电视机类型的设备。 12345678910111213141516171819202122232425&lt;html&gt;&lt;head&gt;&lt;!--浏览器在显示器上显示 14 像素的 Verdana 字体。但是假如页面需要被打印，将使用 10 个像素的 Times 字体。注意：font-weight 被设置为粗体，不论显示器还是纸媒介--&gt;&lt;style&gt;@media screen&#123;p.test &#123;font-family:verdana,sans-serif; font-size:14px&#125;&#125;@media print&#123;p.test &#123;font-family:times,serif; font-size:10px&#125;&#125;@media screen,print&#123;p.test &#123;font-weight:bold&#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;....&lt;/body&gt;&lt;/html&gt; 八、注意事项 避免使用Internet Explorer Behaviors：只有 Internet Explorer 支持 behavior 属性。 More info: CSS 参考手册]]></content>
      <tags>
        <tag>web</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML（三）HTML5]]></title>
    <url>%2F2016%2F07%2F15%2FHtml03%2F</url>
    <content type="text"><![CDATA[HTML5 将成为 HTML、XHTML 以及 HTML DOM 的新标准， 是 W3C 与 WHATWG 合作的结果。 本文章主要介绍 HTML5 的基本概念。 Quick Guide一、 声明123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Title of the document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Content of the document......&lt;/body&gt;&lt;/html&gt; 二、浏览器支持所有现代浏览器都支持 HTML5，都会自动把未识别元素当做行内元素来处理。但是Internet Explorer 8 以及更早的版本，不允许对未知元素添加样式，使用 HTML5 Enabling JavaScript 取解决。 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Styling HTML5&lt;/title&gt; &lt;!--[if lt IE 9]&gt; &lt;script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"&gt;&lt;/script&gt; &lt;![endif]--&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;My First Article&lt;/h1&gt;&lt;article&gt;London is the capital city of England. It is the most populous city in the United Kingdom, with a metropolitan area of over 13 million inhabitants.&lt;/article&gt;&lt;/body&gt;&lt;/html&gt; 三、语义元素 类型 示例 Empty &lt;input type=&quot;text&quot; value=&quot;John Doe&quot; disabled&gt; Unquoted &lt;input type=&quot;text&quot; value=John Doe&gt; Double-quoted &lt;input type=&quot;text&quot; value=&quot;John Doe&quot;&gt; Single-quoted &lt;input type=&quot;text&quot; value=&#39;John Doe&#39;&gt; 四、语义元素HTML5 提供了定义页面不同部分的新语义元素： 标签 描述 &lt;article&gt; 定义文档内的文章。 &lt;aside&gt; 定义页面内容之外的内容。 &lt;bdi&gt; 定义与其他文本不同的文本方向。 &lt;details&gt; 定义用户可查看或隐藏的额外细节。 &lt;dialog&gt; 定义对话框或窗口。 &lt;figcaption&gt; 定义 &lt;figure&gt; 元素的标题。 &lt;figure&gt; 定义自包含内容，比如图示、图表、照片、代码清单等等。 &lt;footer&gt; 定义文档或节的页脚。 &lt;header&gt; 定义文档或节的页眉。 &lt;main&gt; 定义文档的主内容。 &lt;mark&gt; 定义重要或强调的内容。 &lt;menuitem&gt; 定义用户能够从弹出菜单调用的命令/菜单项目。 &lt;meter&gt; 定义已知范围（尺度）内的标量测量。 &lt;nav&gt; 定义文档内的导航链接。 &lt;progress&gt; 定义任务进度。 &lt;rp&gt; 定义在不支持 ruby 注释的浏览器中显示什么。 &lt;rt&gt; 定义关于字符的解释/发音（用于东亚字体）。 &lt;ruby&gt; 定义 ruby 注释（用于东亚字体）。 &lt;section&gt; 定义文档中的节。 &lt;summary&gt; 定义 &lt;details&gt; 元素的可见标题。 &lt;time&gt; 定义日期/时间。 &lt;wbr&gt; 定义可能的折行（line-break）。 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;section&gt;&lt;h1&gt;WWF&lt;/h1&gt;&lt;p&gt;The World Wide Fund for Nature (WWF) is an international organization working on issues regarding the conservation, research and restoration of the environment, formerly named the World Wildlife Fund. WWF was founded in 1961.&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;h1&gt;WWF's Panda symbol&lt;/h1&gt;&lt;p&gt;The Panda has become the symbol of WWF. The well-known panda logo of WWF originated from a panda named Chi Chi that was transferred from the Beijing Zoo to the London Zoo in the same year of the establishment of WWF.&lt;/p&gt;&lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 五、图形 &lt;canvas&gt;：使用 JavaScript 在网页上绘制图像。 12345678910111213141516171819202122&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;canvas id="myCanvas" width="200" height="100" style="border:1px solid #c3c3c3;"&gt;Your browser does not support the canvas element.&lt;/canvas&gt;&lt;script type="text/javascript"&gt;var c=document.getElementById("myCanvas");var cxt=c.getContext("2d");cxt.fillStyle="#FF0000";cxt.beginPath();cxt.arc(70,18,15,0,Math.PI*2,true);cxt.closePath();cxt.fill();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; &lt;svg&gt;:使用 XML 描述 2D 图形的语言 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="190"&gt; &lt;polygon points="100,10 40,180 190,60 10,60 160,180" style="fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;" /&gt;&lt;/svg&gt;&lt;/body&gt;&lt;/html&gt; 六、媒体 标签 描述 &lt;audio&gt; 标签定义声音，比如音乐或其他音频流。 &lt;video&gt; 标签定义视频。 &lt;embed&gt; 标签定义嵌入的内容，比如插件。 &lt;video&gt; 标签的属性 属性 值 描述 autoplay autoplay 如果出现该属性，则视频在就绪后马上播放。 controls controls 如果出现该属性，则向用户显示控件，比如播放按钮。 height pixels 设置视频播放器的高度。 loop loop 如果出现该属性，则当媒介文件完成播放后再次开始播放。 preload preload 如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。 src url 要播放的视频的 URL。 width pixels 设置视频播放器的宽度。 &lt;audio&gt; 123456789101112&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;audio controls="controls"&gt; &lt;source src="/i/song.ogg" type="audio/ogg"&gt; &lt;source src="/i/song.mp3" type="audio/mpeg"&gt;Your browser does not support the audio element.&lt;/audio&gt;&lt;/body&gt;&lt;/html&gt; &lt;video&gt; 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;video width="320" height="240" controls="controls" autoplay="autoplay"&gt; &lt;source src="/i/movie.ogg" type="video/ogg" /&gt; &lt;source src="/i/movie.mp4" type="video/mp4" /&gt; &lt;source src="/i/movie.webm" type="video/webm" /&gt;&lt;/video&gt;&lt;/body&gt;&lt;/html&gt; 七、API地理位置getCurrentPosition():获得用户的地理位置 返回对象的属性 描述 coords.latitude 十进制数的纬度 coords.longitude 十进制数的经度 coords.accuracy 位置精度 coords.altitude 海拔，海平面以上以米计 coords.altitudeAccuracy 位置的海拔精度 coords.heading 方向，从正北开始以度计 coords.speed 速度，以米/每秒计 timestamp 响应的日期/时间 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;p id="demo"&gt;点击这个按钮，获得您的坐标：&lt;/p&gt;&lt;button onclick="getLocation()"&gt;试一下&lt;/button&gt;&lt;script&gt;var x=document.getElementById("demo");function getLocation() &#123; if (navigator.geolocation) &#123; navigator.geolocation.getCurrentPosition(showPosition,showError); &#125; else&#123;x.innerHTML="Geolocation is not supported by this browser.";&#125; &#125;function showPosition(position) &#123; x.innerHTML="Latitude: " + position.coords.latitude + "&lt;br /&gt;Longitude: " + position.coords.longitude; &#125;function showError(error) &#123; switch(error.code) &#123; case error.PERMISSION_DENIED: x.innerHTML="User denied the request for Geolocation." break; case error.POSITION_UNAVAILABLE: x.innerHTML="Location information is unavailable." break; case error.TIMEOUT: x.innerHTML="The request to get user location timed out." break; case error.UNKNOWN_ERROR: x.innerHTML="An unknown error occurred." break; &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 拖放 把元素设置为可拖放:draggable=”true” 拖放的内容:ondragstart 规定拖动什么数据。,dataTransfer.setData()设置拖动数据的数据类型和值 拖到何处:ondragover规定被拖动的数据能够被放置到何处 进行放置:ondrop 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt;#div1, #div2&#123;float:left; width:198px; height:66px; margin:10px;padding:10px;border:1px solid #aaaaaa;&#125;&lt;/style&gt;&lt;script type="text/javascript"&gt;function allowDrop(ev)&#123;ev.preventDefault();&#125;function drag(ev)&#123;ev.dataTransfer.setData("Text",ev.target.id);&#125;function drop(ev)&#123;&lt;!-- 调用 preventDefault() 来阻止数据的浏览器默认处理方式（drop 事件的默认行为是以链接形式打开） --&gt;ev.preventDefault();&lt;!-- 通过 dataTransfer.getData() 方法获得被拖的数据。该方法将返回在 setData() 方法中设置为相同类型的任何数据 --&gt;var data=ev.dataTransfer.getData("Text");&lt;!-- 被拖数据是被拖元素的 id ("drag1"),把被拖元素追加到放置元素中 --&gt;ev.target.appendChild(document.getElementById(data));&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="div1" ondrop="drop(event)" ondragover="allowDrop(event)"&gt; &lt;img src="/i/eg_dragdrop_w3school.gif" draggable="true" ondragstart="drag(event)" id="drag1" /&gt;&lt;/div&gt;&lt;div id="div2" ondrop="drop(event)" ondragover="allowDrop(event)"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 应用程序缓存HTML5 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。通过创建 cache manifest 文件，可以轻松地创建 web 应用的离线版本。 应用程序缓存为应用带来三个优势： 离线浏览 - 用户可在应用离线时使用它们 速度 - 已缓存资源加载得更快 减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。 浏览器支持：所有主流浏览器均支持应用程序缓存，除了 Internet Explorer。 样例12345678&lt;!DOCTYPE HTML&gt;&lt;html manifest="demo.appcache"&gt;&lt;body&gt;The content of the document......&lt;/body&gt;&lt;/html&gt; 请注意，manifest 文件需要配置正确的 MIME-type，即 “text/cache-manifest”。必须在 web 服务器上进行配置。 manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。manifest 文件可分为三个部分： CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存 1234CACHE MANIFEST/theme.css/logo.gif/main.js NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存 12NETWORK:login.asp 12NETWORK:* FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面） 12FALLBACK:/html5/ /404.html 更新缓存:一旦应用被缓存，它就会保持缓存直到发生下列情况 用户清空浏览器缓存 manifest 文件被修改 由程序来更新应用缓存 重要的提示：如果您编辑了一幅图片，或者修改了一个 JavaScript 函数，这些改变都不会被重新缓存。以 “#” 开头的是注释行，更新注释行中的日期和版本号是一种使浏览器重新缓存文件的办法。 Web Workers当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。 浏览器支持：所有主流浏览器均支持 web worker，除了 Internet Explorer。 1.创建 web worker 文件：demo_workers.js 12345678910var i=0;function timedCount()&#123;i=i+1;postMessage(i);setTimeout("timedCount()",500);&#125;timedCount(); 2.创建 Web Worker 对象 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;p&gt;计数: &lt;output id="result"&gt;&lt;/output&gt;&lt;/p&gt;&lt;button onclick="startWorker()"&gt;开始 Worker&lt;/button&gt; &lt;button onclick="stopWorker()"&gt;停止 Worker&lt;/button&gt;&lt;br /&gt;&lt;br /&gt;&lt;script&gt;var w;function startWorker()&#123;// 检测用户的浏览器是否支持它if(typeof(Worker)!=="undefined") &#123; if(typeof(w)=="undefined") &#123; // 创建 Web Worker 对象 w=new Worker("/example/html5/demo_workers.js"); &#125; w.onmessage = function (event) &#123; document.getElementById("result").innerHTML=event.data; &#125;; &#125;else &#123; document.getElementById("result").innerHTML="Sorry, your browser does not support Web Workers..."; &#125;&#125;// 终止 Web Workerfunction stopWorker()&#123; w.terminate();&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 服务器发送事件服务器发送事件（server-sent event）允许网页获得来自服务器的更新。 浏览器支持：所有主流浏览器均支持服务器发送事件，除了 Internet Explorer。 1.创建服务器端实例:把 “Content-Type” 报头设置为 “text/event-stream”. demo_sse.php12345678&lt;?phpheader('Content-Type: text/event-stream');header('Cache-Control: no-cache');$time = date('r');echo "data: The server time is: &#123;$time&#125;\n\n";flush();?&gt; demo_sse.asp123456&lt;%Response.ContentType=&quot;text/event-stream&quot;Response.Expires=-1Response.Write(&quot;data: &quot; &amp; now())Response.Flush()%&gt; 2.创建Server-Sent 事件12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;获得服务器更新&lt;/h1&gt;&lt;div id="result"&gt;&lt;/div&gt;&lt;script&gt;// 检测服务器发送事件的浏览器支持情况if(typeof(EventSource)!=="undefined") &#123; // 接收 Server-Sent 事件通知 var source=new EventSource("/example/html5/demo_sse.php"); source.onmessage=function(event) &#123; document.getElementById("result").innerHTML+=event.data + "&lt;br /&gt;"; &#125;; &#125;else &#123; document.getElementById("result").innerHTML="抱歉，您的浏览器不支持 server-sent 事件 ..."; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在上面的例子中，我们使用 onmessage 事件来获取消息。不过还可以使用其他事件： 事件 描述 onopen 当通往服务器的连接被打开 onmessage 当接收到消息 onerror 当错误发生 八、表单HTML 表单用于搜集不同类型的用户输入。&lt;form&gt; 元素用于定义 HTML 表单。 12345&lt;form&gt; .form elements .&lt;/form&gt; &lt;input&gt; 元素:表单 输入元素 新增类型： 类型 描述 color 设置输入类型为颜色 date 设置输入类型为日期 datetime 设置输入类型为日期和时间（有时区） datetime-local 设置输入类型为日期和时间（无时区） email 设置输入类型为邮箱，被提交时自动对电子邮件地址进行验证 month 设置输入类型为年月 number 设置输入类型为数字 range 设置输入类型为一定范围内的值，配合属性来规定限制：min、max、step、value search 设置输入类型为搜索 tel 设置输入类型为电话 time 设置输入类型为时间（无时区） url 设置输入类型为网站，提交时能够自动验证 week 设置输入类型为周和年 新增设置属性： 属性 描述 autocomplete 规定form 或 input 域的自动完成：提交表单，重新加载 autofocus 规定 页面加载时，input 域 自动地获得焦点 form 规定 input 域 所属的一个或多个表单 form overrides 规定 input 域 的表单重写属性 height and width 规定 input 域 的高度和宽度 list 规定 input 域 的的选项列表 min, max and step 规定 input 域 的最大、最小、数字间隔 multiple 规定 input 域 中可选择多个值 novalidate 规定在提交表单时不应该验证 form 或 input 域 pattern 规定检查 input 域 是否满足正则表达式。 placeholder 提供一种提示（hint），描述 input 域 所期待的值 required 规定 input 域 是必需的（必需填写）。 12345678910111213141516&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;form action="/example/html5/demo_form.asp" method="get" autocomplete="on"&gt;First name:&lt;input type="text" name="fname" /&gt;&lt;br /&gt;Last name: &lt;input type="text" name="lname" /&gt;&lt;br /&gt;E-mail: &lt;input type="email" name="email" autocomplete="off" /&gt;&lt;br /&gt;&lt;input type="submit" /&gt;&lt;/form&gt;&lt;p&gt;请填写并提交此表单，然后重载页面，来查看自动完成功能是如何工作的。&lt;/p&gt;&lt;p&gt;请注意，表单的自动完成功能是打开的，而 e-mail 域是关闭的。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 新的表单元素 标签 描述 &lt;datalist&gt; 定义输入控件的预定义选项。 &lt;keygen&gt; 定义键对生成器字段（用于表单）。 &lt;output&gt; 定义计算结果。 &lt;datalist&gt; :为 &lt;input&gt; 元素规定预定义选项列表。元素的 list 属性必须引用 &lt;datalist&gt; 元素的 id 属性。 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;form action="/demo/demo_form.asp"&gt;&lt;select name="cars"&gt;&lt;option value="volvo"&gt;Volvo&lt;/option&gt;&lt;option value="saab"&gt;Saab&lt;/option&gt;&lt;option value="fiat"&gt;Fiat&lt;/option&gt;&lt;option value="audi"&gt;Audi&lt;/option&gt;&lt;/select&gt;&lt;br&gt;&lt;br&gt;&lt;input type="submit"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; &lt;keygen &gt;:密钥对生成器（key-pair generator）。当提交表单时，会生成两个键，一个是私钥，一个公钥。私钥（private key）存储于客户端，公钥（public key）则被发送到服务器。公钥可用于之后验证用户的客户端证书（client certificate）。 123456789101112&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;form action="/example/html5/demo_form.asp" method="get"&gt;Username: &lt;input type="text" name="usr_name" /&gt;Encryption: &lt;keygen name="security" /&gt;&lt;input type="submit" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; &lt;output &gt;:用于不同类型的输出 12345678910111213141516171819202122&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;script type="text/javascript"&gt;function resCalc()&#123;numA=document.getElementById("num_a").value;numB=document.getElementById("num_b").value;document.getElementById("result").value=Number(numA)+Number(numB);&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;使用 output 元素的简易计算器：&lt;/p&gt;&lt;form onsubmit="return false"&gt; &lt;input id="num_a" /&gt; + &lt;input id="num_b" /&gt; = &lt;output id="result" onforminput="resCalc()"&gt;&lt;/output&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 九、HTML5 迁移元素切换 典型的 HTML4 典型的 HTML5 &lt;div id=&quot;header&quot;&gt; &lt;header&gt; &lt;div id=&quot;menu&quot;&gt; &lt;nav&gt; &lt;div id=&quot;content&quot;&gt; &lt;section&gt; &lt;div id=&quot;post&quot;&gt; &lt;article&gt; &lt;div id=&quot;footer&quot;&gt; &lt;footer&gt; 更改Doctype1&lt;!DOCTYPE html&gt; 更改编码1&lt;meta charset="utf-8"&gt; 添加 shiv123&lt;!--[if lt IE 9]&gt; &lt;script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"&gt;&lt;/script&gt;&lt;![endif]--&gt; 为语义元素添加 CSS代码规范 请使用正确的文档类型 请使用小写元素名 关闭所有 HTML 元素 关闭空的 HTML 元素 使用小写属性名 属性值加引号：属性值有空格需要引号 必需的属性：始终对图像使用 alt 属性 空格和等号：等号两边不要空格 避免长代码行：代码行超过 80 个字符 空行和缩进：请勿使用没有必要的空行和缩进。没有必要在短的和相关项目之间使用空行，也没有必要缩进每个元素 不推荐省略 &lt;html&gt; 和 &lt;body&gt; 标签。 &lt;title&gt;是必须的 注释规范:短注释应该在单行中书写，并在 在独立的行中书写 请使用简单的语法来链接样式表 开括号与选择器位于同一行 在开括号之前用一个空格 使用两个字符的缩进 在每个属性与其值之间使用冒号加一个空格 在每个逗号或分号之后使用空格 在每个属性值对（包括最后一个）之后使用分号 只在值包含空格时使用引号来包围值 把闭括号放在新的一行，之前不用空格 避免每行超过 80 个字符 使用简单的语法来加载外部脚本 在 HTML 中使用（与 JavaScript）相同的命名约定 使用小写文件名 文件扩展名要规范：html文件 .html; css文件 .css ;JavaScript .js]]></content>
      <tags>
        <tag>web</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML（二）XHTML]]></title>
    <url>%2F2016%2F06%2F15%2FHtml02%2F</url>
    <content type="text"><![CDATA[XHTML 是以 XML 格式编写的 HTML。XHTML 于2000年的1月26日成为 W3C 标准，W3C 将 XHTML 定义为最新的HTML版本。XHTML 将逐渐取代 HTML。本文章主要介绍 XHTML 的基本概念。 Quick Guide一、为什么要使用XHTML万维网上的许多页面都包含着糟糕的 HTML 代码，市场中存在着不同的浏览器技术，某些浏览器没有能力和手段来解释糟糕的标记语言。XML 是一种必须正确标记且格式良好的标记语言。通过结合 XML 和 HTML 的长处，开发出了 XHTML。 二、文档结构 XHTML DOCTYPE 是强制性的 &lt;html&gt; 中的 XML namespace 属性是强制性的 &lt;html&gt;、&lt;head&gt;、&lt;title&gt; 以及 &lt;body&gt; 也是强制性的 一个 XHTML 文档有三个主要的部分： DOCTYPE:文档类型声明, DTD 规定了使用通用标记语言(SGML)的网页的语法 STRICT（严格类型）: 需要干净的标记，避免表现上的混乱。请与层叠样式表配合使用。 TRANSITIONAL（过渡类型）: 当需要利用 HTML 在表现上的特性时，并且当需要为那些不支持层叠样式表的浏览器编写 XHTML 时。 FRAMESET（框架类型）: 需要使用HTML框架将浏览器窗口分割为两部分或更多框架时。 Head Body 123456789101112&lt;!-- 文档类型声明定义文档的类型 --&gt;&lt;!DOCTYPE htmlPUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;simple document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;a simple paragraph&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 三、语法元素语法 XHTML 元素必须正确嵌套 XHTML 元素必须始终关闭 XHTML 元素必须小写 XHTML 文档必须有一个根元素 XHTML DTD 定义了强制使用的 HTML 元素 属性语法 XHTML 属性必须使用小写 XHTML 属性值必须用引号包围 XHTML 属性最小化也是禁止的 用 Id 属性代替 name 属性 四、HTML升级至 XHTML 向每张页面的第一行添加 XHTML &lt;!DOCTYPE&gt; 向每张页面的 html 元素添加 xmlns 属性 把所有元素名改为小写 关闭所有空元素：&lt;hr&gt; 和 &lt;br&gt; 标签应该被替换为 &lt;hr /&gt; 和 &lt;br /&gt; 把所有属性名改为小写 为所有属性值加引号 验证站点: 通过 DTD 验证 XHTML 使用 W3C 验证器：http://validator.w3.org/check?uri=https://www.baidu.com （uri=被验证网页） 五、模块XHTML 是简单而庞大的语言。XHTML 包含了网站开发者需要的大多数功能。对于某些特殊的用途，XHTML 太大且太复杂，而对于其他的用途，它又太简单了。 通过将 XHTML 分为若干模块，W3C 已经创造出数套小巧且定义良好的 XHTML 元素，这些元素既可被独立应用于简易设备，又可以与其他 XML 标准并入大型且更复杂的应用程序。 通过使用模块化的 XHTML，产品和软件设计者可以： 选择被某种设备所支持的元素。 在不打破 XHTML 标准的情况下，使用 XML 对 XHTML 进行扩展。 针对小型设备，对 XHTML 进行简化。 通过添加新的 XML 功能（比如 MathML, SVG, 语音和多媒体），针对复杂的应用对 XHTML 进行扩展。 定义 XHTML 框架，比如 XHTML BASIC （针对移动设备的 XHTML 子集）。 W3C 已将 XHTML 的定义分为28种模型： 模块名称 描述 Applet Module (Applet模块) 定义已被废弃的applet元素。 Base Module (基础模块) 定义基本元素。 Basic Forms Module (基础表单模块) 定义基本的表单元素 (forms)。 Basic Tables Module (基础表格模块) 定义基本的表格元素 (table)。 Bi-directional Text Module (双向文本模块) 定义bdo元素。 Client Image Map Module(客户端图像映射模块) 定义浏览器端图像映射元素(image map elements)。 Edit Module (编辑模块) 定义编辑元素删除和插入。 Forms Module (表单模块) 定义所有在表单中使用的元素。 Frames Module (框架模块) 定义frameset元素。 Hypertext Module (超文本模块) 定义a元素。 Iframe Module (内联框架模块) 定义iframe元素。 Image Module (图像模块) 定义图像元素 (img)。 Intrinsic Events Module () 定义事件属性 (event)，比如onblur和onchange。 Legacy Module (遗留模块) 定义被废弃的元素和属性。 Link Module (链接模块) 定义链接 (link)元素。 List Module (列表模块) 定义列表元素ol, li, ul, dd, dt,和dl。 Metainformation Module (元信息模块) 定义meta元素。 Name Identification Module (名称识别模块) 定义已被废弃的name属性。 Object Module (对象模块) 定义对象元素 (object)和param元素。 Presentation Module (表现模块) 定义表现元素比如b和i。 Scripting Module (脚本模块) 定义脚本 (script)和无脚本 (noscript)元素。 Server Image Map Module(服务器端图像映射模块) 定义服务器端图像映射(server side image map)元素 Structure Module (结构模块) 定义以下元素：html, head, title and body。 Style Attribute Module (样式属性模块) 定义样式属性。 Style Sheet Module (样式表模块) 定义样式元素。 Tables Module (表格模块) 定义用于表格中的元素。 Target Module (Target模块) 定义target属性。 Text Module (文本模块) 定义文本容器元素 (text container)，比如p和h1。 六、标准属性核心属性以下标签不提供下面的属性：base, head, html, meta, param, script, style, 以及 title 元素。 属性 值 描述 class class_rule 或 style_rule 元素的类(class) id id_name 元素的某个特定id style 样式定义 内联样式定义 title 提示文本 显示于提示工具中的文本 语言属性 (Language Attributes)以下标签不提供下面的属性：base, br, frame, frameset, hr, iframe, param, 以及 script 元素。 属性 值 描述 dir ltr \ rtl 设置文本的方向 lang 语言代码 设置语言代码 键盘属性 (Keyboard Attributes) 属性 值 描述 accesskey 字符 设置访问某元素的键盘快捷键 tabindex 数 设置某元素的Tab次序 七、事件在现代浏览器中都内置有大量的事件处理器。这些处理器会监视特定的条件或用户行为，例如鼠标单击或浏览器窗口中完成加载某个图像。通过使用客户端的 JavaScript，可以将某些特定的事件处理器作为属性添加给特定的标签，并可以在事件发生时执行一个或多个 JavaScript 命令或函数。 事件处理器的值是一个或一系列以分号隔开的 Javascript 表达式、方法和函数调用，并用引号引起来。当事件发生时，浏览器会执行这些代码。例如，当您把鼠标移动到一个超链接时，会启动一个 JavaScript 函数。支持 JavaScript 的浏览器支持 标签中的一个特殊的 “mouse over”事件处理器 - 被称为 onmouseover 来完成这项工作： 1&lt;a href="/index.html" onmouseover="alert('Welcome');return false"&gt;&lt;/a&gt; 窗口事件 (Window Events)仅在 body 和 frameset 元素中有效。 属性 值 描述 onload 脚本 当文档被载入时执行脚本 onunload 脚本 当文档被卸下时执行脚本 表单元素事件 (Form Element Events)仅在表单元素中有效。 属性 值 描述 onchange 脚本 当元素改变时执行脚本 onsubmit 脚本 当表单被提交时执行脚本 onreset 脚本 当表单被重置时执行脚本 onselect 脚本 当元素被选取时执行脚本 onblur 脚本 当元素失去焦点时执行脚本 onfocus 脚本 当元素获得焦点时执行脚本 键盘事件 (Keyboard Events)在下列元素中无效：base, bdo, br, frame, frameset, head, html, iframe, meta, param, script, style, 以及 title 元素。 属性 值 描述 onkeydown 脚本 当键盘被按下时执行脚本 onkeypress 脚本 当键盘被按下后又松开时执行脚本 onkeyup 脚本 当键盘被松开时执行脚本 鼠标事件 (Mouse Events)在下列元素中无效：base, bdo, br, frame, frameset, head, html, iframe, meta, param, script, style, title 元素。 属性 值 描述 onclick 脚本 当鼠标被单击时执行脚本 ondblclick 脚本 当鼠标被双击时执行脚本 onmousedown 脚本 当鼠标按钮被按下时执行脚本 onmousemove 脚本 当鼠标指针移动时执行脚本 onmouseout 脚本 当鼠标指针移出某元素时执行脚本 onmouseover 脚本 当鼠标指针悬停于某元素之上时执行脚本 onmouseup 脚本 当鼠标按钮被松开时执行脚本 八、结构化 使用恰当的文档类型声明和命名空间。 使用 meta 元素声明你的内容类型。 使用小写字母书写所有的元素和属性。 为所有的属性值加引号。 为所有的属性分配值。 关闭所有的标签。 使用空格和斜线关闭空标签。 不要在注释中写双下划线。 确保小于号及和号为 &lt; 和 &amp; 为表达语义而标记文档，而不是为了样式：最大限度地使用 CSS 来进行布局 根据它们的意义使用元素，而不是根据它们的外观 使用结构化元素，而不是无意义的垃圾 ：ul、li div、id 和其他帮手]]></content>
      <tags>
        <tag>web</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML（一）HTML的基本概念]]></title>
    <url>%2F2016%2F05%2F15%2FHtml01%2F</url>
    <content type="text"><![CDATA[HTML 是一种超文本标记语言 (Hyper Text Markup Language)。本文章主要介绍 HTML 的基本概念。 Quick Guide一、HTML 标签标记语言使用标记标签(markup tag)来描述网页 。HTML 标记标签通常被称为 HTML 标签 (HTML tag)。 HTML 标签是由尖括号包围的关键词，比如 &lt;html&gt; HTML 标签通常是成对出现的，比如 &lt;b&gt; 和 &lt;/b&gt; 标签对中的第一个标签是开始标签，第二个标签是结束标签 开始和结束标签也被称为开放标签和闭合标签 HTML 标签对大小写不敏感 ，万维网联盟（W3C）在 HTML 4 中推荐使用小写，而在未来 (X)HTML 版本中强制使用小写。 HTML 标签参考手册 1.HTML 的 基本标签 1.HTML 标题（Heading）：是通过 &lt;h1&gt; - &lt;h6&gt; 等标签进行定义的。 123&lt;h1&gt;This is a heading&lt;/h1&gt;&lt;h2&gt;This is a heading&lt;/h2&gt;&lt;h3&gt;This is a heading&lt;/h3&gt; 2.HTML 段落:通过 &lt;p&gt; 标签进行定义的。 12&lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;p&gt;This is another paragraph.&lt;/p&gt; 3.HTML 链接:通过 &lt;a&gt; 标签进行定义的。在 href 属性中指定链接的地址。 1&lt;a href="https://www.baidu.com/"&gt;This is a link&lt;/a&gt; 4.HTML 图像:通过 &lt;img&gt; 标签进行定义的。图像的名称和尺寸是以属性的形式提供的。 1&lt;img src="w3school.jpg" width="104" height="142" /&gt; 2.HTML 标题标签 标签 描述 &lt;html&gt; 定义 HTML 文档。 &lt;body&gt; 定义文档的主体。 &lt;h1&gt; to &lt;h6&gt; 定义 HTML 标题 &lt;hr&gt; 定义水平线。 &lt;!--&gt; 定义注释。 1234567891011121314&lt;html&gt;&lt;body&gt;&lt;!-- &lt;h1&gt; 定义最大的标题。&lt;h6&gt; 定义最小的标题 --&gt;&lt;h1&gt;This is a heading&lt;/h1&gt;&lt;!-- 水平线--&gt;&lt;hr /&gt;&lt;!--[if IE 8]&gt; .... 只有 Internet Explorer 显示注释....&lt;![endif]--&gt;&lt;h2&gt;This is a heading&lt;/h2&gt;&lt;h3&gt;This is a heading&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 3.HTML 段落标签 标签 描述 &lt;p&gt; 定义段落。 &lt;br /&gt; 插入单个折行（换行）。 12345678&lt;html&gt;&lt;body&gt;&lt;h1&gt;我的第一个标题&lt;/h1&gt;&lt;p&gt;我的第一个段落。&lt;/p&gt;&lt;br /&gt;&lt;p&gt;我的第一个段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 4.HTML 格式化标签 文本格式化 标签 描述 &lt;b&gt; 定义粗体文本。 &lt;big&gt; 定义大号字。 &lt;em&gt; 定义着重文字。 &lt;i&gt; 定义斜体字。 &lt;small&gt; 定义小号字。 &lt;strong&gt; 定义加重语气。 &lt;sub&gt; 定义下标字。 &lt;sup&gt; 定义上标字。 &lt;ins&gt; 定义插入字。 &lt;del&gt; 定义删除字。 12345678910111213141516171819202122232425262728293031323334353637&lt;html&gt;&lt;body&gt;&lt;b&gt;This text is bold&lt;/b&gt;&lt;br /&gt;&lt;strong&gt;This text is strong&lt;/strong&gt;&lt;br /&gt;&lt;big&gt;This text is big&lt;/big&gt;&lt;br /&gt;&lt;em&gt;This text is emphasized&lt;/em&gt;&lt;br /&gt;&lt;i&gt;This text is italic&lt;/i&gt;&lt;br /&gt;&lt;small&gt;This text is small&lt;/small&gt;&lt;br /&gt;This text contains&lt;sub&gt;subscript&lt;/sub&gt;&lt;br /&gt;This text contains&lt;sup&gt;superscript&lt;/sup&gt;&lt;/body&gt;&lt;/html&gt; 计算机输出 标签 描述 &lt;code&gt; 定义计算机代码。 &lt;kbd&gt; 定义键盘码。 &lt;samp&gt; 定义计算机代码样本。 &lt;tt&gt; 定义打字机代码。 &lt;var&gt; 定义变量。 &lt;pre&gt; 定义预格式文本。 1234567891011121314151617181920212223242526272829&lt;html&gt;&lt;body&gt;&lt;code&gt;&lt;pre&gt;var person = &#123; firstName:"Bill", lastName:"Gates", age:50, eyeColor:"blue"&#125;&lt;/pre&gt;&lt;/code&gt;&lt;br /&gt;&lt;kbd&gt;Keyboard input&lt;/kbd&gt;&lt;br /&gt;&lt;tt&gt;Teletype text&lt;/tt&gt;&lt;br /&gt;&lt;samp&gt;Sample text&lt;/samp&gt;&lt;br /&gt;&lt;var&gt;Computer variable&lt;/var&gt;&lt;br /&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;这些标签常用于显示计算机/编程代码。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 引用、引用和术语定义 标签 描述 &lt;abbr&gt; 定义缩写。 &lt;acronym&gt; 定义首字母缩写。 &lt;address&gt; 定义地址。 &lt;bdo&gt; 定义文字方向。 &lt;blockquote&gt; 定义长的引用。 &lt;q&gt; 定义短的引用语。 &lt;cite&gt; 定义引用、引证。 &lt;dfn&gt; 定义一个定义项目。 123456789101112131415161718192021222324252627282930313233343536&lt;html&gt;&lt;body&gt;&lt;p&gt;WWF 的目标是：&lt;q&gt;构建人与自然和谐共存的世界。&lt;/q&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;以下内容引用自 WWF 的网站：&lt;/p&gt;&lt;blockquote cite="http://www.worldwildlife.org/who/index.html"&gt;五十年来，WWF 一直致力于保护自然界的未来。世界领先的环保组织，WWF 工作于 100 个国家，并得到美国一百二十万会员及全球近五百万会员的支持。&lt;/blockquote&gt;&lt;br /&gt;&lt;p&gt;&lt;abbr title="World Health Organization"&gt;WHO&lt;/abbr&gt; 成立于 1948 年。&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&lt;dfn&gt;&lt;abbr title="World Health Organization"&gt;WHO&lt;/abbr&gt;&lt;/dfn&gt; 成立于 1948 年。&lt;/p&gt;&lt;br /&gt; &lt;address&gt;Written by Donald Duck.&lt;br&gt; Visit us at:&lt;br&gt;Example.com&lt;br&gt;Box 564, Disneyland&lt;br&gt;USA&lt;/address&gt;&lt;br /&gt;&lt;p&gt;&lt;cite&gt;The Scream&lt;/cite&gt; by Edward Munch. Painted in 1893.&lt;/p&gt;&lt;br /&gt;&lt;bdo dir="rtl"&gt;This text will be written from right to left&lt;/bdo&gt;&lt;/body&gt;&lt;/html&gt; 5.HTML 链接标签 标签 描述 href 定义锚。 HTML 使用超级链接与网络上的另一个文档相连，点击链接可以从一张页面跳转到另一张页面。有两种使用 标签的方式： 通过使用 href 属性 - 创建指向另一个文档的链接 1&lt;a href="https://www.baidu.com/"&gt;百度一下&lt;/a&gt; 通过使用 name 属性 - 创建文档内的书签 1&lt;a name="tips"&gt;基本的注意事项&lt;/a&gt; 6.HTML 图像标签 标签 描述 &lt;img&gt; 定义图像。 &lt;map&gt; 定义图像地图。 &lt;area&gt; 定义图像地图中的可点击区域。 通过使用 HTML，可以在文档中显示图像。 1234567&lt;img src="planets.jpg" border="0" usemap="#planetmap" alt="Planets" /&gt;&lt;map name="planetmap" id="planetmap"&gt; &lt;area shape="circle" coords="180,139,14" href ="venus.html" alt="Venus" /&gt; &lt;area shape="circle" coords="129,161,10" href ="mercur.html" alt="Mercury" /&gt; &lt;area shape="rect" coords="0,0,110,260" href ="sun.html" alt="Sun" /&gt;&lt;/map&gt; HTML 文件路径 路径 描述 &lt;img src=&quot;picture.jpg&quot;&gt; picture.jpg 位于与当前网页相同的文件夹 &lt;img src=&quot;images/picture.jpg&quot;&gt; picture.jpg 位于当前文件夹的 images 文件夹中 &lt;img src=&quot;/images/picture.jpg&quot;&gt; picture.jpg 当前站点根目录的 images 文件夹中 &lt;img src=&quot;../picture.jpg&quot;&gt; picture.jpg 位于当前文件夹的上一级文件夹中 7.HTML表格 标签 表格 描述 &lt;table&gt; 定义表格 &lt;caption&gt; 定义表格标题。 &lt;th&gt; 定义表格的表头。 &lt;tr&gt; 定义表格的行。 &lt;td&gt; 定义表格单元。 &lt;thead&gt; 定义表格的页眉。 &lt;tbody&gt; 定义表格的主体。 &lt;tfoot&gt; 定义表格的页脚。 &lt;col&gt; 定义用于表格列的属性。 &lt;colgroup&gt; 定义表格列的组。 12345678910111213141516171819202122232425262728293031323334&lt;html&gt;&lt;body&gt;&lt;table border="1"&gt;&lt;caption&gt;横跨两列的单元格&lt;/caption&gt;&lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th colspan="2"&gt;电话&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;Bill Gates&lt;/td&gt; &lt;td&gt;555 77 854&lt;/td&gt; &lt;td&gt;555 77 855&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;br/&gt;&lt;table border="1"&gt;&lt;caption&gt;横跨两行的单元格&lt;/caption&gt;&lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;td&gt;Bill Gates&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;th rowspan="2"&gt;电话&lt;/th&gt; &lt;td&gt;555 77 854&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;555 77 855&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 8.HTML 列表标签 标签 描述 &lt;ol&gt; 定义有序列表。 &lt;ul&gt; 定义无序列表。 &lt;li&gt; 定义列表项。 &lt;dl&gt; 定义定义列表。 &lt;dt&gt; 定义定义项目。 &lt;dd&gt; 定义定义的描述。 无序列表：始于 &lt;ul&gt; 标签，每个列表项始于 &lt;li&gt;。 1234&lt;ul&gt;&lt;li&gt;Coffee&lt;/li&gt;&lt;li&gt;Milk&lt;/li&gt;&lt;/ul&gt; 有序列表:始于 &lt;ol&gt; 标签,每个列表项始于 &lt;li&gt; 标签。 1234&lt;ol&gt;&lt;li&gt;Coffee&lt;/li&gt;&lt;li&gt;Milk&lt;/li&gt;&lt;/ol&gt; 二、HTML 元素HTML 元素是由 HTML 标签 和 纯文本 构成。HTML 元素：是从开始标签（start tag 或者叫做 开放标签（opening tag） ）到结束标签（end tag 或者叫做 闭合标签（closing tag） ）的所有代码。 开始标签 元素内容 结束标签 &lt;p&gt; This is a paragraph &lt;/p&gt; &lt;a href=&quot;default.htm&quot; &gt; This is a link &lt;/a&gt; &lt;br /&gt; 三、HTML 文档HTML 文档是由嵌套的 HTML 元素构成，用来描述网页。Web 浏览器的作用是读取 HTML 文档，并以网页的形式显示出它们。 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Title of the document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;The content of the document......&lt;/body&gt;&lt;/html&gt; HTML 文档类型&lt;!DOCTYPE&gt; 声明帮助浏览器正确地显示网页。 HTML5 1&lt;!DOCTYPE html&gt; HTML 4.01 12&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd"&gt; XHTML 1.0 12&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; HTML 头部元素 标签 描述 &lt;head&gt; 定义关于文档的信息。 title 定义文档标题。 base 定义页面上所有链接的默认地址或默认目标。 link 定义文档与外部资源之间的关系。 &lt;meta&gt; 定义关于 HTML 文档的元数据。 &lt;script&gt; 定义客户端脚本。 &lt;style&gt; 定义文档的样式信息。 四、HTML 编写网页选择合适的编辑器 文本编辑器 Notepad (PC) TextEdit (Mac) 专业的 HTML 编辑器 Adobe Dreamweaver Microsoft Expression Web CoffeeCup HTML Editor 遍写步骤 1.启动编辑器 2.在编辑器中键入 HTML 代码，如下： 1234567&lt;!DOCTYPE HTML&gt; &lt;html&gt;&lt;body&gt;&lt;h1&gt;我的第一个标题&lt;/h1&gt;&lt;p&gt;我的第一个段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 3.保存为HTML文件(后缀为 .htm 或者 .html ) 4.在浏览器中运行这个 HTML 文件 五、HTML 属性HTML 标签拥有属性。属性提供了有关 HTML 元素的更多信息。属性总是以名称/值对的形式出现，比如：name=”value”。属性总是在 HTML 元素的开始标签中规定。 例如：1&lt;a href="http://www.baidu.com"&gt;This is a link&lt;/a&gt; HTML 标准属性参考手册 六、HTML 样式 标签 描述 &lt;style&gt; 定义样式定义。 &lt;link&gt; 定义资源引用。 定义HTML 元素的样式: style 属性(内联样式) 123456789&lt;html&gt;&lt;!--background-color 属性为元素定义了背景颜色 --&gt;&lt;body style="background-color:yellow"&gt;&lt;!-- text-align 属性规定了元素中文本的水平对齐方式 --&gt;&lt;h1 style="text-align:center"&gt;This is a heading&lt;/h1&gt;&lt;!--font-family、color 以及 font-size 属性分别定义元素中文本的字体系列、颜色和字体尺寸--&gt;&lt;p style="font-family:arial;color:red;font-size:20px;"&gt;A paragraph.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 独立的样式表中（CSS 文件） 外部样式表123&lt;head&gt;&lt;link rel="stylesheet" type="text/css" href="mystyle.css"&gt;&lt;/head&gt; - 内部样式表 1234567&lt;head&gt;&lt;style type="text/css"&gt;body &#123;background-color: red&#125;p &#123;margin-left: 20px&#125;&lt;/style&gt;&lt;/head&gt; HTML 类对 HTML 块级元素 进行分类（设置类），使我们能够为元素的类定义 CSS 样式。 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;.cities &#123; background-color:black; color:white; margin:20px; padding:20px;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="cities"&gt;&lt;h2&gt;London&lt;/h2&gt;&lt;p&gt;London is the capital city of England. It is the most populous city in the United Kingdom, with a metropolitan area of over 13 million inhabitants.&lt;/p&gt;&lt;/div&gt;&lt;div class="cities"&gt;&lt;h2&gt;Paris&lt;/h2&gt;&lt;p&gt;Paris is the capital and most populous city of France.&lt;/p&gt;&lt;/div&gt;&lt;div class="cities"&gt;&lt;h2&gt;Tokyo&lt;/h2&gt;&lt;p&gt;Tokyo is the capital of Japan, the center of the Greater Tokyo Area,and the most populous metropolitan area in the world.&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 分类行内元素：例如设置 &lt;span&gt; 元素的类，能够为相同的 &lt;span&gt; 元素设置相同的样式。 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; span.red &#123;color:red;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;My &lt;span class="red"&gt;Important&lt;/span&gt; Heading&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; HTML 颜色可以通过颜色值和颜色名设置 颜色值：由红色、绿色和蓝色的值组成（RGB） Color Color HEX Color RGB 黑色 #000000 rgb(0,0,0) 红色 #FF0000 rgb(255,0,0) 绿色 #00FF00 rgb(0,255,0) 蓝色 #0000FF rgb(0,0,255) 黄色 #FFFF00 rgb(255,255,0) 浅蓝色 #00FFFF rgb(0,255,255) 紫色 #FF00FF rgb(255,0,255) 灰色 #C0C0C0 rgb(192,192,192) 白色 #FFFFFF rgb(255,255,255) 颜色名：仅仅有 16 种颜色名被 W3C 的 HTML4.0 标准所支持。它们是：aqua, black, blue, fuchsia, gray, green, lime, maroon, navy, olive, purple, red, silver, teal, white, yellow。如果需要使用其它的颜色，需要使用十六进制的颜色值。 Color Color HEX Color Name 爱丽丝蓝 #F0F8FF AliceBlue 古董白 #FAEBD7 AntiqueWhite 蓝晶 #7FFFD4 Aquamarine 黑色 #000000 Black 蓝色 #0000FF Blue 紫罗兰 #8A2BE2 BlueViolet 棕色 #A52A2A Brown 颜色列表 七、HTML 布局HTML 块 标签 描述 &lt;div&gt; 定义文档中的分区或节（division/section）。 &lt;span&gt; 定义 span，用来组合文档中的行内元素。 &lt;div&gt; 元素:块级元素，它是可用于组合其他 HTML 元素的容器。用途是文档布局,如果与 CSS 一同使用，可用于对大的内容块设置样式属性。 &lt;span&gt; 元素:内联元素，可用作文本的容器。与 CSS 一同使用时，可用于为部分文本设置样式属性。 HTML5 语义元素 语义元素 说明 header 定义文档或节的页眉 nav 定义导航链接的容器 section 定义文档中的节 article 定义独立的自包含文章 aside 定义内容之外的内容（比如侧栏） footer 定义文档或节的页脚 details 定义额外的细节 summary 定义 details 元素的标题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;#header &#123; background-color:black; color:white; text-align:center; padding:5px;&#125;#nav &#123; line-height:30px; background-color:#eeeeee; height:300px; width:100px; float:left; padding:5px; &#125;#section &#123; width:350px; float:left; padding:10px; &#125;#footer &#123; background-color:black; color:white; clear:both; text-align:center; padding:5px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="header"&gt;&lt;h1&gt;The Title&lt;/h1&gt;&lt;/div&gt;&lt;div id="nav"&gt;File&lt;br&gt;View&lt;br&gt;Help&lt;br&gt;&lt;/div&gt;&lt;div id="section"&gt;&lt;h2&gt;Hello World&lt;/h2&gt;&lt;/div&gt;&lt;div id="footer"&gt;GoodBye&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 使用表格的 HTML 布局123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;table.lamp &#123; width:100%; border:1px solid #d4d4d4;&#125;table.lamp th, td &#123; padding:10px;&#125;table.lamp th &#123; width:40px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;table class="lamp"&gt;&lt;tr&gt; &lt;th&gt; &lt;img src="/images/lamp.jpg" alt="Note" style="height:32px;width:32px"&gt; &lt;/th&gt; &lt;td&gt; The table element was not designed to be a layout tool. &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 八、HTML 响应式 Web 设计 RWD 指的是响应式 Web 设计（Responsive Web Design） RWD 能够以可变尺寸传递网页 RWD 对于平板和移动设备是必需的 自定义1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang="en-US"&gt;&lt;head&gt;&lt;style&gt;.city &#123;float: left;margin: 5px;padding: 15px;width: 300px;height: 300px;border: 1px solid black;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;W3School Demo&lt;/h1&gt;&lt;h2&gt;Resize this responsive page!&lt;/h2&gt;&lt;br&gt;&lt;div class="city"&gt;&lt;h2&gt;London&lt;/h2&gt;&lt;p&gt;London is the capital city of England.&lt;/p&gt;&lt;p&gt;It is the most populous city in the United Kingdom,with a metropolitan area of over 13 million inhabitants.&lt;/p&gt;&lt;/div&gt;&lt;div class="city"&gt;&lt;h2&gt;Paris&lt;/h2&gt;&lt;p&gt;Paris is the capital and most populous city of France.&lt;/p&gt;&lt;/div&gt;&lt;div class="city"&gt;&lt;h2&gt;Tokyo&lt;/h2&gt;&lt;p&gt;Tokyo is the capital of Japan, the center of the Greater Tokyo Area,and the most populous metropolitan area in the world.&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 使用 BootstrapBootstrap 是最流行的开发响应式 web 的 HTML, CSS, 和 JS 框架。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt;&lt;div class="jumbotron"&gt; &lt;h1&gt;W3School Demo&lt;/h1&gt; &lt;p&gt;Resize this responsive page!&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="container"&gt;&lt;div class="row"&gt; &lt;div class="col-md-4"&gt; &lt;h2&gt;London&lt;/h2&gt; &lt;p&gt;London is the capital city of England.&lt;/p&gt; &lt;p&gt;It is the most populous city in the United Kingdom, with a metropolitan area of over 13 million inhabitants.&lt;/p&gt; &lt;/div&gt; &lt;div class="col-md-4"&gt; &lt;h2&gt;Paris&lt;/h2&gt; &lt;p&gt;Paris is the capital and most populous city of France.&lt;/p&gt; &lt;/div&gt; &lt;div class="col-md-4"&gt; &lt;h2&gt;Tokyo&lt;/h2&gt; &lt;p&gt;Tokyo is the capital of Japan, the center of the Greater Tokyo Area, and the most populous metropolitan area in the world.&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 九、HTML 框架HTML Frameset通过使用框架，你可以在同一个浏览器窗口中显示不止一个页面。每份HTML文档称为一个框架，并且每个框架都独立于其他的框架。 使用框架的坏处： 开发人员必须同时跟踪更多的HTML文档 很难打印整张页面 框架结构标签（&lt;frameset&gt;）框架结构标签（&lt;frameset&gt;）定义如何将窗口分割为框架,每个 frameset 定义了一系列行或列,rows/columns 的值规定了每行或每列占据屏幕的面积. 竖直框架 123456789101112&lt;html&gt;&lt;frameset cols="25%,50%,25%"&gt; &lt;frame src="/example/html/frame_a.html"&gt; &lt;frame src="/example/html/frame_b.html"&gt; &lt;frame src="/example/html/frame_c.html"&gt;&lt;noframes&gt;&lt;body&gt;您的浏览器无法处理框架！&lt;/body&gt;&lt;/noframes&gt;&lt;/frameset&gt;&lt;/html&gt; 水平框架 123456789&lt;html&gt;&lt;frameset rows="25%,50%,25%"&gt; &lt;frame src="/example/html/frame_a.html"&gt; &lt;frame src="/example/html/frame_b.html"&gt; &lt;frame src="/example/html/frame_c.html"&gt;&lt;/frameset&gt;&lt;/html&gt; HTML Iframeiframe 用于在网页内显示网页。 设置高度和宽度 1&lt;iframe src=&quot;demo_iframe.htm&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/iframe&gt; 删除边框 1&lt;iframe src=&quot;demo_iframe.htm&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt; 可用作链接的目标 12&lt;iframe src=&quot;demo_iframe.htm&quot; name=&quot;iframe_a&quot;&gt;&lt;/iframe&gt;&lt;p&gt;&lt;a href=&quot;http://www.baidu.com&quot; target=&quot;iframe_a&quot;&gt;baidu&lt;/a&gt;&lt;/p&gt; 十、HTML 脚本&lt;script&gt; 标签用于定义客户端脚本，比如 JavaScript。script 元素既可包含脚本语句，也可通过 src 属性指向外部脚本文件。必需的 type 属性规定脚本的 MIME 类型。 JavaScript 最常用于图片操作、表单验证以及内容动态更新。 标签 描述 &lt;script&gt; 定义客户端脚本。 &lt;noscript&gt; 为不支持客户端脚本的浏览器定义替代内容。 下面的脚本会向浏览器输出“Hello World!”： 12345678&lt;html&gt;&lt;body&gt;&lt;script type="text/javascript"&gt;document.write("Hello World!")&lt;/script&gt;&lt;noscript&gt;Your browser does not support JavaScript!&lt;/noscript&gt;&lt;/body&gt;&lt;/html&gt; 十一、HTML 转换HTML 字符实体HTML 中的预留字符要在页面展示，必须被替换为字符实体。 注释：实体名称对大小写敏感！ 显示结果 描述 实体名称 实体编号 空格 &nbsp; &#160; &lt; 小于号 &lt; &#60; &gt; 大于号 &gt; &#62; &amp; 和号 &amp; &#38; “ 引号 &quot; &#34; ‘ 撇号 &apos; (IE不支持) &#39; ￠ 分（cent） &cent; &#162; £ 镑（pound） &pound; &#163; ¥ 元（yen） &yen; &#165; € 欧元（euro） &euro; &#8364; § 小节 &sect; &#167; © 版权（copyright） &copy; &#169; ® 注册商标 &reg; &#174; ™ 商标 &trade; &#8482; × 乘号 &times; &#215; ÷ 除号 &divide; &#247; HTML 实体符号参考手册 HTML URLURL（Uniform Resource Locator,统一资源定位器） 也被称为网址。 1scheme://host.domain:port/path/filename 解释： scheme - 定义因特网服务的类型。最常见的类型是 http host - 定义域主机（http 的默认主机是 www） domain - 定义因特网域名，比如 w3school.com.cn :port - 定义主机上的端口号（http 的默认端口号是 80） path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。 filename - 定义文档/资源的名称 以下是其中一些最流行的 scheme： Scheme 访问 用于… http 超文本传输协议 以 http:// 开头的普通网页。不加密。 https 安全超文本传输协议 安全网页。加密所有信息交换。 ftp 文件传输协议 用于将文件下载或上传至网站。 file 您计算机上的文件。 URL 编码：URL 只能使用 ASCII 字符集来通过因特网进行发送。ASCII 集合之外的字符，使用 “%” 其后跟随两位的十六进制数来替换。URL 不能包含空格。URL 编码通常使用 + 来替换空格。 字符 URL 编码 € %80 £ %A3 © %A9 ® %AE À %C0 Á %C1 Â %C2 Ã %C3 Ä %C4 Å %C5 URL 编码参考手册。 十二、HTML 表单HTML 表单用于搜集不同类型的用户输入。 元素用于定义 HTML 表单。 12345&lt;form&gt; .form elements .&lt;/form&gt; &lt;input&gt; 元素:表单 输入元素 使用的类型： 类型 描述 text 定义常规文本输入。 password 密码字段,加密显示 radio 定义单选按钮输入（选择多个选择之一） checkbox 定义复选框 submit 定义提交按钮（提交表单） button 定义按钮 设置属性：| 属性 | 描述 || :——– | :——————————— || disabled | 规定输入字段应该被禁用。 || maxlength | 规定输入字段的最大字符数。 || readonly | 规定输入字段为只读（无法修改）。 || size | 规定输入字段的宽度（以字符计）。 || value | 规定输入字段的默认值。 | 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;form&gt;name:&lt;br&gt;&lt;input type="text" name="name"&gt;&lt;br&gt;&lt;input type="radio" name="sex" value="male" checked&gt;Male&lt;br&gt;&lt;input type="radio" name="sex" value="female"&gt;Female&lt;br&gt;&lt;input type="submit" value="Submit"&gt;&lt;/form&gt; &lt;p&gt;请注意表单本身是不可见的。&lt;/p&gt;&lt;p&gt;同时请注意文本字段的默认宽度是 20 个字符。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; &lt;select&gt;:下拉列表 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;form action="/demo/demo_form.asp"&gt;&lt;select name="cars"&gt;&lt;option value="volvo"&gt;Volvo&lt;/option&gt;&lt;option value="saab"&gt;Saab&lt;/option&gt;&lt;option value="fiat"&gt;Fiat&lt;/option&gt;&lt;option value="audi"&gt;Audi&lt;/option&gt;&lt;/select&gt;&lt;br&gt;&lt;/br&gt;&lt;input type="submit"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; &lt;textarea&gt;: 定义多行输入字段（文本域） 12345678910111213&lt;html&gt;&lt;body&gt;&lt;form&gt;&lt;textarea name="message" rows="10" cols="30"&gt;The cat was playing in the garden.&lt;/textarea&gt;&lt;br&gt;&lt;br&gt;&lt;input type="submit"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; &lt;button&gt;:定义可点击的按钮12345678&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;button type="button" onclick="alert('Hello World!')"&gt;点击我！&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 十三、HTML媒体Web 上的多媒体指的是音效、音乐、视频和动画。 视频格式 格式 文件 描述 AVI .avi AVI (Audio Video Interleave) 格式是由微软开发的。所有运行 Windows 的计算机都支持 AVI 格式。它是因特网上很常见的格式，但非 Windows 计算机并不总是能够播放。 WMV .wmv Windows Media 格式是由微软开发的。Windows Media 在因特网上很常见，但是如果未安装额外的（免费）组件，就无法播放 Windows Media 电影。一些后期的 Windows Media 电影在所有非 Windows 计算机上都无法播放，因为没有合适的播放器。 MPEG .mpg.mpeg MPEG (Moving Pictures Expert Group) 格式是因特网上最流行的格式。它是跨平台的，得到了所有最流行的浏览器的支持。 QuickTime .mov QuickTime 格式是由苹果公司开发的。QuickTime 是因特网上常见的格式，但是 QuickTime 电影不能在没有安装额外的（免费）组件的 Windows 计算机上播放。 RealVideo .rm.ram RealVideo 格式是由 Real Media 针对因特网开发的。该格式允许低带宽条件下（在线视频、网络电视）的视频流。由于是低带宽优先的，质量常会降低。 Flash .swf.flv Flash (Shockwave) 格式是由 Macromedia 开发的。Shockwave 格式需要额外的组件来播放。但是该组件会预装到 Firefox 或 IE 之类的浏览器上。 Mpeg-4 .mp4 Mpeg-4 (with H.264 video compression) 是一种针对因特网的新格式。事实上，YouTube 推荐使用 MP4。YouTube 接收多种格式，然后全部转换为 .flv 或 .mp4 以供分发。越来越多的视频发布者转到 MP4，将其作为 Flash 播放器和 HTML5 的因特网共享格式。 声音格式 格式 文件 描述 MIDI .mid.midi MIDI (Musical Instrument Digital Interface) 是一种针对电子音乐设备（比如合成器和声卡）的格式。MIDI 文件不含有声音，但包含可被电子产品（比如声卡）播放的数字音乐指令。因为 MIDI 格式仅包含指令，所以 MIDI 文件极其小巧。上面的例子只有 23k 的大小，但却能播放将近 5 分钟。MIDI 得到了广泛的平台上的大量软件的支持。大多数流行的网络浏览器都支持 MIDI。 RealAudio .rm.ram RealAudio 格式是由 Real Media 针对因特网开发的。该格式也支持视频。该格式允许低带宽条件下的音频流（在线音乐、网络音乐）。由于是低带宽优先的，质量常会降低。 Wave .wav Wave (waveform) 格式是由 IBM 和微软开发的。所有运行 Windows 的计算机和所有网络浏览器（除了 Google Chrome）都支持它。 WMA .wma WMA 格式 (Windows Media Audio)，质量优于 MP3，兼容大多数播放器，除了 iPod。WMA 文件可作为连续的数据流来传输，这使它对于网络电台或在线音乐很实用。 MP3 .mp3.mpga MP3 文件实际上是 MPEG 文件的声音部分。MPEG 格式最初是由运动图像专家组开发的。MP3 是其中最受欢迎的针对音乐的声音格式。期待未来的软件系统都支持它。 如何播放 标签 描述 &lt;applet&gt; 不赞成。定义内嵌 applet。 &lt;embed&gt; HTML4 中不赞成，HTML5 中允许。定义内嵌对象。 &lt;object&gt; 定义内嵌对象。 &lt;param&gt; 定义对象的参数。 &lt;object&gt;:使用辅助程序 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;object width="420" height="360" classid="clsid:02BF25D5-8C17-4B23-BC80-D3488ABDDC6B" codebase="http://www.apple.com/qtactivex/qtplugin.cab"&gt;&lt;param name="src" value="/i/bird.wav" /&gt;&lt;param name="controller" value="true" /&gt;&lt;/object&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;object width="400" height="40"classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000"codebase="http://fpdownload.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=8,0,0,0"&gt;&lt;param name="SRC" value="bookmark.swf"&gt;&lt;embed src="/i/bookmark.swf"&gt;&lt;/embed&gt;&lt;/object&gt;&lt;/body&gt;&lt;/html&gt; &lt;embed&gt;：定义外部（非 HTML）内容的容器 123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;embed height="100" width="100" src="/i/horse.mp3"&gt;&lt;/embed&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;浏览器可能需要安装插件以后，才能播放该文件。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; &lt;herf&gt;:也可以使用超链接,配合js脚本或者辅助应用程序 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;p&gt;&lt;a href="/i/song.mp3"&gt;播放 mp3&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="/i/bird.wav"&gt;播放 wav&lt;/a&gt;&lt;/p&gt;&lt;script type="text/javascript" src="http://mediaplayer.yahoo.com/js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; More info: HTML 速查手册HTML 参考手册]]></content>
      <tags>
        <tag>web</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部署GitLab]]></title>
    <url>%2F2016%2F04%2F21%2F%E9%83%A8%E7%BD%B2GitLab%2F</url>
    <content type="text"><![CDATA[GitLab是利用 Ruby on Rails 一个开源的版本管理系统，实现一个自托管的Git项目仓库，可通过Web界面进行访问公开的或者私人项目,适合大规模。文章介绍在Centos7.5环境下搭建GitLab。 Quick Guide前置 1.配置需求(官方配置推荐2C8G,硬盘至少有 5-10 GB) 2.系统防火墙中打开HTTP和SSH访问 12345sudo yum install -y curl policycoreutils-python openssh-serversudo systemctl enable sshdsudo systemctl start sshdsudo firewall-cmd --permanent --add-service=httpsudo systemctl reload firewalld 3.安装Postfix以发送通知电子邮件 123sudo yum install postfixsudo systemctl enable postfixsudo systemctl start postfix 安装 1.添加GitLab包存储库 1curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.rpm.sh | sudo bash 2.设置GitLab实例的URL 1sudo EXTERNAL_URL="http://&lt;server_ip:port&gt;" yum install -y gitlab-ee 3.启动并查看 12sudo gitlab-ctl reconfiguresudo gitlab-ctl status 4.用浏览器访问刚才配置的gitlab中的EXTERNAL_URL 5.设置新密码,用root用户和新密码登录 常用命令12345678910sudo gitlab-ctl start # 启动sudo gitlab-ctl stop # 停止sudo gitlab-ctl status # 查看状态sudo gitlab-ctl restart # 重启sudo gitlab-ctl reconfigure # 修改后直接编译启动sudo vim /etc/gitlab/gitlab.rb # 修改默认的配置文件gitlab-rake gitlab:check SANITIZE=true --trace # 检查gitlabsudo gitlab-ctl tail # 查看所有日志sudo gitlab-ctl tail nginx/gitlab_access.log # 查看nginx访问日志cat /opt/gitlab/embedded/service/gitlab-rails/VERSION # 查看gitlab版本 服务构成 nginx：静态Web服务器 gitlab-shell：用于处理Git命令和修改authorized keys列表 gitlab-workhorse:轻量级的反向代理服务器 logrotate：日志文件管理工具 postgresql：数据库 redis：缓存数据库 sidekiq：用于在后台执行队列任务（异步执行） unicorn：An HTTP server for Rack applications，GitLab Rails应用是托管在这个服务器上面的。 卸载GitLab 1.停止GitLab 1sudo gitlab-ctl stop 2.停止GitLab 1sudo rpm -e gitlab-ee 3.查看进程 1ps aux | grep gitlab|grep service 4.停止进程 12kill -9 &lt;查看到的进程PID&gt;ps aux | grep gitlab|grep service # 检查进程 5.删除所有包含gitlab文件 1find / -name gitlab | xargs rm -rf Docker方式安装 1.下拉镜像 1docker pull gitlab/gitlab-ce:latest 2.启动容器 123456sudo docker run --detach \--hostname &lt;server_ip&gt; \--publish 444:443 --publish 8880:80 --publish 2222:22 \--name gitlab \--restart always \gitlab/gitlab-ce:latest 3.用浏览器访问http://&lt;server_ip&gt;:8880,使用root登录配置,可以参考官方文档 问题 1.错误信息为:GitLab is taking too much time to respond,返回502 处理步骤: 1.查看日志,发现unicorn端口被占用 1sudo gitlab-ctl tail 2.修改unicorn端口 12gitlab-ctl stop # 停止gitlabvi /etc/gitlab/gitlab.rb # 3.应用配置,检查是否生效 123sudo gitlab-ctl reconfigure # 应用配置sudo gitlab-ctl restart # 重启服务lsof -i:8081 # 检查是否生效 More info: GitLab官网]]></content>
      <tags>
        <tag>git</tag>
        <tag>环境部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部署Gitea]]></title>
    <url>%2F2016%2F03%2F04%2F%E9%83%A8%E7%BD%B2Gitea%2F</url>
    <content type="text"><![CDATA[Gitea是一个极易安装，运行非常快速，安装和使用体验良好的自建Git服务,支持Linux、macOS和Windows以及各种架构(x86，amd64，还包括ARM和 PowerPC)。文章介绍在Centos7.5环境下搭建Gitea。 Quick Guide前置 1.安装MySQL/Mariadb(版本大于5.5.3) 12345# Centos系统yum install -y mariadb-server # 安装mariadb-serversystemctl start mariadb.service # 启动服务systemctl enable mariadb.service # 添加到开机启动mysql # 本地登录Mariadb 12UPDATE mysql.user SET password = PASSWORD('123') WHERE USER = 'root'; # 修改密码FLUSH PRIVILEGES; Ubuntu系统和Debian系统 1wget -O install.sh http://download.bt.cn/install/install-ubuntu.sh &amp;&amp; sudo bash install.sh 2.安装Git 12345# CentOS系统yum -y install git# Debian和Ubuntu系统apt-get -y install git 安装 1.安装Gitea 123wget -O gitea https://dl.gitea.io/gitea/1.4.0/gitea-1.4.0-linux-amd64chmod +x gitea./gitea web 2.用浏览器访问http://&lt;server_ip&gt;:3000进行初始配置登录 1sudo EXTERNAL_URL="http://&lt;server_ip:port&gt;" yum install -y gitlab-ee Docker方式安装 1.预置 1234567# 安装并启动Dockercurl -sSL https://get.docker.com/ | shservice docker start# 安装Docker Composecurl -L https://github.com/docker/compose/releases/download/1.17.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-compose 2.创建并进入gitea目录 12345# 创建并进入gitea目录mkdir gitea &amp;&amp; cd gitea# 创建并编辑docker-compose.yml文件nano docker-compose.yml 3.创建并编辑docker-compose.yml文件(配置内容复制进去) 1nano docker-compose.yml 1234567891011121314151617181920212223242526272829303132333435version: "2"networks: gitea: external: falseservices: server: image: gitea/gitea:latest environment: + USER_UID=1000 + USER_GID=1000 restart: always networks: + gitea volumes: + ./gitea:/data ports: + "3000:3000" + "222:22" depends_on: + db db: image: mysql:5.7 restart: always environment: + MYSQL_ROOT_PASSWORD=gitea + MYSQL_USER=gitea + MYSQL_PASSWORD=gitea + MYSQL_DATABASE=gitea networks: + gitea volumes: + ./mysql:/var/lib/mysql 3.运行docker-compose.yml文件 1docker-compose up -d 4.用浏览器访问http://&lt;server_ip&gt;:3000进行初始配置登录 问题 1.访问http://&lt;server_ip&gt;:3000失败 原因:需要关闭防火墙，或者打开对应的3000端口 12345678# CentOS 7systemctl stop firewalld.servicesystemctl disable firewalld.service# 其它系统iptables -I INPUT -p tcp --dport 3000 -j ACCEPTservice iptables save service iptables restart 2.ERROR: Failed to Setup IP tables: Unable to enable SKIP DNAT rule 原因:端口被占用重启docker服务，或者修改配置 1service docker restart More info: Github地址]]></content>
      <tags>
        <tag>git</tag>
        <tag>环境部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub使用指导]]></title>
    <url>%2F2016%2F02%2F13%2FGitHub%E4%BD%BF%E7%94%A8%E6%8C%87%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[GitHub是一个面向开源及私有软件项目的托管平台，因为只支持Git作为唯一的版本库格式进行托管，故名GitHub。文章介绍Git的使用指导。 Quick Guide前置注册注册账户 寻找牛人 GitHub上的代码库本身：尤其是：Explore、热门关注信息库两个栏目 GitHub官方推荐：GitHub自身的官方博客与GitHub员工们的个人博客推荐的项目与开发者 各类社交媒体上提到的的GitHub库：尤其是Hacker News上提到的GitHub库。 搜索小技巧 使用场景 使用方法 样例 搜索百科大全 xxx awesome java awesome 找例子 xxx simple java email simple 找空项目架子 xxx starter SpringBoot starter 找技术教程 xxx tutorial python tutorial 生产力小技巧给git库做标签 codeshelver： 观察的项目如果多了，怎么管理？用codeshelver，安装扩展之后，可以对GitHub项目做标签。 利用git与github做wiki gollum： gollum是一个基于git的轻型wiki系统。 监测重点项目 GitHubwatcher: GitHubwatcher适用于通知不频繁的情景。 GitHub官方资源GitHub官方列出了一些有用的脚本与书签。 社区驱动的安装与配置文件GitHub中各类配置文件层出不穷，一些常用的： osh-my-zsh：将终端从bash改为zsh之后，可考虑安装社区驱动的zsh配置文件，含有多个插件。可参考旧文zsh与oh-my-zsh gitignore：GitHub官方出品 yourchili:服务器各类安装shell，比如安装nginx等。 用途写作早在2008年，就有技术图书作者通过Git来写作，以下是示范： Node.js初学者教材，中文版在这里。 backbone基础 Sinatra教程 你能想到的技术前沿话题，大多能在GitHub找到相应的培训材料或者开源图书。 个人写作照样适用。在前文理想的写作环境：Git+GitHub+Markdown+Jekyll，我已经格外赞美过这些美好事物了。 暖色调的灯光，足够宽度的工作台，听着清脆的键盘声音，基于Git、GitHub、Markdown与Jekyll来写作，不担心写废与排版，只关注最纯粹的写作，是一种享受。我有时候会想，如果Git、Github、Markdown、Jekyll，再加上Yaml、Json的作者，让这些作者们重新来设计今天互联网基础架构偏文本的部分，会诞生一些什么？ 个人博客可以在Github上快速搭建一个基于jekyll的博客系统 Jekyll：参考告别wordpress，拥抱jekyll Octopress：参考Ruby开源项目介绍(1)：octopress——像黑客一样写博客 GitHub Pages：参考GitHub Pages 演讲借助于GitHub，可以享受更纯粹、更酷的演讲 通过speakerdeck更好的分享ppt文档 使用GitHub著名传教士、Progit作者Scott Chacon开发的showoff 来自开源社区的其他演讲库impress.js 找工作因为GitHub上的代码无法造假，也容易通过你关注的项目来了解知识面的宽度与深度。现在越来越多知名公司活跃在GitHub，发布开源库并招募各类人才 fredwu是Ruby中文社区活跃份子，他的开源项目angel_nest，一个天使投资与创业者对接的网站，适合Ruby初学者升级为Ruby中级开发者时学习，也在Hacker News上被热烈讨论过，让我们来看看他的简历：http://resume.GitHub.com/?fredwu 简历生成器:登陆网站GitHub简历生成器，填入你的GitHub网站用户名即可。 第三方网站提供基于GitHub的人才招聘服务，例如： GitHire:通过它，可以找出你所在地区的程序员。 Gitalytics.com：通过它，能评估某位程序员在GitHub、LinkedIn、StackOverflow、hackernews等多个网站的影响力。 链接与资源 图形化客户端 GitHub for Mac (OSX, 免费) 指南和手册 GitHub 帮助 More info: Github 简明指南 如何高效利用GitHub]]></content>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git流程]]></title>
    <url>%2F2016%2F01%2F13%2FGit%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[文章介绍Git的项目工作流程。 Quick Guide基本流程模块 Workspace：工作区 就是你在电脑里能看到的目录。 Index / Stage：暂存区 英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 Repository：仓库区（或本地仓库） 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Remote：远程仓库 Git服务器的仓库(自己搭建或者托管平台),存储对应项目代码 一般工作流程如下 git clone:克隆 Git 资源作为工作目录。 在克隆的资源上添加或修改文件。注意：修改前保证代码的最新，不然提交可能产生冲突需要解决（git pull） git add:提交修改或者新增到暂存库。 git diff:在提交前查看修改。错误，可以撤回提交（git reset HEAD） git commit：提交修改到本地仓库。如果错误，可以撤回提交（git reset commit_id 或 git revert） git push:提交修改到远端仓库。 更新代码 git fetch origin master 从远程的origin的master主分支下载最新的版本到origin/master分支上 git stash 把当前修改放入暂存库 git log -p master origin/master 比较本地的master分支和origin/master分支的差别 git merge origin/master 合并master代码到当前分支 git stash pop 把修改从暂存看恢复回来来 流程类型1.集中式工作流类似Subversion，集中式工作流让你无需去适应一个全新流程就可以体验Git带来的收益。这个工作流也可以作为向更Git风格工作流迁移的友好过渡。 常用命令1234567891011# 1.合并上游的修改到自己的仓库git pull --rebase origin master# 2.查看冲突文件git status# 3.修改完成后，用老套路暂存这些文件，并让git rebase完成剩下的事git add &lt;some-file&gt; git rebase --continue# 4.修改完推送git push origin master# 如果你碰到了冲突，但发现搞不定，不要惊慌。只要执行下面这条命令，就可以回到你执行git pull --rebase命令前的样子git rebase --abort 2.功能分支工作流功能分支工作流以集中式工作流为基础，不同的是为各个新功能分配一个专门的分支来开发。这样可以在把新功能集成到正式项目前，用Pull Requests的方式讨论变更。 常用命令1234567# 1.在开始开发功能前，使用下面的命令新建一个分支：git checkout -b marys-feature master# 2.这个新分支上，小红按老套路编辑、暂存和提交修改，按需要提交以实现功能git statusgit add &lt;some-file&gt;git commitgit push -u origin marys-feature 3.Gitflow工作流Gitflow工作流通过为功能开发、发布准备和维护分配独立的分支，让发布迭代过程更流畅。严格的分支模型也为大型项目提供了一些非常必要的结构。 常用命令123456789101112131415161718192021222324252627282930313233343536373839404142# 1.创建开发分支git branch developgit push -u origin develop# 2.基于develop分支产生功能分支git checkout -b some-feature develop# 3.老套路添加提交到各自功能分支上：编辑、暂存、提交：git statusgit add &lt;some-file&gt;git commit# 4.功能开发完合并到开发分支git pull origin developgit checkout developgit merge some-featuregit pushgit branch -d some-feature# 5.准备发布git checkout -b release-0.1 develop# 6.完成发布，合并修改到master分支和develop分支上，删除发布分支git checkout mastergit merge release-0.1git pushgit checkout developgit merge release-0.1git pushgit branch -d release-0.1# 7.发布分支是作为功能开发（develop分支）和对外发布（master分支）间的缓冲。只要有合并到master分支，就应该打好Tag以方便跟踪。git tag -a 0.1 -m "Initial public release" mastergit push --tags# 1.线上发现bug，从master分支上拉出了一个维护分支，提交修改以解决问题，然后直接合并回master分支git checkout -b issue-#001 master# Fix the buggit checkout mastergit merge issue-#001git push# 2.新加这些重要修改需要包含到develop分支，并删除维护分支git checkout developgit merge issue-#001git pushgit branch -d issue-#001 4.Forking工作流Forking工作流是分布式工作流，充分利用了Git在分支和克隆上的优势。可以安全可靠地管理大团队的开发者（developer），并能接受不信任贡献者（contributor）的提交。 常用命令：12345678910111213141516171819202122# 1.项目维护者初始化正式仓库git init --bare /path/to/repo.git# 2.开发者fork正式仓库git clone https://user@bitbucket.org/user/repo.git# 3.orking工作流需要2个远程别名 —— 一个指向正式仓库，另一个指向开发者自己的服务端仓库。别名的名字可以任意命名，常见的约定是使用origin作为远程克隆的仓库的别名 （这个别名会在运行git clone自动创建），upstream（上游）作为正式仓库的别名。git remote add upstream https://bitbucket.org/maintainer/repo# 4.开发者开发自己的功能git checkout -b some-feature# Edit some codegit commit -a -m "Add first draft of some feature"# 5.用git pull命令获得新的提交git pull upstream master# 6.开发者发布自己的功能git push origin feature-branch# 7.使用Pull Request提交到正式仓库# 8.维护者需要从开发者的服务端仓库中fetch功能分支， 合并到他本地的master分支git fetch https://bitbucket.org/user/repo feature-branch# 查看变更git checkout mastergit merge FETCH_HEAD# 9.开发者和正式仓库做同步git push origin master 5.Pull RequestsPull requests是Bitbucket提供的让开发者更方便地进行协作的功能，提供了友好的Web界面可以在提议的修改合并到正式项目之前对修改进行讨论。 开发者向团队成员通知功能开发已经完成，Pull Requests是最简单的用法。 开发者完成功能开发后，通过Bitbucket账号发起一个Pull Request。 这样让涉及这个功能的所有人知道要去做Code Review和合并到master分支。 在功能分支工作流中使用Pull Request 在Gitflow工作流中使用Pull Request 在Forking工作流中使用Pull Request 企业日常开发模式探索解决的需求场景如下： 能支持日常迭代开发、紧急线上bug修复、多功能并行开发 大概50人左右的团队，平日迭代项目较多，且周期短（1~2周一个迭代） 能够通过tag重建整个系统 支持code review 所有上线的代码必须都是经过测试保证，且能自动同步到下一次的迭代中 能和公司的项目管理/持续集成系统整合 迭代需求会、冲刺会后确定本次迭代的目标后，将迭代内容视为一个项目，在 Gitlab 上创建一个 Repository，初始化工程代码结构，根据上线日期，比如20150730上线，开出分支 release20150730、dev20150730 两个分支，dev 分支作为日常开发主干分支，release 分支作为提测打包、Code Review 的分支。 迭代开始，日常开发进行中，开发人员在 dev 分支上进行 Commit、Push 代码，并且解决掉日常协同开发中的冲突等问题，等到达到提测条件的时候，提测者，首先 Merge Master 分支上的最新代码 git merge --no-ff origin/master ，使得 Master 分支上的变更更新到迭代开发分支dev上面，之后，在 Gitlab 上面发起 pull request 请求，并指定 Code Review 人，请求的分支选择本次上线的 release 分支，即 release20150730。 被指定 Code Review 的人，对发起者的代码 Review 后，决定是否可以提交测试，若有问题，评论注释代码后，提交者对代码进行进行修改，重复步骤2，直到代码 Review 者认为 Ok。之后便可以借助自己公司的打包部署，对这些代码发布到测试环境验证。 步骤2-3重复多次后，就会达到一个稳定可发布的版本，即上线版本，上线后，将 release 版本上面最后的提交（图中0.2.4上线对应处）合并到 Master 分支上面，并打 Tag0.3。至此，一次完整的迭代开发完成。 若此次上线后，不久发现生产环境有 Bug 需要修复，则从 Tag 处新开分支 release_bugfix_20150731、dev_bugfix_20150731 ，开发人员从 dev_bugfix_20150731分支上进行开发，提测code review在 release_bugfix_20150731 分支上，具体步骤参考2-3，测试环境验证通过后，发布到线上，验证OK，合并到 Master 分支，并打 Tag0.2.3，此次 Bug 修复完毕，专为解 Bug 而生的这两个分支可以退伍了，删除release_bugfix_20150731、dev_bugfix_20150731两分支即可。（所有的历史 Commit 信息均已经提交到了 Master 分支上，不用担心丢失） master：master永远是线上代码，最稳定的分支，存放的是随时可供在生产环境中部署的代码，当开发活动告一段落，产生了一份新的可供部署的代码时，发布成功之后，代码才会由 aone2 提交到 master，master 分支上的代码会被更新。应用上 aone2 后禁掉所有人的 master的写权限 develop：保存当前最新开发成果的分支。通常这个分支上的代码也是可进行每日夜间发布的代码，只对开发负责人开放develop权限。 feature: 功能特性分支，每个功能特性一个 feature/ 分支，开发完成自测通过后合并入 develop 分支。可以从 master 或者develop 中拉出来。 hotfix: 紧急bug分支修复分支。修复上线后，可以直接合并入master。 master：master永远是线上代码，最稳定的分支，存放的是随时可供在生产环境中部署的代码，当开发活动告一段落，产生了一份新的可供部署的代码时，发布成功之后，代码才会由 aone2 提交到 master，master 分支上的代码会被更新。应用上 aone2 后禁掉所有人的 master的写权限 develop：保存当前最新开发成果的分支。通常这个分支上的代码也是可进行每日夜间发布的代码，只对开发负责人开放develop权限。 feature: 功能特性分支，每个功能特性一个 feature/ 分支，开发完成自测通过后合并入 develop 分支。可以从 master 或者develop 中拉出来。 hotfix: 紧急bug分支修复分支。修复上线后，可以直接合并入master。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2F2015%2F12%2F13%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Git是一个开源的分布式版本控制系统，用于敏捷高效地处理项目。文章介绍Git的常用命令。 Quick Guide基本命令 1.工作区域 工作区(workspace)：就是你在电脑里能看到的目录。 暂存区(Index/Stage)：英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 版本库(master):工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 远端仓库(Remote): Git服务器的仓库(自己搭建或者托管平台),存储对应项目代码 2.文件的状态 未修改(Origin) 已修改(Modified) 已暂存(Staged) 已提交(Committed) 已推送(Pushed) 3.基本操作 git add:把工作区的文件放入暂存区 12git add &lt;path&gt; # 把工作区的文件修改提交到暂存区git add . # 提交工作区的所有文件修改 git commit：把文件从暂存区提交进本地仓库 123git commit -m "the commit message" # 提交当前暂存区的修改记录git commit -a # 会先把所有已经track的文件的改动`git add`进来，然后提交。git commit --amend # 增补提交，会使用与当前提交节点相同的父节点进行一次新的提交，旧的提交将会被取消。 git push:把文件从本地仓库推送进远程仓库 12git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; # 从 Git 本地仓库中更新到远端仓库git push origin [tagname] # 分享标签 4.检查修改以及回滚 git diff:在提交前工作目录中当前文件和暂存区域快照之间的差异,。如果错误，可以撤回提交（git reset HEAD） 12345678git diff &lt;file&gt; # 比较当前文件和暂存区文件差异git diff &lt;id1&gt;&lt;id1&gt;&lt;id2&gt; # 比较两次提交之间的差异git diff &lt;branch1&gt; &lt;branch2&gt; # 在两个分支之间比较git diff # 比较未修改和已修改后差异---已修改，未暂存git diff --staged # 比较暂存区和版本库差异---已未暂存，未提交git diff --cached # 比较暂存区和版本库差异---已未暂存，未提交git diff &lt;当前分支&gt; &lt;远程主机名/远端分支&gt; # 比较本地分支和远端分支的差异---已提交，未推送git diff --stat # 仅仅比较统计信息 git reset:将HEAD指向的位置改变为之前存在的某个版本,用于撤消之前的一些操作(add, commit) 12345git reset --hard # 回退到上个版本，放弃版本后的修改、暂存和提交git reset --mixed # mixed是默认参数，回退到上个版本，放弃版本后的暂存和提交git reset --soft # 回退到上个版本，放弃版本后的提交git reset --hard HEAD~n # 回退n个版本git reset --hard &lt;commit_id&gt; # 回滚到指定版本，修改不能保存 git revert:同reset，只不过撤销操作之前和之后的commit和history都会保留，并且把这次撤销作为一次最新的提交 123git revert HEAD # 撤销前一次 commitgit revert HEAD^ # 撤销前前一次 commitgit revert &lt;commit-id&gt; # 撤回指定commit-id 5.其他基本命令 git init：初始化一个 Git 仓库 1git init newrepo # 指定目录作为Git仓库 git config：命令用于获取并设置存储库或全局选项 12345git config --global user.name "xiaoming" # 设置全局用户名git config --global user.email "xiaoming@gmail.com" # 设置全局邮箱git config --global core.editor emacs # 设置编缉器git config --global merge.tool vimdiff # 设置比较工具，比较工具用来解决合并时的冲突git config --list # 检查配置 git clone:克隆 Git 资源作为工作目录。 1git clone &lt;repo&gt; &lt;directory&gt; # 从现有 Git 仓库中拷贝项目克隆到指定的目录 git pull:是从远程获取最新版本到本地，并自动merge 1git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; # 从 Git 远端仓库中更新到本地仓库 git status:显示文件修改是否被暂存或者tracked。 1git status git branch：用于列出，创建或删除分支。 123git branch # 查看当前有哪些分支git branch &lt;分支&gt; # 新建分支git branch -d &lt;分支&gt; # 删除分支 git checkout:用于切换分支或恢复工作树文件。 123git checkout &lt;文件&gt; # 还原文件的修改git checkout &lt;分支&gt; # 切换分支git checkout -b &lt;分支&gt; # 创建并切换分支 git log:用于显示提交日志信息 1git log [&lt;options&gt;] [&lt;revision range&gt;] [[\--] &lt;path&gt;…] git stash:用于将改过的被追踪的文件和暂存的变更储藏在脏工作目录中（refs/stas） 123git stash # 将当前的修改和暂存储藏存储起来，用于更新远端分支产生冲突时候git stash list # 查看储藏git stash pop # 释放储藏 git fetch:命令用于从另一个存储库下载对象和引用。 12git fetch origin # 从远程refs/heads/命名空间复制所有分支，并将它们存储到本地的refs/remotes/origin/命名空间中git fetch &lt;远程主机名&gt; &lt;分支名&gt; # 更新远程主机的分支到本地 git merge:用于将两个或两个以上的开发历史加入(合并)一起 12git merge &lt;分支&gt;1… &lt;分支2&gt;… # 合并分支到当前分支git merge &lt;远程主机名/分支名&gt; # 合并fetch的分支到当前分支 git rebase:用于把一个分支的修改合并到当前分支,放弃一个分支的记录 12git rebase &lt;分支&gt;1… &lt;分支2&gt;… # 合并分支到当前分支git rebase &lt;远程主机名/分支名&gt; # 合并fetch的分支到当前分支 git remote:管理一组跟踪的存储库 12git remote -v # 列出已经存在的远程分支的详细信息git remote add &lt;shortname&gt; &lt;url&gt; # 添加远程仓库 git help:显示有关Git的帮助信息。 12git help &lt;verb&gt; # 显示命令的帮助信息git &lt;verb&gt; --help # 显示命令的帮助信息 其他 git rm：用于从工作区和索引中删除文件 1git rm [-f | --force] [-n] [-r] [--cached] [--ignore-unmatch] [--quiet] [--] &lt;file&gt;… git mv：用于移动或重命名文件，目录或符号链接 1git mv &lt;options&gt;… &lt;args&gt;… git mergetool:用于运行合并冲突解决工具来解决合并冲突 1git mergetool [--tool=&lt;tool&gt;] [-y | --[no-]prompt] [&lt;file&gt;…] git tag：用于创建，列出，删除或验证使用GPG签名的标签对象。 1234567git tag # 列显已有的标签git tag -a &lt;tag-name&gt;-m 'version info' # 创建标签git tag -s &lt;tag-name&gt;-m 'version info' # 签署标签git tag -d # 删除标签git tag &lt;tag-name&gt; # 创建轻量级标签git tag -v &lt;tag-name&gt; # 验证标签git tag -a &lt;tag-name&gt; &lt;command-id&gt; # 后期加注标签 git submodule:用于初始化，更新或检查子模块(另外一个仓库) 123git submodule add &lt;url&gt; # 添加子模块git submodule init # 初始化本地配置文件的子模块git submodule update # 更新子模块 git show:用于显示各种类型的对象 1git show [options] &lt;object&gt;…​ # 显示一个或多个对象(blobs，树，标签和提交) git shortlog:用于汇总git日志输出 1git shortlog # 返回这个 git repository 底下每个用户进行 commit 的次数，以及每次 commit 的注释 git describe:显示离当前提交最近的标签。 1git describe [--all] [--tags] [--contains] [--abbrev=&lt;n&gt;] [&lt;commit-ish&gt;…​] More info: Git 完整命令手册]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部署Git]]></title>
    <url>%2F2015%2F11%2F23%2F%E9%83%A8%E7%BD%B2Git%2F</url>
    <content type="text"><![CDATA[这是一个简单的指导说明，介绍如何git部署和配置使用. Quick Start安装下载地址 配置Git 首先在本地创建ssh key,后面的`your_email@youremail.com`改为你在github上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。 1ssh-keygen -t rsa -C "your_email@youremail.com" 💡 默认在 .ssh下面生成两个两个文件 私钥:id_rsa 公钥:id_rsa.pub 在~/下生成.ssh文件夹，进去，打开id_rsa.pub，复制里面的key。 💡 注:修改公钥最后的字符只会影响名字 回到github上，进入 Account Settings（账户配置），左边选择SSH Keys，Add SSH Key,title随便填，粘贴在你电脑上生成的key。 为了验证是否成功，在git bash下输入： 1ssh -T git@github.com 如果是第一次的会提示是否continue，输入yes就会看到：You’ve successfully authenticated, but GitHub does not provide shell access 。这就表示已成功连上github。 设置username和email 12git config --global user.name "your name"git config --global user.email "your_email@youremail.com" 进入要上传的仓库，右键git bash，添加远程地址： 1git remote add origin git@github.com:yourName/yourRepo.git 使用多个密钥 1.通过上面方式创建多对密钥和公钥,只不过每次创建需要修改不同名称,防止第二次覆盖 2.修改.ssh下面的config文件,按照下面模板每一对密钥和公钥需要配置对应 Host和公钥位置 3.更新代码需要把github.com替换成 对应配置Host 链接与资源 图形化客户端 Tower (OSX) Source Tree (OSX, 免费) GitBox (OSX, App Store) More info: 像 git 那样思考 图解 Git]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部署Tomcat]]></title>
    <url>%2F2015%2F10%2F26%2F%E9%83%A8%E7%BD%B2Tomcat%2F</url>
    <content type="text"><![CDATA[Tomcat 是由 Apache 开发的一个 Servlet 容器，实现了对 Servlet 和 JSP 的支持，并提供了作为Web服务器的一些特有功能。文章介绍如何在居于Centos7.5安装Tomcat。 Quick Deploy部署准备 1.参照下表格检查环境的JDK版本是否满足(Tomcat 8.5 要求 JDK 版本为 1.7 以上) Servlet Spec JSP Spec EL Spec WebSocket Spec JASPIC Spec Apache Tomcat Version Latest Released Version Supported Java Versions 4.0 2.3 3.0 1.1 1.1 9.0.x 9.0.6 8 and later 3.1 2.3 3.0 1.1 1.1 8.5.x 8.5.29 7 and later 3.1 2.3 3.0 1.1 N/A 8.0.x (superseded) 8.0.50 (superseded) 7 and later 3.0 2.2 2.2 1.1 N/A 7.0.x 7.0.85 6 and later(7 and later for WebSocket) 2.5 2.1 2.1 N/A N/A 6.0.x (archived) 6.0.53 (archived) 5 and later 2.4 2.0 N/A N/A N/A 5.5.x (archived) 5.5.36 (archived) 1.4 and later 2.3 1.2 N/A N/A N/A 4.1.x (archived) 4.1.40 (archived) 1.3 and later 2.2 1.1 N/A N/A N/A 3.3.x (archived) 3.3.2 (archived) 1.1 and later 1whereis java 2.安装JDK(详细请自行查询) 安装和配置 1.下载安装包 1wget http://mirrors.hust.edu.cn/apache/tomcat/tomcat-8/v8.5.37/bin/apache-tomcat-8.5.37.tar.gz 2.解压安装包 1tar -xzvf apache-tomcat-8.5.37.tar.gz 3.启动 Tomcat 1./apache-tomcat-8.5.37/bin/startup.sh 4.通过curl或者浏览器访问 1curl http://localhost:8080 重要目录说明 bin - Tomcat 脚本存放目录（如启动、关闭脚本）。 .sh 文件用于 Unix 系统,.bat 文件用于 Windows 系统 conf - Tomcat 配置文件目录 server.xml 配置文件中的根元素。它的属性代表了整个 servlet 容器的特性。 logs - Tomcat 默认日志目录 webapps - webapp 运行的目录 web 工程发布（例如jenkin） 1.打包好的 war 包放在 Tomcat 安装目录下的 webapps 目录下 1mv jenkins.war apache-tomcat-8.5.37/webapps/ 2.启动Tomcat(Tomcat 会自动解压 webapps 目录下的 war 包) 1./apache-tomcat-8.5.37/bin/startup.sh 3.通过curl或者浏览器访问 1curl http://localhost:8080/jenkins web 项目路径结构 webapp 站点根目录(例如解压后的jenkins目录) META-INF 存放工程自身相关的一些信息，元文件信息，通常由开发工具，环境自动生成。 MANIFEST.MF 配置清单文件 WEB-INF Java web应用的安全目录。所谓安全就是客户端无法访问，只有服务端可以访问的目录 classes 存放程序所需要的所有 Java class 文件 *.class 程序需要的 class 文件 *.xml 程序需要的 xml 文件 lib 库文件夹 *.jar 程序需要的 jar 包 web.xml Web应用程序的部署描述文件。它是工程中最重要的配置文件，它描述了 servlet 和组成应用的其它组件，以及应用初始化参数、安全管理约束等。 自定义的目录 自定义的资源文件 More info: Tomcat Wiki]]></content>
      <tags>
        <tag>环境部署</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部署博客]]></title>
    <url>%2F2015%2F09%2F23%2F%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[这是一个简单的指导说明，介绍如何使用github和hexo搭建一个自己的博客. Quick Start部署准备 1.本地安装git和nodejs 2.去github申请账号,并创建一个仓库(仓库名为账户名.github.io) 安装和配置hexo 1.安装hexo 1$ npm install -g hexo-cli 2.安装git部署工具 1$ npm install hexo-deployer-git --save 3.创建hexo的工程目录 1$ hexo init source.账户名.github.io 4.设置git部署仓库 123456$ cd source.账户名.github.io$ vim _config.yml$ deploy: type: git repo: https://github.com/账户名/账户名.github.io.git branch: master 部署hexo 1.克隆仓库到本地 1$ git clone https://github.com/账户名/账户名.github.io.git 2.创建分支 123$ cd 账户名.github.io$ git checkout -b source$ git branch -a 3.移动hexo工程到仓库 1$ mv source.账户名.github.io/* 账户名.github.io 4.保存源码到仓库 123$ git add -A$ git commit -m "add source file"$ git push origin source 5.部署hexo 1$ hexo d 6.访问博客 1$ https://账户名.github.io 修改主题 1.下载主题放入themes目录下 2.修改_config.yml的theme为对应主题名 3.使主题生效 1234567# 清理静态文件hexo clean# 生成静态文件hexo g # 部署hexo dhexo d More info: 优化主题 hexo常用命令]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
